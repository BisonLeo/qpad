import "system.jc"
import "gui2d.jc"
import "javascript.jc"
import "text-box.jc"
import "tex-like.jc"
import "hunspell.jc"
import "smart-find.jc"
import "code-parser.jc"
import "g-l.jc"
import "leak-detection.jc"
import "encoding.jc"
import System.Math.*
import System.Algorithm.*
import System.Console.*
import Gui2D.detail.*
import Javascript.*
import TextBox.*
import TextBox.detail.*
import TexLike.*
import SmartFind.*
import CodeParser.*
import Encoding.*
import GL.*
USE_BLIT_FRAMEBUFFER=0

//text -> i64[]
auto WrapTextSimple(CHyphenator hyp,string sblock, TFont font,i64 w_line, int m_tab_width)
	styles=new CStyleHolder(){m_styles:[new CStyle(){font:font}],m_enable_ligatures:0}
	ret=new i64[]
	foreach s,I in sblock.TokenizeEx("\n",sblock.TOKENIZE_ALLOW_EMPTY|sblock.TOKENIZE_INCLUDE_SEPARATOR)
		n0=ret.n
		(atoms,tail_style_id,indent_point_atom)=TextToLayoutAtom(hyp,s,m_tab_width,w_line,0,styles,CEmbededObject[].NULL)
		line_breaks=GreedyLayoutGeneral(atoms,w_line)
		GenerateTextLayout(
			styles,
			s,atoms,line_breaks,tail_style_id,
			int(I),0LL,w_line,s.EndsWith("\n"),0,
			inline(int style_id, int ccnt0,int ccnt1){
				//char range
				assert(ccnt0>=0&&ccnt1>ccnt0)
				ret.push((i64(ccnt1)<<32)+i64(ccnt0))
				//atom_i=ret.back()
				//value1=int(atom_i>>32)
				//value0=int(atom_i)
				//assert(value0>=0&&value1>value0)
			},
			inline(i64 dw,int ccnt){
				//space
				assert(dw>=0LL&&dw==i64(int(dw)))
				ret.push((i64(0x80000000|int(ccnt))<<32)+i64(dw))
				//atom_i=ret.back()
				//value1=int(atom_i>>32)
				//value0=int(atom_i)
				//if value1>=0:
				//	if !(value0>=0&&value1>value0):
				//		Writeln(ccnt,' ',dw)
				//	assert(value0>=0&&value1>value0)
			},
			inline(i64 h_up,i64 h_line,int aflag_ccnt){
				//line
				//there is only one style, we know the heights
				assert(aflag_ccnt>=0)
				ret.push((-1LL<<32)+i64(aflag_ccnt))
				//atom_i=ret.back()
				//value1=int(atom_i>>32)
				//value0=int(atom_i)
				//if value1>=0:assert(value0>=0&&value1>value0)
			},
			inline(int oid, int ccnt){
				//object
				//do nothing
			})
		if n0<ret.n:
			//shove back real newlines to \n
			high_dword=int(ret[n0]>>32)
			if high_dword==-1:
				ccnt=(int(ret[n0])&ATOM_MASK_CCNT)
				if ccnt>0&&sblock[ccnt-1]=='\n':
					ret[n0]-=1LL
	return ret

/*
or-ing tokens
	<
	<script
failure case:
	a lot of \\ \"
	token ambiguity cross the boundary
	ignore
	---
	an escape char mode
		self-zeroing token eater
	it breaks the tokenization assumption
*/
REAL_TYPE_MOV=0;
REAL_TYPE_XOR=1;
REAL_TYPE_ADD=2;
//DEFAULT_WRAP_WIDTH_IN_CHARS=2048LL
/*
at 65536 chars we have about 27 bits in m_wrap_width_in_fp, that leaves 37 bits for line numbers
this is well enough for a wiki dump
*/
DEFAULT_WRAP_WIDTH_IN_CHARS=65536LL
GRACEFUL_WORD_SIZE=256
MAX_ALLOWED_INDENTATION=20
MAX_SPECIAL_COLOR_ID_SIZE=iptr(GRACEFUL_WORD_SIZE)

struct TBracketType
	int type
	int[] tok0,tok1

//0+=0 for non-inc
struct TBDFATransition
	i32 m_and
	i32 m_xor
	i16 m_delta
	u16 m_next_state

struct TColorRule
	string color_name
	//int bid
	//int extend_0,extend_1
	int bmask
	int extend_flags

struct TKeyword
	string s
	string color_name

class CLanguageDescription
	//int[] m_enabled_from_inside
	int[] m_all_key_states
	int[] m_token_enabling_masks
	int[] m_id_from_key_state
	u8[] m_char_map
	u16[] m_bigchar_dfa
	i16[] m_bigchar_dfa_ops
	int m_total_state_size
	int m_context_size
	int m_n_char_types
	int m_n_key_states
	u8[] m_token_lengths
	int m_n_tokens
	//the initial state is always 0
	/////////
	//TBracketType[] m_bracket_types
	TBDFATransition[] m_bracket_dfa
	TColorRule[] m_coloring_rules
	/////////
	string m_default_color_name
	string[] m_word_color_names
	int[] m_word_dfa
	u8[] m_word_char_map
	uint4 m_word_char_set
	int m_n_word_char_types
	int[] m_word_dfa_initial_state
	int[] m_word_dfa_initial_state_triggered
	string m_trigger_chars
	/////////
	int m_color_id_spell_check
	/////////
	int[] m_key_decl_color_ids
	int m_kd_color

auto DrawTilde(TFont fnt_tilde,float x0,float x1,float y,int C)
	//just use a glyph - '~' in the icon font!
	//its height is 0.03*h, width is 1*h...
	h_tilde_raw=g_renderer.GetCharacterHeight(fnt_tilde)
	w_tilde=g_renderer.GetCharacterAdvance(fnt_tilde,int('~'))
	for(x=x0;x<x1;x+=w_tilde)
		need_clipping=0
		if x+w_tilde>x1:
			need_clipping=1
			g_renderer.PushCliprect(x,y,x1-x,h_tilde_raw)
		g_renderer.DrawChar(fnt_tilde,x,y,C,int('~'))
		if need_clipping:
			g_renderer.PopCliprect()

HL_DISPLAY_MODE_EMBOLDEN=2
HL_DISPLAY_MODE_TILDE=3
OVERLAY_AE=0
OVERLAY_IME=1
//U_ELLIPSIS=0x2026
struct TEllipsisItem
	float x,y,scale
	int color
struct TOverlayItem
	i64 flatx
	i64 y,delta_x
	string s_text
	int type
	int sel0,sel1
	i64 w_strikeout
struct TTildeItem
	i64 ccnt0,ccnt1
	int color
class CCodeEmbededObject
	CLocator loc
	JSObject obj
	i64 dy//<measured in # lines
class CLayouter_programmer
	FLAG_HAS_TAB=1
	FLAG_HAS_ENTER=2
	/////////
	m_wrap_width_in_fp=0LL
	m_tab_width_in_fp=0LL
	m_tab_width=4
	m_wrap_width=0.f
	m_font=TFont()
	m_font_emboldened=TFont()
	m_bgcolor_selection=0xff800000
	m_color_overlay=0xff000000
	m_color_embolden=0xff000000
	m_color_virtual_diff_bold=0xff000000
	//////////////
	m_enable_advanced_wrapping=0
	CHyphenator m_hyp
	//////////////
	__pointer m_spell_checker
	string m_spell_checker_name
	long2[] m_current_frame_spell_errors
	TTildeItem[] m_current_frame_tildes
	float3[] m_current_frame_strikeouts
	int m_temporarily_disable_spell_check
	int m_enable_ceo_rendering
	//////////////
	//JSObject m_style
	CLanguageDescription m_lang
	int[] m_cached_colors
	int m_cached_colors_p_word_part
	int m_cached_color_virtual_hyphen
	//////////////
	//int[] m_char_width_cache_ascii
	//int[int] m_char_width_cache
	int[int] m_char_kerning_cache
	/////////////////
	m_hidden_ranges=new CLocator[]
	m_ceos=new CCodeEmbededObject[]
	i64 m_w_ellipsis
	m_ellipsis_items=new TEllipsisItem[]
	/////////////////
	CFileIndex m_file_index
	/////////////////
	charWidth=function(int ch){
		//if u32(ch)<u32(0x80):
		//	ret=m_char_width_cache_ascii[ch]
		//	if !ret:
		//		ret=max(int(float2fixed(g_renderer.GetCharacterAdvance(m_font,int(ch)))),1)+1
		//		m_char_width_cache_ascii[ch]=ret
		//else
		//	ret=m_char_width_cache[ch]
		//	if !ret:
		//		ret=max(int(float2fixed(g_renderer.GetCharacterAdvance(m_font,int(ch)))),1)+1
		//		m_char_width_cache[ch]=ret
		//return ret-1
		return max(int(float2fixed(g_renderer.GetCharacterAdvance(m_font,int(ch)))),1)
	}
	charKerning=function(int ch0,int ch1){
		if u32(ch0)>=65536u||u32(ch1)>=65536u:return 0
		key=(ch0<<16)+ch1
		ret=m_char_kerning_cache[key]
		if !ret:
			//we can get negative/0/positive, use 0x80000000 as the improbable
			ret=int(float2fixed(g_renderer.GetKerning(m_font,ch0,ch1)))^0x80000000
		return ret^0x80000000
	}
	charHeight=inline(){
		return float2fixed(g_renderer.GetCharacterHeight(m_font))
	}
	/////////////////
	//this thing isn't line-only
	name=function(){return "renderer"}
	stateSize=function(){return 5}
	/////////////////
	isLineOnly=function(){
		return m_enable_advanced_wrapping
	}
	PreprocessBlock=function(CEditableText caller,i64[] a,string s){
		if m_enable_advanced_wrapping:
			//-' '-1LL to avoid OOB values
			return WrapTextSimple(m_hyp,s, m_font,m_wrap_width_in_fp-charWidth(int(' '))-1LL, m_tab_width)
		else
			return i64[].NULL
	}
	/////////////////
	//final format: pre-tab width, has-tabbed-ness, tab-enter width, has-enter-ness, post-enter width, max width
	//do not use a render-central design
	AddString=function(i64[] a,i64[] pp,string s_context,string s,iptr ofs){
		w_pre_tab=a[0]
		w_tab_enter=a[1]
		w_post_enter=a[2]
		flags=int(a[3])
		w_max=a[4]
		if m_enable_advanced_wrapping:
			//the fancy mode only uses w_pre_tab
			w_pre_tab=_RenderText(MODE_BB,0LL,a,pp,s,ofs, u8[].NULL, 0LL,0LL,0LL,0LL,0.f,0.f,0.f)
			w_max=a[4]
			//flags|=FLAG_HAS_ENTER
		else
			foreach ch,I in Utf8Chars(s)
				if I>=ofs:break
				if ch=='\t':
					if !(flags&FLAG_HAS_ENTER):
						if !(flags&FLAG_HAS_TAB):
							flags|=FLAG_HAS_TAB
						else
							w_tab_enter=(w_tab_enter/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
					else
						w_post_enter=(w_post_enter/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
				else if ch=='\n':
					w_curline=0LL
					if !(flags&FLAG_HAS_ENTER):
						flags|=FLAG_HAS_ENTER
						w_curline=w_pre_tab
						if flags&FLAG_HAS_TAB:
							w_curline=(w_curline/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
						w_curline+=w_tab_enter
					else
						y=w_post_enter/m_wrap_width_in_fp
						w_curline=w_post_enter-y*m_wrap_width_in_fp
						w_post_enter=(y+1LL)*m_wrap_width_in_fp
					if w_max<w_curline:w_max=w_curline
				else if ch!='\r':
					dx=charWidth(ch)
					if !(flags&FLAG_HAS_ENTER):
						if !(flags&FLAG_HAS_TAB):
							w_pre_tab+=dx
						else 
							w_tab_enter+=dx
					else
						w_post_enter+=dx
			w_curline=0LL
			if !(flags&FLAG_HAS_ENTER):
				w_curline=w_pre_tab
				if flags&FLAG_HAS_TAB:
					w_curline=(w_curline/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
				w_curline+=w_tab_enter
			else
				y=w_post_enter/m_wrap_width_in_fp
				w_curline=w_post_enter-y*m_wrap_width_in_fp
			if w_max<w_curline:w_max=w_curline
		a[0]=w_pre_tab
		a[1]=w_tab_enter
		a[2]=w_post_enter
		a[3]=i64(flags)
		a[4]=w_max
	}
	Add=function(i64[] a,i64[] b){
		a_w_pre_tab=a[0]
		a_w_tab_enter=a[1]
		a_w_post_enter=a[2]
		a_flags=int(a[3])
		a_w_max=int(a[4])
		b_w_pre_tab=b[0]
		b_w_tab_enter=b[1]
		b_w_post_enter=b[2]
		b_flags=int(b[3])
		b_w_max=int(b[4])
		if a_flags&FLAG_HAS_ENTER:
			//a_w_post_enter
			a_w_post_enter+=b_w_pre_tab
			if b_flags&FLAG_HAS_TAB:
				a_w_post_enter=(a_w_post_enter/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
			a_w_post_enter+=b_w_tab_enter
			y=a_w_post_enter/m_wrap_width_in_fp
			w_curline=a_w_post_enter-y*m_wrap_width_in_fp
			if a_w_max<w_curline:a_w_max=w_curline
			if b_flags&FLAG_HAS_ENTER:
				a_w_post_enter=(y+1LL)*m_wrap_width_in_fp
			a_w_post_enter+=b_w_post_enter
		else if a_flags&FLAG_HAS_TAB:
			a_w_tab_enter+=b_w_pre_tab
			if b_flags&FLAG_HAS_TAB:
				a_w_tab_enter=(a_w_tab_enter/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
			a_w_tab_enter+=b_w_tab_enter
			if b_flags&FLAG_HAS_ENTER:
				a_flags|=FLAG_HAS_ENTER
				a_w_post_enter=b_w_post_enter
		else
			a_w_pre_tab+=b_w_pre_tab
			a_flags=b_flags
			a_w_tab_enter=b_w_tab_enter
			a_w_post_enter=b_w_post_enter
		//retest the first line for max - merging single-line a with non-single-line b
		if m_enable_advanced_wrapping:
			//don't max w_curline into it, it's shit in this mode
			a_w_max=a[4]
		else
			w_curline=a_w_pre_tab
			if a_flags&FLAG_HAS_TAB:
				w_curline=(w_curline/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
			w_curline+=a_w_tab_enter
			if a_w_max<w_curline:a_w_max=w_curline
		a[0]=a_w_pre_tab
		a[1]=a_w_tab_enter
		a[2]=a_w_post_enter
		a[3]=i64(a_flags)
		a[4]=max(a_w_max,b_w_max)
	}
	GetFlatX=inline(i64[] a){
		w_pre_tab=a[0]
		w_tab_enter=a[1]
		w_post_enter=a[2]
		flags=int(a[3])
		x=w_pre_tab
		if flags&FLAG_HAS_TAB:
			x=(x/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
		x+=w_tab_enter
		if flags&FLAG_HAS_ENTER:
			x=(x/m_wrap_width_in_fp+1LL)*m_wrap_width_in_fp
		x+=w_post_enter
		return x
	}
	GetFlatXEnMasse=inline(i64[] a){
		auto ret=new i64[a.n/5]
		for i=0:ret.n-1
			w_pre_tab=a[i*5+0]
			w_tab_enter=a[i*5+1]
			w_post_enter=a[i*5+2]
			flags=int(a[i*5+3])
			x=w_pre_tab
			if flags&FLAG_HAS_TAB:
				x=(x/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
			x+=w_tab_enter
			if flags&FLAG_HAS_ENTER:
				x=(x/m_wrap_width_in_fp+1LL)*m_wrap_width_in_fp
			x+=w_post_enter
			ret[i]=x
		return ret
	}
	XYToX=inline(i64 x,i64 y){
		hc=charHeight()
		return max(min(x,m_wrap_width_in_fp-1LL),0LL)+(y/hc)*m_wrap_width_in_fp
	}
	/////////////////
	//compare known-positive doubles as ints
	Compare=function(CEditableText ed,i64[] a,i64[] b){
		return __C_compare(GetFlatX(a),AddHiddenRanges(ed,b[0],b[1]))
	}
	SeekInBlock=function(CEditableText ed,i64 ccnt_base,i64[] a,i64[] pp,string s,i64[] b){
		if m_enable_advanced_wrapping:
			return iptr(_RenderText(MODE_SEEK,0LL,a,pp,s,s.n, u8[].NULL, b[0],b[1],0LL,0LL,0.f,0.f,0.f))
		//seeked into hidden text?
		x_goal=AddHiddenRanges(ed,b[0],b[1])
		x=GetFlatX(a)
		is_end=0
		if b[0]>=m_wrap_width_in_fp:
			is_end=1
		if b.n>2:
			//hint
			x_last_known=AddHiddenRanges(ed,b[2],b[3])
			ccnt_last_known=b[4]
			if u64(ccnt_last_known-ccnt_base)<u64(s.n):
				p=iptr(ccnt_last_known-ccnt_base)
				x=x_last_known
				foreach ch,I in Utf8Chars(s[p:])
					if ch=='\t':
						x=(x/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
					else if ch=='\n':
						x=(x/m_wrap_width_in_fp+1LL)*m_wrap_width_in_fp
					else if ch!='\r':
						dx=charWidth(ch)
						x+=dx
					if x>x_goal:
						if is_end:
							is_end=0
						else
							return I+p
				return s.n
		foreach ch,I in Utf8Chars(s)
			if ch=='\t':
				x=(x/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
			else if ch=='\n':
				x=(x/m_wrap_width_in_fp+1LL)*m_wrap_width_in_fp
			else if ch!='\r':
				dx=charWidth(ch)
				x+=dx
			if x>x_goal:
				if is_end:
					is_end=0
				else
					return I
		return s.n
	}
	/////////////////
	//long3 m_caret_overlay
	m_overlays=new TOverlayItem[]
	//JSObject m_overlay_obj
	i64 m_caret_offset
	JSObject m_tentative_editops
	JSObject m_virtual_diffs
	TOverlayItem[] m_precomputed_overlays_for_tentative_editops//need to reset in JS
	i64[] m_overlay_embolden_ranges
	SetTextStyle=function(JSObject obj){
		m_lang=obj["language"].as(CLanguageDescription)
		m_font=obj["font"].as(TFont)
		m_font_emboldened=obj["font_emboldened"].as(TFont)
		//m_char_width_cache_ascii=new int[128]
		//m_char_width_cache=new int[int]
		m_char_kerning_cache=new int[int]
		m_tab_width=obj["tab_width"].or(8)
		m_wrap_width=obj["wrap_width"].or(0.f)
		m_tab_width_in_fp=i64(m_tab_width)*charWidth(int(' '))
		m_hyp=obj["hyphenator"].as(CHyphenator)
		m_enable_advanced_wrapping=!!m_hyp
		if !(m_wrap_width>0.f):
			m_wrap_width_in_fp=DEFAULT_WRAP_WIDTH_IN_CHARS*charWidth(int(' '))
			m_wrap_width_in_fp=(m_wrap_width_in_fp/m_tab_width_in_fp)*m_tab_width_in_fp
			//Writeln(m_wrap_width_in_fp)
		else
			m_wrap_width_in_fp=(float2fixed(m_wrap_width)/m_tab_width_in_fp)*m_tab_width_in_fp
		obj["displayed_wrap_width"]=fixed2double(m_wrap_width_in_fp)
		////////////
		BeginRender(obj)
		/////////
		sname=obj["m_spell_checker"].as(string)
		if sname&&sname.n:
			m_spell_checker=Hunspell.getSpeller(sname)
			if m_spell_checker:
				m_spell_checker_name=sname
	}
	BeginRender=function(JSObject obj){
		if Platform.BUILD=="debug":
			if !m_lang:
				obj.GetContext().evalVoid("UI.DumpCallStack()","<stack>")
		m_cached_colors_p_word_part=int(m_lang.m_coloring_rules.n+1)
		m_cached_colors=new int[m_cached_colors_p_word_part+m_lang.m_word_color_names.n]
		m_cached_colors[0]=obj[m_lang.m_default_color_name].or(0xff000000)
		foreach crule,I in m_lang.m_coloring_rules
			m_cached_colors[I+1]=obj[crule.color_name].or(0xff000000)
		foreach color_name,I in m_lang.m_word_color_names
			m_cached_colors[m_cached_colors_p_word_part+I]=obj[color_name].or(0xff000000)
		m_bgcolor_selection=int(obj["bgcolor_selection"].or(u32(m_bgcolor_selection)))
		m_color_overlay=int(obj["color_overlay"].or(u32(m_color_overlay)))
		m_color_embolden=int(obj["color"].or(u32(m_color_embolden)))
		m_cached_color_virtual_hyphen=int(obj["color_hyphen"].or(u32(m_cached_color_virtual_hyphen)))
		if m_spell_checker&&!m_temporarily_disable_spell_check:
			m_current_frame_spell_errors=new long2[]
		m_current_frame_tildes=new TTildeItem[]
		m_current_frame_strikeouts=new float3[]
		m_w_ellipsis=float2fixed(obj["w_ellipsis"].as(float))
		m_ellipsis_items.clear()
		edobj=obj["ed"].as(JSObject);
		if edobj:
			m_file_index=edobj["m_file_index"].as(CFileIndex)
		else
			m_file_index=CFileIndex.NULL
		m_color_virtual_diff_bold=obj["color_virtual_diff_bold"].as(int)
	}
	SetCaretOverlay=function(CEditableText caller,i64 x,i64 y,JSObject obj){
		m_overlays.clear()
		//m_overlay_obj=obj
		w_overlayd=0.
		m_caret_offset=0LL
		if obj:
			s=obj["text"].as(string)
			if s:
				w_overlayd=GetStringWidth(m_font,s)
			flatx=AddHiddenRanges(caller,x,y)
			overlay_sel0=obj["start"].or(0L)
			overlay_sel1=overlay_sel0+obj["length"].or(0L)
			cmap=new iptr[]
			foreach chj,J in Utf8Chars(s)
				cmap.push(J)
			cmap.push(s.n)
			overlay_sel0=min(overlay_sel0,cmap.n-1)
			overlay_sel1=min(overlay_sel1,cmap.n-1)
			x_sel0=0LL
			x_sel1=0LL
			if uptr(overlay_sel0)<uptr(cmap.n)&&uptr(overlay_sel1)<uptr(cmap.n):
				//measuring
				x_sel0=double2fixed(GetStringWidth(m_font,s[:cmap[overlay_sel0]-1]))
				x_sel1=double2fixed(GetStringWidth(m_font,s[:cmap[overlay_sel1]-1]))
				m_caret_offset=max(x_sel0,x_sel1)
			m_overlays.push(TOverlayItem(){
				flatx:flatx,
				y:(flatx+m_wrap_width_in_fp-1LL)/m_wrap_width_in_fp-1LL,
				delta_x:double2fixed(w_overlayd),
				s_text:s,
				type:obj["type"].or("IME")=="IME"?OVERLAY_IME:OVERLAY_AE,
				sel0:x_sel0,
				sel1:x_sel1,
				w_strikeout:0LL,
			})
		if !m_precomputed_overlays_for_tentative_editops:
			prec_overlays=new TOverlayItem[]
			m_precomputed_overlays_for_tentative_editops=prec_overlays
			if m_tentative_editops:
				n3=m_tentative_editops.length()
				n=n3/3
				ccnts=new i64[]
				for i=0:3:n3-3
					ccnt_i=m_tentative_editops[i+0].as(i64)
					ccnts.push(ccnt_i)
					ccnts.push(ccnt_i+m_tentative_editops[i+1].as(i64))
				//////
				hid=caller.m_handler_registration["renderer"].as(int)
				a=caller.GetStateEnMasse(hid,ccnts)
				flatxs=GetFlatXEnMasse(a)//[GetFlatX(a[i*5:]) for i=0:n*2-1]
				for i=0:n-1
					s_i=m_tentative_editops[i*3+2].as(string)
					if !s_i:
						s_i=""
					else if s_i.IndexOf('\t')>=0||s_i.IndexOf('\n')>=0:
						s_i=s_i.Replace(["\t","\u2192","\n","\u21b5"])
					w_overlayd_i=GetStringWidth(m_font,s_i)
					prec_overlays.push(TOverlayItem(){
						flatx:flatxs[i*2+1],
						y:(flatxs[i*2+1]+m_wrap_width_in_fp-1LL)/m_wrap_width_in_fp-1LL,
						delta_x:double2fixed(w_overlayd_i),
						s_text:s_i,
						type:OVERLAY_AE,
						sel0:0LL,
						sel1:0LL,
						w_strikeout:flatxs[i*2+1]-flatxs[i*2],
					})
		if m_precomputed_overlays_for_tentative_editops:
			m_overlays.push(m_precomputed_overlays_for_tentative_editops)
		m_overlay_embolden_ranges=new i64[]
		if m_virtual_diffs:
			ccnts=new i64[]
			n3=m_virtual_diffs.length()
			for i=0:3:n3-3
				ccnt_j=m_virtual_diffs[i+0].as(i64)
				sz_j=m_virtual_diffs[i+1].as(i64)
				ccnts.push(ccnt_j)
				ccnts.push(ccnt_j+sz_j)
			n=n3/3
			hid=caller.m_handler_registration["renderer"].as(int)
			a=caller.GetStateEnMasse(hid,ccnts)
			flatxs=GetFlatXEnMasse(a)//[GetFlatX(a[i*5:]) for i=0:n*2-1]
			for i=0:n-1
				ccnt_j=m_virtual_diffs[i*3+0].as(i64)
				sz_j=m_virtual_diffs[i*3+1].as(i64)
				if sz_j:
					m_overlay_embolden_ranges.push(ccnt_j)
					m_overlay_embolden_ranges.push(ccnt_j+sz_j)
				s_i=m_virtual_diffs[i*3+2].as(string)
				if !s_i:
					s_i=""
				else if s_i.IndexOf('\t')>=0:
					s_i=s_i.Replace(["\t"," "])
				w_overlayd_i=GetStringWidth(m_font,s_i)
				m_overlays.push(TOverlayItem(){
					flatx:flatxs[i*2+1],
					y:(flatxs[i*2+1]+m_wrap_width_in_fp-1LL)/m_wrap_width_in_fp-1LL,
					delta_x:double2fixed(w_overlayd_i),
					s_text:s_i,
					type:OVERLAY_AE,
					sel0:0LL,
					sel1:0LL,
					w_strikeout:-double2fixed(w_overlayd_i),
				})
		m_overlays.Sortby(inline(item){return item.flatx})
		w_overlay=double2fixed(w_overlayd)
		//m_caret_overlay=long3(,0LL,w_overlay)
		//m_caret_overlay.y=(m_caret_overlay.x+m_wrap_width_in_fp-1LL)/m_wrap_width_in_fp*m_wrap_width_in_fp
		//m_caret_offset=0LL
		return w_overlay
	}
	GetCaretOffset=function(){
		return m_caret_offset
	}
	AddOverlayOffset=function(i64 x0,i64 y){
		flatx0=x0+y*m_wrap_width_in_fp
		p=m_overlays.InlineBisect(inline(a){return a.flatx<=flatx0})
		p--
		x=x0
		for(;p>=0;p--)
			if m_overlays[p].y==y:
				x+=m_overlays[p].delta_x
			else
				break
		return x
	}
	TestOverlay=inline(p_overlay, fnt_scaled,scale,x,projectXY){
		if p_overlay>=m_overlays.n:return 0
		oi=m_overlays[p_overlay]
		if x!=oi.flatx:return 0
		s_overlay=oi.s_text
		auto prj_x=projectXY(x)
		x_sel0=fixed2double(oi.sel0)
		x_sel1=fixed2double(oi.sel1)
		if x_sel0>x_sel1:
			(x_sel0,x_sel1)=(x_sel1,x_sel0)
		if oi.w_strikeout:
			auto dy_strikeout=fnt_scaled.h*fnt_scaled.pfnt.y_baseline_per_height*0.46875f
			flatx_s0=x-oi.w_strikeout
			flatx_s1=x
			if flatx_s0>flatx_s1:
				tmp=flatx_s0
				flatx_s0=flatx_s1
				flatx_s1=tmp
			y_s0=(flatx_s0)/m_wrap_width_in_fp
			y_s1=(flatx_s1)/m_wrap_width_in_fp
			for yi=y_s0:y_s1
				fx0=max(yi*m_wrap_width_in_fp,flatx_s0)
				fx1=min((yi+1)*m_wrap_width_in_fp-1,flatx_s1)
				//Writeln('--- ',yi,' ',fx0,' ',fx1)
				auto prj_fx0=projectXY(fx0)
				auto prj_fx1=projectXY(fx1)
				m_current_frame_strikeouts.push(float3(prj_fx0.x,prj_fx0.y,prj_fx1.x-prj_fx0.x))
		//selection - pre-draw the highlight
		if x_sel0<x_sel1:
			g_renderer.DrawRectangle(prj_x.x+float(x_sel0)*scale,prj_x.y,float((x_sel1-x_sel0)*scale),g_renderer.GetCharacterHeight(fnt_scaled), m_bgcolor_selection)
		xo=x
		foreach chj,J in Utf8Chars(s_overlay)
			dx_j=charWidth(chj)
			prj_xo=projectXY(xo)
			//g_renderer.DrawChar(fnt_scaled, prj_xo.x,prj_xo.y,m_color_overlay, chj)
			g_renderer.FastDrawChar(prj_xo.x,prj_xo.y,m_color_overlay, chj)
			xo+=dx_j
		if oi.type==OVERLAY_IME:
			y_underline=prj_x.y+fnt_scaled.h*(fnt_scaled.pfnt.y_baseline_per_height+0.02f)
			g_renderer.DrawRectangle(prj_x.x,y_underline,fixed2float(oi.delta_x)*scale,max(fnt_scaled.h*0.05f,1.f), m_color_overlay)
		return 1
	}
	RenderText=function(CEditableText ed,i64 ccnt_base,i64[] a,i64[] pp,string s, u8[] color_ids, i64 scroll_x,i64 scroll_y,i64 clip_w,i64 clip_h,float screen_x,float screen_y,float scale){
		//word coloring - update color_ids
		//get a GRACEFUL_WORD_SIZE context on each side - do it per-char
		word_dfa=m_lang.m_word_dfa
		word_char_map=m_lang.m_word_char_map
		word_char_set=m_lang.m_word_char_set
		n_word_char_types=m_lang.m_n_word_char_types
		color_id_spell_check=m_lang.m_color_id_spell_check
		key_decl_color_ids=m_lang.m_key_decl_color_ids
		kd_color=m_lang.m_kd_color
		//start from word_ccnt0, do per-char enum until we go out of block
		word_ccnt0=ccnt_base
		budget=GRACEFUL_WORD_SIZE
		foreach ch,I in ed.enumUtf8Backward(ccnt_base)
			if !isWordChar(ch):break
			word_ccnt0=I
			budget--
			if budget<0:break
		ccnt_block_end=ccnt_base+i64(s.n)
		ch_before_word=ed.GetUtf8CharNeighborhood(word_ccnt0)[0]
		trigger_chars=m_lang.m_trigger_chars
		word_ccnt0_bak=word_ccnt0-1
		s_word=new string
		file_index=m_file_index
		if file_index:
			PrecomputeIndices(file_index)
			color_table=file_index.m_temp_color_table
		else
			color_table=int[int].NULL
		s_temp_getid=new char[MAX_SPECIAL_COLOR_ID_SIZE]
		n_tokens=m_lang.m_n_tokens
		isCustomWordChar=inline(int ch){
			if ch>=128:
				return int(TextBox.detail.g_unicode_wordchars.Bisect(function(int c0){return c0<=ch})&1)
			else
				return TextBox.detail.isInCharSet(word_char_set,ch)
		}
		for(;;)
			//Writeln(word_ccnt0)
			ch_first=0
			foreach ch,I,I2 in ed.enumUtf8Forward(word_ccnt0)
				word_ccnt0=I
				if isCustomWordChar(ch):
					ch_first=ch
					break
				ch_before_word=ch
				word_ccnt0=I2
				if word_ccnt0>=ccnt_block_end:
					break
			if word_ccnt0>=ccnt_block_end:break
			//Writeln(word_ccnt0,' ',word_ccnt0_bak)
			if word_ccnt0<=word_ccnt0_bak:
				//blocked by invalid utf8
				break
			word_ccnt0_bak=word_ccnt0
			//Writeln(word_ccnt0,' ',ccnt_block_end,' ',s[word_ccnt0])
			//now we know we have a word
			//non-word chars should immediately terminate the DFA
			color_id=0
			cid=color_ids[max(iptr(word_ccnt0-ccnt_base),0L)]
			if u32(cid)<u32(m_lang.m_word_dfa_initial_state.n):
				st=m_lang.m_word_dfa_initial_state[cid]
				if trigger_chars&&ch_before_word<128&&trigger_chars.IndexOf(char(ch_before_word))>=0:
					//it's immediately after the trigger char, use the alternative initial state
					st=m_lang.m_word_dfa_initial_state_triggered[cid]
			else
				st=~0
			if st>=0:
				budget=GRACEFUL_WORD_SIZE
				foreach ch,I in ed.enumCharsForward(word_ccnt0)//it's 8-bit here, not UTF8!
					//and ch is signed
					//non-word chars would inevitably terminate the DFA
					chi=int(u8(ch))
					st=word_dfa[st+int(word_char_map[chi])]
					if st<0:break
					budget--
					if budget<0:break
			if st>=0:st=word_dfa[st+1]
			//Writeln(word_ccnt0,' ',cid,' ',st)
			if color_table&&st==~kd_color&&key_decl_color_ids:
				//parser-based highlighting
				s_temp_getid.n=MAX_SPECIAL_COLOR_ID_SIZE
				p_s_temp_getid=0L
				foreach ch,I in ed.enumCharsForward(word_ccnt0)//it's 8-bit here, not UTF8!
					if p_s_temp_getid>=MAX_SPECIAL_COLOR_ID_SIZE:break
					chi=int(u8(ch))
					if !CharSet.has(CharSet.idbody,chi):break
					s_temp_getid[p_s_temp_getid++]=char(ch)
				if p_s_temp_getid&&!CharSet.has(CharSet.idhead,int(u8(s_temp_getid[0]))):
					p_s_temp_getid=0L
				if p_s_temp_getid:
					s_temp_getid.n=p_s_temp_getid
					id_temp=getid(s_temp_getid)
					key_decl_type=color_table[id_temp]-1
					//Writeln('>>> ',s_temp_getid,' ',id_temp,' ',key_decl_type)
					if key_decl_type>=0:
						st=~key_decl_color_ids[key_decl_type]
			color_id=~st
			need_spell_check=0
			if m_spell_checker&&!m_temporarily_disable_spell_check:
				ccnt_before_word=word_ccnt0
				if color_id==color_id_spell_check:
					s_word.n=0
					need_spell_check=1
			is_number=(u32(ch_first-int('0'))<10u)
			//. inside numbers
			foreach ch,I,I2 in ed.enumUtf8Forward(word_ccnt0)
				word_ccnt0=I
				if isCustomWordChar(ch)||is_number&&ch=='.':
					ofs=iptr(word_ccnt0-ccnt_base)
					if uptr(ofs)<uptr(color_ids.n):
						if color_id>0:
							color_ids[ofs]=m_cached_colors_p_word_part+color_id
					if need_spell_check:
						if isCJK(ch):
							need_spell_check=0
						if ch>=65536:
							//surrogate pair - 2nd
							s_word.push(char(((ch>>18)&0xf)+0xf0))
							s_word.push(char(0x80+((ch>>12)&63)))
							s_word.push(char(0x80+((ch>>6)&63)))
							s_word.push(char(0x80+(ch&63)))
						else if ch>=2048:
							s_word.push(char(((ch>>12)&0xf)+0xe0))
							s_word.push(char(0x80+((ch>>6)&63)))
							s_word.push(char(0x80+(ch&63)))
						else if ch>=128:
							s_word.push(char((ch>>6)+0xc0))
							s_word.push(char(0x80+(ch&63)))
						else
							s_word.push(char(ch))
				else
					break
				ch_before_word=ch
				word_ccnt0=I2
				if word_ccnt0>=ccnt_block_end:
					break
			if need_spell_check:
				//spell check
				if s_word.n>1:
					s_word.push(char(0))
					if !Hunspell.spell(m_spell_checker,s_word):
						is_bad=1
						if s_word[0]>='A'&&s_word[0]<='Z':
							s_word[0]|=i8(0x20)
							if Hunspell.spell(m_spell_checker,s_word):
								is_bad=0
						if is_bad&&!m_temporarily_disable_spell_check:
							//not a word
							m_current_frame_spell_errors.push(long2(ccnt_before_word,word_ccnt0))
		///////
		fnt_scaled=m_font
		fnt_scaled.h*=scale
		//smart emboldening for SRGB
		//coulddo: per-color emboldening
		if g_renderer.m_srgb_supported:
			fnt_scaled.SmartEmbolden(m_color_embolden)
		hc=charHeight()
		x=GetFlatX(a)
		tab_width=m_tab_width_in_fp
		wrap_width=m_wrap_width_in_fp
		iy=x/wrap_width
		ix=x-iy*wrap_width
		dx_extra=0LL
		dy_extra=0LL
		p_overlay=m_overlays.InlineBisect(inline(a){return a.flatx<x})
		inline projectXY(i64 x0)
			auto y=x0/wrap_width
			auto x=x0-y*wrap_width
			x+=dx_extra
			y=(y+dy_extra)*hc
			return float2(fixed2float(x-scroll_x)*scale+screen_x,fixed2float(y-scroll_y)*scale+screen_y)
		inline testOverlay()
			while TestOverlay(p_overlay, fnt_scaled,scale,x,projectXY):
				dx_extra+=m_overlays[p_overlay].delta_x
				p_overlay++
			//if m_overlay_obj&&x==m_caret_overlay.x:
			//	DrawOverlay(fnt_scaled,scale,x,projectXY)
			//	dx_extra+=m_caret_overlay.z
		x_right_clip=scroll_x+clip_w
		g_renderer.SetFastDrawCharFont(fnt_scaled)
		if m_enable_advanced_wrapping:
			//we won't need x_right_clip here anyway
			_RenderText(MODE_RENDER,ccnt_base,a,pp,s,s.n, color_ids, scroll_x,scroll_y,clip_w,clip_h,screen_x,screen_y,scale)
			//additional emboldens
			if m_overlay_embolden_ranges&&m_overlay_embolden_ranges.n:
				C_virtual_diff_bold=m_color_virtual_diff_bold
				for i=0:2:m_overlay_embolden_ranges.n-2
					EmboldenTextRange(
						ed,
						m_overlay_embolden_ranges[i+0],
						m_overlay_embolden_ranges[i+1],
						C_virtual_diff_bold,
						scroll_x,scroll_y,clip_w,clip_h,screen_x,screen_y,scale)
			return 
		//the \t\n ignorant hiding
		HideChars(ed,ccnt_base,color_ids,s)
		enable_hidden=m_enable_hidden
		//maintain an embedded object list
		p_next_ceo=0L
		ccnt_next_ceo=-1LL
		if m_ceos.n:
			//virtual overlay
			hid=ed.m_handler_registration["renderer"].as(int)
			SortEmbededObjects()
			p_next_ceo=m_ceos.InlineBisect(inline(a){return a.loc.ccnt<ccnt_base})
			if p_next_ceo<m_ceos.n:
				ccnt_next_ceo=m_ceos[p_next_ceo].loc.ccnt
		//it's OK to have a negative dx_extra
		//maintain x normally
		I_query_valid_point=-1LL
		if enable_hidden>0:
			//query at the first non-hidden char
			if !m_hidden_ranges_prepared:
				PrepareHiddenRanges(ed)
			p=m_hidden_ccnts.Bisect(function(i64 a){return a<=ccnt_base})
			if p<m_hidden_ccnts.n:
				if p&1:
					I_query_valid_point=m_hidden_ccnts[p]-ccnt_base
			///////////
			(ix_visual,iy_visual)=SubHiddenRanges(ed,x)
			dx_extra=ix_visual-ix
			dy_extra=iy_visual-iy
		//if x>m_caret_overlay.x&&x<m_caret_overlay.y:
		//	x+=m_caret_overlay.z
		ix_with_overlay=AddOverlayOffset(ix,iy)
		dx_extra+=ix_with_overlay-ix
		for ch,I in Utf8Chars(s)
			if I==I_query_valid_point:
				//the head query was invalid, reset the stuff
				(ix_visual,iy_visual)=SubHiddenRanges(ed,x)
				dx_extra=ix_visual-ix
				dy_extra=iy_visual-iy
			cidi=color_ids[I]
			if cidi!=u8(255):
				testOverlay()
			//if ccnt_base+I>=980&&ccnt_base+I<=990:
			//	Writeln('  ',ccnt_base+I,' ',dx_extra,' ',dy_extra,' ',cidi,' ',ch)
			if ch=='\r':
				//nothing
			else if ch=='\n':
				if ccnt_base+I==ccnt_next_ceo:
					dy_extra+=m_ceos[p_next_ceo].dy
					p_next_ceo++
					if p_next_ceo<m_ceos.n:
						ccnt_next_ceo=m_ceos[p_next_ceo].loc.ccnt
				if cidi==u8(255):
					dy_extra--
					dx_extra+=ix
				else
					dx_extra=0LL
				x=(x/wrap_width+1LL)*wrap_width
				iy=x/wrap_width
				ix=x-iy*wrap_width
				if (iy+dy_extra)*hc-scroll_y>=clip_h:break
			else if ch==' ':
				dx_i=charWidth(ch)
				x+=dx_i
				ix+=dx_i
				if cidi==u8(255):
					dx_extra-=dx_i
				if ix>=wrap_width:
					if cidi==u8(255):
						dy_extra--
						dx_extra+=ix
					else
						dx_extra=0LL
					ix-=wrap_width
					iy++
			else if ch=='\t':
				if cidi==u8(255):
					dx_extra+=x
					x=(x/tab_width+1LL)*tab_width
					dx_extra-=x
				else
					x=(x/tab_width+1LL)*tab_width
				iy=x/wrap_width
				ix=x-iy*wrap_width
			else
				dx_i=charWidth(ch)
				if cidi!=u8(255):
					if ix+dx_extra<x_right_clip:
						prj_x=float2(fixed2float(ix+dx_extra-scroll_x)*scale+screen_x,fixed2float((iy+dy_extra)*hc-scroll_y)*scale+screen_y)
						//g_renderer.DrawChar(fnt_scaled, prj_x.x,prj_x.y,m_cached_colors[color_ids[I]], ch)
						color=m_cached_colors[int(cidi)&127]
						if enable_hidden<=0&&(int(cidi)&128):
							color&=0x7fffffff
						g_renderer.FastDrawChar(prj_x.x,prj_x.y,color, ch)
				else
					dx_extra-=dx_i
				x+=dx_i
				ix+=dx_i
				if ix>=wrap_width:
					if cidi==u8(255):
						dy_extra--
						dx_extra+=ix
					else
						dx_extra=0LL
					ix-=wrap_width
					iy++
					if (iy+dy_extra)*hc-scroll_y>=clip_h:break
			if (int(cidi)&128)&&enable_hidden>0:
				if cidi!=u8(255):
					cidi&=u8(127)
					//dx_i=charWidth(U_ELLIPSIS)
					dx_i=m_w_ellipsis
					if ix<x_right_clip&&enable_hidden>0:
						//grey it out to mark it as "hidden"
						prj_x=float2(fixed2float(ix+dx_extra-scroll_x)*scale+screen_x,fixed2float((iy+dy_extra)*hc-scroll_y)*scale+screen_y)
						//g_renderer.FastDrawChar(prj_x.x,prj_x.y,m_cached_colors[cidi]&0x55ffffff, U_ELLIPSIS)
						m_ellipsis_items.push(TEllipsisItem(){x:prj_x.x,y:prj_x.y,scale:scale,color:m_cached_colors[cidi]})
					dx_extra+=dx_i
		//if ccnt_base+s.n>=980&&ccnt_base+s.n<=990:
		//	Writeln('      ',ccnt_base+s.n,' ',dx_extra,' ',dy_extra)
		testOverlay()
		//additional emboldens
		if m_overlay_embolden_ranges&&m_overlay_embolden_ranges.n:
			C_virtual_diff_bold=m_color_virtual_diff_bold
			for i=0:2:m_overlay_embolden_ranges.n-2
				//Writeln(
				//	'embolden ',
				//	m_overlay_embolden_ranges[i+0],' ',
				//	m_overlay_embolden_ranges[i+1])
				EmboldenTextRange(
					ed,
					m_overlay_embolden_ranges[i+0],
					m_overlay_embolden_ranges[i+1],
					C_virtual_diff_bold,
					scroll_x,scroll_y,clip_w,clip_h,screen_x,screen_y,scale)
	}
	GetWrapWidth=function(){
		return m_wrap_width_in_fp
	}
	EndRender=function(JSObject obj,CEditableText ed, i64 scroll_x,i64 scroll_y,i64 clip_w,i64 clip_h,float screen_x,float screen_y,float scale){
		if !m_temporarily_disable_spell_check:
			if m_current_frame_spell_errors:
				C_spell_error=obj["color_tilde_spell_error"].as(int)
				m_current_frame_spell_errors.Sort()
				foreach se in m_current_frame_spell_errors
					m_current_frame_tildes.push(TTildeItem(){ccnt0:se.x,ccnt1:se.y,color:C_spell_error})
		if m_current_frame_tildes.n:
			//tilde for spell checks / build errors
			spell_error_ccnts=new i64[m_current_frame_tildes.n*2]
			for i=0:m_current_frame_tildes.n-1
				spell_error_ccnts[i*2+0]=m_current_frame_tildes[i].ccnt0
				spell_error_ccnts[i*2+1]=m_current_frame_tildes[i].ccnt1
			spell_error_ccnts_idx=[i for i=0:spell_error_ccnts.n-1]
			spell_error_ccnts_idx.Sortby(inline(a){return spell_error_ccnts[a]})
			spell_error_ccnts=[spell_error_ccnts[id] foreach id in spell_error_ccnts_idx]
			xys_sorted=ed.GetXYEnMasse(spell_error_ccnts)
			xys=new i64[xys_sorted.n]
			foreach id,I in spell_error_ccnts_idx
				xys[id*2+0]=xys_sorted[I*2+0]
				xys[id*2+1]=xys_sorted[I*2+1]
			dy_baseline=(g_renderer.GetFontBaseline(m_font)+0.04f*m_font.h)*scale
			fnt_tilde0=obj["font_tilde"].as(TFont)
			fnt_tilde0.h=m_font.h*scale
			inline xyToFloat(x,y)
				return float2(fixed2float(x-scroll_x)*scale+screen_x,fixed2float(y-scroll_y)*scale+screen_y)
			wf=fixed2float(min(clip_w,m_wrap_width_in_fp))
			hcf=g_renderer.GetCharacterHeight(m_font)*scale
			for i=0:4:xys.n-4
				C_tilde=m_current_frame_tildes[i>>2].color
				fnt_tilde=fnt_tilde0
				fnt_tilde.SmartEmbolden(C_tilde)
				xy0=xyToFloat(xys[i+0],xys[i+1])
				xy1=xyToFloat(xys[i+2],xys[i+3])
				if xy0.y==xy1.y:
					DrawTilde(fnt_tilde,xy0.x,xy1.x,xy0.y+dy_baseline, C_tilde)
				else
					//draw 3 rects, we have a cliprect, don't worry
					DrawTilde(fnt_tilde,xy0.x,max(screen_x+wf*scale,xy0.x),xy0.y+dy_baseline, C_tilde)
					//per-line draw...
					for(y=xy0.y+hcf;y<xy1.y-hcf*0.5f;y+=hcf)
						DrawTilde(fnt_tilde,screen_x,screen_x+wf*scale,y+dy_baseline, C_tilde)
					DrawTilde(fnt_tilde,screen_x,max(xy1.x,screen_x),xy1.y+dy_baseline, C_tilde)
			//m_current_frame_spell_errors=long2[].NULL
		//else
		//fnt_scaled=m_font
		//fnt_scaled.h*=scale
		if m_enable_hidden>0:
			if !m_hidden_ranges_prepared:
				PrepareHiddenRanges(ed)
			if m_hidden_ccnts.n&&m_hidden_ccnts[0]==0LL:
				//draw ... at the zeroth text, if it's visible
				//g_renderer.DrawChar(fnt_scaled, fixed2float(-scroll_x)*scale+screen_x,fixed2float(-scroll_y)+screen_y,
				//	m_cached_colors[0], U_ELLIPSIS)
				m_ellipsis_items.push(TEllipsisItem(){
						x:fixed2float(-scroll_x)*scale+screen_x,
						y:fixed2float(-scroll_y)*scale+screen_y,
						scale:scale,color:m_cached_colors[0]})
			js_callback=obj["DrawEllipsis"].as(JSObject)
			foreach ei in m_ellipsis_items
				js_callback.CallAsMethod(int,obj,ei.x,ei.y,ei.scale,ei.color)
		//render embedded objects
		if m_enable_ceo_rendering&&m_ceos.n:
			SortEmbededObjects()
			ceo_xys=ed.GetXYEnMasse([ceo.loc.ccnt+1 for ceo in m_ceos])
			hc0=charHeight()
			for ceo,I in m_ceos
				ceo.obj.CallMethod(int,"Render",
					(fixed2float(ceo_xys[I*2+0]-scroll_x)*scale+screen_x)/g_renderer.m_pixels_per_unit,
					(fixed2float(ceo_xys[I*2+1]-ceo.dy*hc0-scroll_y)*scale+screen_y)/g_renderer.m_pixels_per_unit,
					scale)
		//draw strikeouts
		if m_current_frame_strikeouts.n:
			C_strikeout=obj["color_strikeout"].as(int)
			fnt_scaled=m_font
			fnt_scaled.h*=scale
			hc=g_renderer.GetCharacterHeight(fnt_scaled)
			h_strikeout=hc*0.1f
			foreach job in m_current_frame_strikeouts
				g_renderer.DrawRectangle(job.x,job.y+(hc-h_strikeout)*0.5f,job.z,h_strikeout,C_strikeout)
		////////////
		m_file_index=CFileIndex.NULL
	}
	EmboldenTextRange=function(CEditableText ed,i64 ccnt0,i64 ccnt1,int C, i64 scroll_x,i64 scroll_y,i64 clip_w,i64 clip_h,float screen_x,float screen_y,float scale){
		hid=ed.m_handler_registration["renderer"].as(int)
		hc=charHeight()
		fnt_bold_scaled=m_font_emboldened
		fnt_bold_scaled.h*=scale
		ch_prev=ed.GetUtf8CharNeighborhood(ccnt0)[0]
		s_embolden=ed.GetText(ccnt0,ccnt1-ccnt0)
		wrap_width=m_wrap_width_in_fp
		x=GetFlatX(ed.GetStateAt(hid,ccnt0))
		if ed.IsAtLineWrap(ccnt0):
			x=(x+wrap_width-1)/wrap_width*wrap_width
		if this.IsRangeHidden(ed,ccnt0,ccnt1):
			//it's inside a hidden range
			//coulddo: m_w_ellipsis
			return
		foreach ch in Utf8Chars(s_embolden)
			iy=x/wrap_width
			ix=x-iy*wrap_width
			ix_with_overlay=AddOverlayOffset(ix,iy)
			dx_overlay=ix_with_overlay-ix
			//Writeln('>>> ',ix,' ',iy)
			(ix,iy)=SubHiddenRanges(ed,x)
			//Writeln(ix,' ',iy)
			ix+=dx_overlay
			prj_x=float2(fixed2float(ix-scroll_x)*scale+screen_x,fixed2float(iy*hc-scroll_y)*scale+screen_y)
			g_renderer.DrawChar(fnt_bold_scaled, prj_x.x,prj_x.y,C, ch)
			dx_i=charWidth(ch)
			x+=dx_i
			if m_enable_advanced_wrapping:
				x+=charKerning(ch_prev,ch)
				ch_prev=ch
	}
	DrawEnhancedHighlight=function(JSObject obj,CEditableText ed,CHLRange hl, i64 scroll_x,i64 scroll_y,i64 clip_w,i64 clip_h,float screen_x,float screen_y,float scale){
		////////
		ccnt0=hl.p0.ccnt
		ccnt1=hl.p1.ccnt
		mode=int(hl.display_mode)
		if mode==HL_DISPLAY_MODE_EMBOLDEN:
			//only embolden a single char
			EmboldenTextRange(ed,ccnt0,ccnt1,hl.color, scroll_x,scroll_y,clip_w,clip_h,screen_x,screen_y,scale)
		else if mode==HL_DISPLAY_MODE_TILDE:
			m_current_frame_tildes.push(TTildeItem(){ccnt0:ccnt0,ccnt1:ccnt1,color:hl.color})
	}
	GetCharacterHeightAt=function(i64 ccnt_base,i64[] a,i64[] pp,string s,iptr ofs){
		return charHeight()
	}
	GetDefaultFont=function(){
		return m_font
	}
	GetXYFromState=function(CEditableText ed,i64[] a){
		(x,y)=SubHiddenRanges(ed,GetFlatX(a))
		y*=charHeight()
		return long2(x,y)
	}
	IsAtLineWrap=function(i64[] a,i64[] pp,string s,iptr ofs){
		if m_enable_advanced_wrapping:
			foreach atom_i,I in pp[1:]
				high_dword=int(atom_i>>32)
				if high_dword==-1:
					ccnt=(int(atom_i)&ATOM_MASK_CCNT)
					if ccnt==ofs&&(ofs>=s.n||s[ofs]!='\n'):
						return 1
					if ccnt>ofs:break
		else
			//not \n and divides m_wrap_width_in_fp
			a2=new(a)
			AddString(a2,pp,new string,s,ofs)
			x1=GetFlatX(a2)
			ch_prev=0
			foreach ch in CharToUtf8Backward(s[:ofs-1].ReverseOrder(),iptr)
				ch_prev=ch
				break
			//we could have \n in the block above... and the test is done outside
			x0=x1-charWidth(ch_prev)
			if x1/m_wrap_width_in_fp>x0/m_wrap_width_in_fp:
				//if ofs&&s[ofs-1]!='\n':
				return -1
		return 0
	}
	//////////////////////////////
	JS_AddWord=function(JSContext JS){
		if !m_spell_checker:return 0
		s_word=JS.Param(0).as(string)
		if !s_word:return 0
		Hunspell.addWord(m_spell_checker,m_spell_checker_name,s_word)
		return JS.Return(1)
	}
	string[] m_cached_suggestion
	string m_cached_suggestion_word
	JS_Suggest=function(JSContext JS){
		if !m_spell_checker||!m_current_frame_spell_errors:return 0
		ed=JS.Param(0).as(CEditableText)
		ccnt=JS.Param(1).as(i64)
		p=m_current_frame_spell_errors.Bisect(function(long2 a){return a.y<=ccnt})
		if p<m_current_frame_spell_errors.n:
			word_pos=m_current_frame_spell_errors[p]
			if ccnt>=word_pos.x&&ccnt<word_pos.y:
				s_word=ed.GetText(word_pos.x,word_pos.y-word_pos.x)
				if m_cached_suggestion_word&&m_cached_suggestion_word==s_word:
					suggestions=m_cached_suggestion
				else
					suggestions=Hunspell.suggest(m_spell_checker,s_word)
					m_cached_suggestion=suggestions
					m_cached_suggestion_word=s_word
				ret=JS.New()
				ret["suggestions"]=suggestions
				ret["s_prefix"]=s_word
				ret["ccnt0"]=word_pos.x
				return JS.Return(ret)
		return 0
	}
	JS_ClearContext=function(JSContext JS){
		m_current_frame_spell_errors=long2[].NULL
		return 0
	}
	JS_ResetSpellChecker=function(JSContext JS){
		obj=JS.Param(0).as(JSObject)
		sname=obj["m_spell_checker"].as(string)
		m_spell_checker=Hunspell.getSpeller(sname)
		if m_spell_checker:
			m_spell_checker_name=sname
		else
			m_spell_checker_name=string.NULL
		m_current_frame_spell_errors=long2[].NULL
		return JS.Return(!!m_spell_checker)
	}
	//////////////////////////////
	MODE_BB=0
	MODE_SEEK=1
	MODE_RENDER=2
	_RenderText=function(int mode,i64 ccnt_base,i64[] a,i64[] pp,string s,iptr ofs0, u8[] color_ids, i64 scroll_x,i64 scroll_y,i64 clip_w,i64 clip_h,float screen_x,float screen_y,float scale){
		//use flat x
		hc=charHeight()
		wrap_width=m_wrap_width_in_fp
		ofs=ofs0
		inline projectX(i64 x)
			return fixed2float(x-scroll_x)*scale+screen_x
		inline projectY(i64 y)
			return fixed2float(y*hc-scroll_y)*scale+screen_y
		//inline projectXY(i64 x0)
		//	auto y=x0/wrap_width
		//	auto x=x0-y*wrap_width
		//	y*=hc
		//	return float2(fixed2float(x-scroll_x)*scale+screen_x,fixed2float(y-scroll_y)*scale+screen_y)
		//re-create the atoms, convert string, then render
		flat_x=a[0]
		auto w_max=a[4]
		y=flat_x/wrap_width
		x=flat_x-y*wrap_width
		if mode==MODE_RENDER:
			x=AddOverlayOffset(x,y)
		p_overlay=m_overlays.InlineBisect(inline(a){return a.flatx<flat_x})
		//if flat_x>m_caret_overlay.x&&flat_x<m_caret_overlay.y:
		//	//it's an abuse of the separate x/y: we must avoid wrapping
		//	x+=m_caret_overlay.z
		//y_overlay=m_caret_overlay.x/wrap_width
		//x_overlay=m_caret_overlay.x-y_overlay*wrap_width
		//////////////////////////////////
		newline_flags=0
		y_baseline=float2fixed(g_renderer.GetFontBaseline(m_font))
		h_line=hc
		fnt_scaled=TFont()
		dy_baseline=0LL
		ch32_prev=int('\n')
		color=m_cached_colors[0]
		if mode==MODE_RENDER:
			fnt_scaled=m_font
			fnt_scaled.h*=scale
			//smart emboldening for SRGB - it has to be done *after* the scale
			if g_renderer.m_srgb_supported:
				fnt_scaled.SmartEmbolden(m_color_embolden)
		OfsCheck=__inline_loop_body(ccnt){
			if mode==MODE_BB&&h_line:
				//never return before the first newline
				if ccnt>=ofs:
					if w_max<x:w_max=x
					a[4]=w_max
					return flat_x
		}
		SeekCheck=__inline_loop_body(ccnt){
			if mode==MODE_SEEK:
				auto y_real=y*hc
				if y_real>scroll_y||scroll_y>=y_real&&scroll_y<y_real+h_line&&x>scroll_x:
					return i64(ccnt)
		}
		inline projectXY(i64 x0)
			//DO NOT WRAP DURING DRAWOVERLAY!
			//hidden case... not supported here
			auto x=x0-y*wrap_width
			return float2(fixed2float(x-scroll_x)*scale+screen_x,fixed2float(y*hc-scroll_y)*scale+screen_y)
		myDrawChar=function(int ch32){
			while TestOverlay(p_overlay, fnt_scaled,scale,flat_x,projectXY):
				x+=m_overlays[p_overlay].delta_x
				p_overlay++
			//if m_overlay_obj&&x==x_overlay&&y==y_overlay:
			//	flat_x=y*wrap_width+x
			//	DrawOverlay(fnt_scaled,scale,flat_x,projectXY)
			//	x+=m_caret_overlay.z
			if ch32!=int(' '):
				dy_flags=0LL
				g_renderer.FastDrawChar(projectX(x),projectY(y+dy_baseline+dy_flags),color, ch32)
		}
		NewlineCheck=inline(){
			if mode==MODE_RENDER:myDrawChar(int(' '))
			if newline_flags:
				if mode==MODE_RENDER&&(newline_flags&ATOM_FLAG_HYPHEN):
					color=m_cached_color_virtual_hyphen
					myDrawChar(int('-'))
				if w_max<x:w_max=x
				flat_x-=x
				flat_x+=wrap_width
				x=0LL
				y++
		}
		//skip to the line
		i_start=0L
		if mode==MODE_BB:
			if m_wrap_width>0.f:
				for i=0L:pp.n-1
					if int(pp[i]>>32)==-1:
						//found a line
						value0=int(pp[i])
						if (value0&ATOM_MASK_CCNT)>=ofs:break
						i_start=i+1
						NewlineCheck()
						newline_flags=(value0&(ATOM_FLAG_NEWLINE|ATOM_FLAG_HYPHEN))
			else
				//if it's unwrapped, we need w_max, we can't skip it
		else if mode==MODE_SEEK:
			for i=0L:pp.n-1
				if int(pp[i]>>32)==-1:
					//found a line
					value0=int(pp[i])
					NewlineCheck()
					auto y_real=y*hc
					if y_real>scroll_y||scroll_y>=y_real&&scroll_y<y_real+h_line&&x>scroll_x:
						y--
						break
					i_start=i+1
					newline_flags=(value0&(ATOM_FLAG_NEWLINE|ATOM_FLAG_HYPHEN))
		foreach atom_i in pp[i_start:]
			value1=int(atom_i>>32)
			value0=int(atom_i)
			if value1==-1:
				//line start
				OfsCheck(value0&ATOM_MASK_CCNT)
				SeekCheck(value0&ATOM_MASK_CCNT)
				NewlineCheck()
				if mode==MODE_RENDER:
					if y*hc-scroll_y>=clip_h:break
				newline_flags=(value0&(ATOM_FLAG_NEWLINE|ATOM_FLAG_HYPHEN))
				ch32_prev=int('\n')
				if !ofs:
					//re-check for block-head case
					if mode==MODE_SEEK:
						return i64(value0)
					else
						if mode==MODE_BB:
							if w_max<x:w_max=x
							a[4]=w_max
						return flat_x
			else if value1&0x80000000:
				//space
				if mode==MODE_RENDER:
					while TestOverlay(p_overlay, fnt_scaled,scale,flat_x,projectXY):
						x+=m_overlays[p_overlay].delta_x
						p_overlay++
				value1&=0x7fffffff
				OfsCheck(value1)
				x+=i64(value0)
				flat_x+=i64(value0)
				SeekCheck(value1)
				ch32_prev=int(' ')
			else
				//Writeln(value0,' ',value1)
				assert(value0>=0&&value1>value0)
				//ignore RTL reversal here - conceptually it goes LTR, and we just flip it "visually"
				//and precompute the ranges
				//arabic transformations - in the recursion
				//__inline_loop_body TranslateArabic(iptr ccnt0,string s_part)
				//	auto su32=[int2(ch,int(ccnt0+I)) foreach ch,I in Utf8Chars(s_part)]
				//	for J=0:su32.n-1
				//		ch32=su32[J].x
				//		if isArabic(ch32):
				//			prev_arabic=(J>0&&isArabic(su32[J-1].x))
				//			next_arabic=(J<su32.n-1&&isArabic(su32[J+1].x))
				//			ch32=g_arabic_table[(ch32-0x600)*4+next_arabic*2+prev_arabic]
				//		//ch32
				//		//if ch32=='\t':ch32=int(' ')
				//		dx_temp=charKerning(ch32_prev,ch32)
				//		x+=dx_temp
				//		flat_x+=dx_temp
				//		OfsCheck(su32[J].y)
				//		if mode==MODE_RENDER:
				//			if ch32!=' '&&ch32!='\r'&&ch32!='\n':
				//				color=m_cached_colors[int(color_ids[su32[J].y])]
				//				myDrawChar(ch32)
				//			else
				//				while TestOverlay(p_overlay, fnt_scaled,scale,flat_x,projectXY):
				//					x+=m_overlays[p_overlay].delta_x
				//					p_overlay++
				//		if ch32=='\t':
				//			dx_temp=charWidth(ch32)*4
				//		else
				//			dx_temp=charWidth(ch32)
				//		x+=dx_temp
				//		flat_x+=dx_temp
				//		ch32_prev=ch32
				//		SeekCheck(su32[J].y)
				//__inline_loop_body AddLigature(iptr ccnt0,iptr nc,string s_ligature)
				//	ch32=0
				//	foreach ch in Utf8Chars(s_ligature)
				//		ch32=ch
				//		break
				//	x0=x
				//	x+=float2fixed(g_renderer.GetKerning(m_font,ch32_prev,ch32))
				//	auto dx=charWidth(ch32)
				//	if mode==MODE_RENDER:
				//		myDrawChar(ch32)
				//	else if mode==MODE_SEEK:
				//		for j=0:nc-1
				//			xj=x+dx*i64(j+1)/i64(nc)
				//			if y>scroll_y||scroll_y>=y&&scroll_y<y+h_line&&xj>=scroll_x:
				//				return i64(ccnt0+j)
				//	else if mode==MODE_BB:
				//		for j=0:nc-1
				//			if ccnt0+j>=ofs:return x+dx*i64(j)/i64(nc)+y*wrap_width
				//	x+=dx
				//	ch32_prev=ch32
				if mode!=MODE_RENDER||y*hc+hc>scroll_y:
					spart=s[value0:value1-1]
					//ligatures=m_styles[current_style_id].ligatures
					//ligature_poses=spart.FindAll(ligatures)
					//p_last=0L
					//for i=0:2:ligature_poses.n-2
					//	p=ligature_poses[i]
					//	id=ligature_poses[i+1]
					//	if p_last<p:
					//		TranslateArabic(value0+p_last,spart[p_last:p-1])
					//	p_last=p+ligatures[id*2+0].n
					//	AddLigature(value0+p,p_last-p,ligatures[id*2+1])
					//if p_last<spart.n:
					//	TranslateArabic(value0+p_last,spart[p_last:])
					//TranslateArabic(value0,spart)
					//flatx_next_line=(flat_x/wrap_width+1LL)*wrap_width;
					foreach ch32,I in Utf8Chars(spart)
						//ch32
						//if ch32=='\t':ch32=int(' ')
						dx_temp=charKerning(ch32_prev,ch32)
						x+=dx_temp
						flat_x+=dx_temp
						OfsCheck(value0+I)
						if mode==MODE_RENDER:
							if ch32!=' '&&ch32!='\r'&&ch32!='\n':
								color=m_cached_colors[int(color_ids[value0+I])]
								myDrawChar(ch32)
							else
								while TestOverlay(p_overlay, fnt_scaled,scale,flat_x,projectXY):
									x+=m_overlays[p_overlay].delta_x
									p_overlay++
						if ch32=='\t':
							//tab
							dx_temp=charWidth(32)*m_tab_width
						else
							dx_temp=charWidth(ch32)
						x+=dx_temp
						flat_x+=dx_temp
						//if flat_x>=flatx_next_line:
						//	y++
						//	x=flat_x-y*wrap_width
						//	flatx_next_line+=wrap_width
						ch32_prev=ch32
						SeekCheck(value0+I)
		NewlineCheck()
		if mode==MODE_SEEK:
			return i64(s.n)
		else
			if mode==MODE_BB:
				if w_max<x:w_max=x
				a[4]=w_max
			return flat_x
	}
	///////////////////////
	//call onchange in js
	m_hidden_ranges_prepared=0
	TAddRangeItem[] m_hidden_dx_add
	TSubRangeItem[] m_hidden_dx_sub
	i64[] m_hidden_ccnts
	struct TDeltaYItem
		i64 flatx0_hidden
		i64 flatx1_hidden
		i64 dy_enforced//<measured in # lines
	m_ceos_sorted=0
	SortEmbededObjects=function(){
		if m_ceos_sorted:return
		m_ceos_sorted=1
		m_ceos.Sortby(inline(a){return a.loc.ccnt})
	}
	/**
	\brief how hidden text is being handled, mainly used when finding
	
	-1: disable all
	 0: enable seeking, disable rendering
	 1: enable all
	*/
	m_enable_hidden=1 
	struct TAddRangeItem
		i64 x,y
		i64 dx,dfx,dy_enforced
	struct TSubRangeItem
		i64 fx0,fx1
		i64 dx,dfx
	PrepareHiddenRanges=function(CEditableText ed){
		//remove the stale ranges
		n2=0
		for I=0:2:m_hidden_ranges.n-2
			loc0=m_hidden_ranges[I]
			loc1=m_hidden_ranges[I+1]
			if (loc1.ccnt>loc0.ccnt):
				m_hidden_ranges[n2+0]=loc0
				m_hidden_ranges[n2+1]=loc1
				n2+=2
		m_hidden_ranges.n=n2;
		//they must be x-addressible
		m_hidden_ranges_prepared=1
		raw_ccnts=[loc.ccnt*2LL+i64(I&1) foreach loc,I in m_hidden_ranges]
		ccnts=new i64[]
		raw_ccnts.Sort()
		//sort and merge
		cvg=0
		foreach e in raw_ccnts
			if e&1:
				cvg--
				if !cvg:
					if ccnts.back()==(e>>1):
						ccnts.pop()
					else
						ccnts.push(e>>1)
			else
				if !cvg:
					ccnts.push(e>>1)
				cvg++
		assert(!(ccnts.n&1))
		hid=ed.m_handler_registration["renderer"].as(int)
		bk_m_enable_hidden=m_enable_hidden
		m_enable_hidden=-1
		a=ed.GetStateEnMasse(hid,ccnts)
		m_enable_hidden=bk_m_enable_hidden
		all_x=GetFlatXEnMasse(a)//[GetFlatX(a[i:]) for i=0:5:a.n-5]
		dy_events=new TDeltaYItem[(all_x.n>>1)+m_ceos.n]
		p_dy=0L
		for i=0:2:all_x.n-1
			dy_events[p_dy]=TDeltaYItem(){
				flatx0_hidden:all_x[i+0],
				flatx1_hidden:all_x[i+1],
				dy_enforced:0LL,
			}
			p_dy++
		//////////////////////
		//convert ceos into dy items
		SortEmbededObjects()
		a2=GetFlatXEnMasse(ed.GetStateEnMasse(hid,[ceo.loc.ccnt for ceo in m_ceos]))
		for ceo,I in m_ceos
			dy_events[p_dy]=TDeltaYItem(){
				flatx0_hidden:a2[I],
				flatx1_hidden:a2[I],
				dy_enforced:ceo.dy,
			}
			p_dy++
		dy_events.Sortby(inline(a){return a.flatx0_hidden})
		dx_add=new TAddRangeItem[dy_events.n]
		dx_sub=new TSubRangeItem[dy_events.n]
		m_hidden_dx_add=dx_add
		m_hidden_dx_sub=dx_sub
		m_hidden_ccnts=ccnts
		w_hidden=m_w_ellipsis//charWidth(U_ELLIPSIS)
		x_new_cur=0LL;y_new_cur=0LL;flatx_ori_cur=0LL
		wrap_width=m_wrap_width_in_fp
		for dye,I in dy_events
			y_ori_cur=flatx_ori_cur/wrap_width
			if flatx_ori_cur<dye.flatx0_hidden:
				//honor and only honor the *original* newlines
				y_ori_next=dye.flatx0_hidden/wrap_width
				if y_ori_next>y_ori_cur:
					y_new_cur+=y_ori_next-y_ori_cur
					x_new_cur=dye.flatx0_hidden-y_ori_next*wrap_width
				else
					x_new_cur+=(dye.flatx0_hidden-flatx_ori_cur)
			y_new_cur+=dye.dy_enforced
			if dye.flatx0_hidden<dye.flatx1_hidden:
				x_new_cur+=w_hidden
			flatx_ori_cur=dye.flatx1_hidden
			dx=x_new_cur-(flatx_ori_cur-flatx_ori_cur/wrap_width*wrap_width)
			//assert(dx>=0LL)
			dfx=(dye.flatx1_hidden/wrap_width-y_new_cur)*wrap_width
			//assert(dfx>=0LL)
			////////////
			dx_add[I]=TAddRangeItem(){x:x_new_cur,y:y_new_cur-dye.dy_enforced, dx:dx,dfx:dfx, dy_enforced:dye.dy_enforced}
			dx_sub[I]=TSubRangeItem(){fx0:dye.flatx0_hidden,fx1:dye.flatx1_hidden, dx:dx,dfx:dfx}
	}
	AddHiddenRanges=function(CEditableText ed,i64 x,i64 y){
		//it's not necessarily an 'add'
		//test: are we on the last line? same line as last hidden should be enough
		//then again, we can't easily get flat X for the bsearch - precompute needs to be in xy pairs
		if m_enable_hidden<=0:return XYToX(x,y)
		if !m_hidden_ranges_prepared:
			PrepareHiddenRanges(ed)
		hc=charHeight()
		y_real=y/hc
		p=m_hidden_dx_add.InlineBisect(inline(a){return a.y<y_real||a.y==y_real&&a.x<=x})-1L
		if p>=0:
			dxitem=m_hidden_dx_add[p]
			x_real=x
			if y_real==dxitem.y:
				x_real-=dxitem.dx
			dfx=dxitem.dfx
			if dxitem.dy_enforced>0&&y_real-dxitem.dy_enforced<dxitem.y:
				//move down from the above of a CEO
				dfx+=dxitem.dy_enforced*m_wrap_width_in_fp
			return max(min(x_real,m_wrap_width_in_fp-1LL),0LL)+(y_real)*m_wrap_width_in_fp+dfx
		else
			return XYToX(x,y)
	}
	SubHiddenRanges=function(CEditableText ed,i64 fx0){
		auto fx=fx0
		y=fx/m_wrap_width_in_fp
		x=fx-y*m_wrap_width_in_fp
		if m_enable_hidden>0:
			if !m_hidden_ranges_prepared:
				PrepareHiddenRanges(ed)
			p=m_hidden_dx_sub.InlineBisect(inline(a){return a.fx0<fx})-1L
			if p>=0:
				dxitem=m_hidden_dx_sub[p]
				wrap_width=m_wrap_width_in_fp
				dx=0LL
				if dxitem.fx1/wrap_width==y||fx<dxitem.fx1:
					dx=dxitem.dx
				//Writeln('SubHiddenRanges ',p,' ',fx,' ',dxitem,' ',dx)
				fx=max(fx,dxitem.fx1)-dxitem.dfx
				y=fx/m_wrap_width_in_fp
				x=fx-y*m_wrap_width_in_fp
				x+=dx
		return (x,y)
	}
	IsRangeHidden=function(CEditableText ed,i64 ccnt0,i64 ccnt1){
		if m_enable_hidden<=0:return 0
		if !m_hidden_ranges_prepared:
			PrepareHiddenRanges(ed)
		p0=m_hidden_ccnts.InlineBisect(inline(i64 a){return a<=ccnt0})
		p1=m_hidden_ccnts.InlineBisect(inline(i64 a){return a<=ccnt1})
		return p0==p1&&(p0&1)
	}
	HideChars=function(CEditableText ed,i64 ccnt0,u8[] color_ids,string s){
		//if !m_enable_hidden:return
		if !m_hidden_ranges_prepared:
			PrepareHiddenRanges(ed)
		p=m_hidden_ccnts.Bisect(function(i64 a){return a<=ccnt0})
		if p>=m_hidden_ccnts.n:
			return
		ccnt_next=m_hidden_ccnts[p]-ccnt0
		enable_hidden=(m_enable_hidden>0)
		i_prev=0L
		for i=0L:color_ids.n-1
			if i==ccnt_next:
				if i&&enable_hidden:color_ids[i_prev]|=u8(128)
				p++
				if p>=m_hidden_ccnts.n:
					return
				ccnt_next=m_hidden_ccnts[p]-ccnt0
			if p&1:
				if enable_hidden:
					color_ids[i]=u8(255)
				else
					color_ids[i]|=u8(128)
			if i32(u8(s[i]))&0xc0!=0x80:
				i_prev=i
		if enable_hidden&&color_ids.n==ccnt_next&&color_ids.n:
			color_ids[i_prev]|=u8(128)
	}
	JS_HideRange=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		if !ed:return JS.ReturnError("invalid editor")
		ccnt0=JS.Param(1).as(i64)
		ccnt1=JS.Param(2).as(i64)
		if ccnt0<ccnt1:
			loc0=ed.CreateLocator(ccnt0,1)
			loc1=ed.CreateLocator(ccnt1,-1)
			m_hidden_ranges.push(loc0)
			m_hidden_ranges.push(loc1)
			m_hidden_ranges_prepared=0
		return 0
	}
	JS_ShowRange=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		if !ed:return JS.ReturnError("invalid editor")
		ccnt0=JS.Param(1).as(i64)
		ccnt1=JS.Param(2).as(i64)
		ranges0=m_hidden_ranges
		ranges1=new CLocator[]
		did=0
		for i=0:2:ranges0.n-2
			if ranges0[i].ccnt<=ccnt1&&ccnt0<=ranges0[i+1].ccnt:
				//drop it
				ranges0[i].discarded=i8(1)
				ranges0[i+1].discarded=i8(1)
				did=1
			else
				ranges1.push(ranges0[i])
				ranges1.push(ranges0[i+1])
		if did:
			m_hidden_ranges=ranges1
			m_hidden_ranges_prepared=0
		return 0
	}
	JS_SnapToShown=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		if !ed:return JS.ReturnError("invalid editor")
		ccnt=JS.Param(1).as(i64)
		direction=JS.Param(2).or(1)
		if m_enable_hidden>0:
			if !m_hidden_ranges_prepared:
				PrepareHiddenRanges(ed)
			p0=m_hidden_ccnts.Bisect(function(i64 a){return a<=ccnt})
			if p0<0||!(p0&1):
				//do nothing
			else
				if direction<0:
					ccnt=m_hidden_ccnts[p0-1]
				else
					ccnt=m_hidden_ccnts[p0]
		return JS.Return(ccnt)
	}
	JS_IsRangeHidden=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		if !ed:return JS.ReturnError("invalid editor")
		ccnt0=JS.Param(1).as(i64)
		ccnt1=JS.Param(2).as(i64)
		ret=0
		if ccnt0<ccnt1:
			ret=IsRangeHidden(ed,ccnt0,ccnt1)
		return JS.Return(ret)
	}
	JS_GetHiddenRanges=function(JSContext JS){
		ret=JS.NewArray()
		foreach loc,I in m_hidden_ranges
			ret[I]=loc.ccnt
		return JS.Return(ret)
	}
	////////////////////
	JS_EmbedObject=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		if !ed:return JS.ReturnError("invalid editor")
		ccnt=JS.Param(1).as(i64)
		obj=JS.Param(2).as(JSObject)
		loc=ed.CreateLocator(ccnt,1)
		m_ceos.push(new CCodeEmbededObject(){
			loc:loc,
			obj:obj,
			dy:obj["h"].as(i64),
		})
		m_ceos_sorted=0
		m_hidden_ranges_prepared=0
		return JS.Return(1)
	}
	JS_QueryEmbeddedObjectAfter=function(JSContext JS){
		ccnt=JS.Param(0).as(i64)
		SortEmbededObjects()
		p=m_ceos.InlineBisect(inline(a){return a.loc.ccnt<ccnt})-1L
		if p<m_ceos.n:
			return JS.Return(p)
		else
			return 0
	}
	JS_RemoveEmbeddedObject=function(JSContext JS){
		id=JS.Param(0).as(iptr)
		if uptr(id)<uptr(m_ceos.n):
			m_ceos[id].obj.CallMethod(int,"OnDestroy")
		m_ceos=[ceo for ceo,I in m_ceos if I!=id]
		m_ceos_sorted=0
		m_hidden_ranges_prepared=0
		return 0
	}
	JS_RemoveAllEmbeddedObjects=function(JSContext JS){
		for ceo in m_ceos
			ceo.obj.CallMethod(int,"OnDestroy")
		m_ceos.clear()
		m_ceos_sorted=0
		m_hidden_ranges_prepared=0
		return 0
	}
	////////////////////
	JS_ResetWrapping=function(JSContext JS){
		auto m_wrap_width=JS.Param(0).or(0.f)
		auto obj=JS.Param(1).as(JSObject)
		if !(m_wrap_width>0.f):
			m_wrap_width_in_fp=DEFAULT_WRAP_WIDTH_IN_CHARS*charWidth(int(' '))
			m_wrap_width_in_fp=(m_wrap_width_in_fp/m_tab_width_in_fp)*m_tab_width_in_fp
		else
			m_wrap_width_in_fp=(float2fixed(m_wrap_width)/m_tab_width_in_fp)*m_tab_width_in_fp
		m_hidden_ranges_prepared=0
		obj["displayed_wrap_width"]=fixed2double(m_wrap_width_in_fp)
		return 0
	}
	JS_ResetTentativeOps=function(JSContext JS){
		m_precomputed_overlays_for_tentative_editops=TOverlayItem[].NULL
		return 0
	}
	///////////////////////
	__JS_prototype=function(JSObject proto){
		proto.ExportMethod(this,"HunspellAddWord",JS_AddWord)
		proto.ExportMethod(this,"HunspellSuggest",JS_Suggest)
		proto.ExportProperty(this,"m_temporarily_disable_spell_check")
		proto.ExportProperty(this,"m_enable_ceo_rendering")
		proto.ExportMethod(this,"ResetSpellChecker",JS_ResetSpellChecker)
		proto.ExportMethod(this,"HunspellClearContext",JS_ClearContext)
		////////////////////
		proto.ExportProperty(this,"m_hidden_ranges_prepared")
		proto.ExportProperty(this,"m_enable_hidden")
		proto.ExportMethod(this,"HideRange",JS_HideRange)
		proto.ExportMethod(this,"ShowRange",JS_ShowRange)
		proto.ExportMethod(this,"SnapToShown",JS_SnapToShown)
		proto.ExportMethod(this,"IsRangeHidden",JS_IsRangeHidden)
		proto.ExportMethod(this,"GetHiddenRanges",JS_GetHiddenRanges)
		////////////////////
		proto.ExportMethod(this,"EmbedObject",JS_EmbedObject)
		proto.ExportMethod(this,"QueryEmbeddedObjectAfter",JS_QueryEmbeddedObjectAfter)
		proto.ExportMethod(this,"RemoveEmbeddedObject",JS_RemoveEmbeddedObject)
		proto.ExportMethod(this,"RemoveAllEmbeddedObjects",JS_RemoveAllEmbeddedObjects)
		////////////////////
		proto.ExportMethod(this,"ResetWrapping",JS_ResetWrapping)
		////////////////////
		proto.ExportProperty(this,"m_tentative_editops")
		proto.ExportProperty(this,"m_virtual_diffs")
		proto.ExportMethod(this,"ResetTentativeOps",JS_ResetTentativeOps)
	}
	//auto __done__()
	//	Writeln('!!! LAYOUTER DESTRUCTED !!!')

class CColorer_programmer
	CLanguageDescription m_lang
	name=function(){return "colorer"}
	stateSize=function(){return int(m_lang.m_total_state_size)}
	contextSize=function(){return int(m_lang.m_context_size)}
	SetTextStyle=function(JSObject obj){
		m_lang=obj["language"].as(CLanguageDescription)
	}
	//state format: ~and_mask|xor_mask, global bracket delta, min brackets
	auto GetTokenList(string s_context,string s,iptr ofs)
		auto ld=m_lang
		auto sz_context=int(s_context.n)
		auto n_char_types=ld.m_n_char_types
		auto char_map=ld.m_char_map
		auto dfa=ld.m_bigchar_dfa
		auto dfa_ops=ld.m_bigchar_dfa_ops
		auto token_lengths=ld.m_token_lengths
		//container={'forEach':inline(fbody){
		//	for i=0:sz_context-1
		//		fbody(s_context[s_context.n-sz_context+i],~i)
		//	foreach ch,I in s
		//		fbody(ch,int(I))
		//}}
		ret=new int[]
		st=0
		for(I=-sz_context;I<=ofs;I++)
			if st<0:
				p_ops=~st
				for(;;)
					st=int(dfa_ops[p_ops])
					if st<0:
						tok_id=~st
						ptok=I-int(token_lengths[tok_id])
						if ptok>=0:
							//flip the token id to sort high priority tokens first
							ret.push((ptok<<16)+(0xffff^tok_id))
						p_ops++
					else
						break
			if I>=ofs:break
			if I>=0:
				ch=int(u8(s[I]))
			else
				ch=int(u8(s_context[s_context.n+I]))
			chi=int(char_map[ch])
			st=int(i16(dfa[st*n_char_types+chi]))
		//shell sort since ret should have been mostly sorted
		//use optimistic gaps, worst case won't happen: we can't have inverted stuff longer than token length
		for(gap=(ret.n+1)>>1;gap>0;gap=(gap+1)>>1)
			for i=gap:ret.n-1
				tmp=ret[i]
				for(j=i;j>=gap&&ret[j-gap]>tmp;j-=gap)
					ret[j]=ret[j-gap]
				ret[j]=tmp
			if gap==1:break
		//flip back the token id
		foreach d,I in ret
			ret[I]=d^0xffff
		return ret
	AddString=function(i64[] a,i64[] pp,string s_context,string s,iptr ofs){
		//here it's just the states
		ld=m_lang
		key_mask=(1<<ld.m_n_key_states)-1
		//do the dfa and get all tokens
		tokens=GetTokenList(s_context,s,ofs)
		bdfa=ld.m_bracket_dfa
		token_masks=ld.m_token_enabling_masks
		token_lengths=ld.m_token_lengths
		n_tokens=ld.m_n_tokens
		for sti=0:ld.m_n_key_states-1
			pa=3*sti
			and_mask=~int(a[pa+0]>>32)
			xor_mask=int(a[pa+0])
			inc_value=0
			min_value=0
			st=ld.m_id_from_key_state[((ld.m_all_key_states[sti]&and_mask)^xor_mask)&key_mask]//*ld.m_n_tokens
			I_next=0
			foreach tok_I in tokens
				I=tok_I>>16
				tok=(tok_I&0xffff)
				if I<I_next||!(token_masks[st]&(1<<tok)):continue
				I_next=I+int(token_lengths[tok])
				tran=bdfa[st*n_tokens+int(tok)]
				and_mask&=tran.m_and
				xor_mask&=tran.m_and
				xor_mask^=tran.m_xor
				st=int(tran.m_next_state)
				inc_value+=int(tran.m_delta)
				//if !sti:Write(inc_value)
				if min_value>inc_value:
					min_value=inc_value
			//if !sti:Writeln(' ',inc_value,' ',ofs)
			a[pa+0]=((i64(~and_mask)<<32)|i64(u64(u32(xor_mask))))
			a[pa+2]=min(a[pa+2],a[pa+1]+i64(min_value))
			a[pa+1]+=i64(inc_value)
	}
	Add=function(i64[] a,i64[] b){
		ld=m_lang
		m_all_key_states=ld.m_all_key_states
		m_id_from_key_state=ld.m_id_from_key_state
		key_mask=(1<<ld.m_n_key_states)-1
		for sti=0:ld.m_n_key_states-1
			pa=3*sti
			and_maska=~int(a[pa+0]>>32)
			xor_maska=int(a[pa+0])
			//we need a state lookup to cover the happened key transitions
			pb=3*m_id_from_key_state[((m_all_key_states[sti]&and_maska)^xor_maska)&key_mask]
			and_maskb=~int(b[pb+0]>>32)
			xor_maskb=int(b[pb+0])
			and_mask=(and_maska&and_maskb)
			xor_mask=((xor_maska&and_maskb)^xor_maskb)
			a[pa+0]=((i64(~and_mask)<<32)|i64(u32(xor_mask)))
			a[pa+2]=min(a[pa+2],a[pa+1]+b[pb+2])
			a[pa+1]+=b[pb+1]
	}
	//For coloring states, we need a colorer
	//latex \: use word-based highlighting
	ComputeCharColorID=function(i64[] a,string s_context,string s){
		ld=m_lang
		crules=ld.m_coloring_rules
		bdfa=ld.m_bracket_dfa
		token_masks=ld.m_token_enabling_masks
		token_lengths=ld.m_token_lengths
		//////////////
		key_mask=(1<<ld.m_n_key_states)-1
		and_maska=~int(a[0]>>32)
		xor_maska=int(a[0])
		bst=ld.m_id_from_key_state[xor_maska&key_mask]//*ld.m_n_tokens
		mask=xor_maska
		mask0=0
		struct TColoringEvent
			int ofs
			i8 rule_id
			i8 direction
		coloring_events=new TColoringEvent[]
		inline testEvent(I,lg_token)
			//Writeln('testEvent ',I,' ',lg_token,' ',mask)
			if mask!=mask0:
				//test color rules sequentially - they are only tested at color *changes*
				for i=crules.n-1:-1:0
					mask_i=crules[i].bmask
					if (mask^mask0)&mask_i:
						evt=TColoringEvent(){rule_id:i8(i)}
						if mask&mask_i:
							//we're entering, backtrack
							evt.ofs=(crules[i].extend_flags&1)?int(I-iptr(lg_token)):int(I)
							evt.direction=i8(1)
						else
							evt.ofs=(crules[i].extend_flags&2)?int(I):int(I-iptr(lg_token))
							evt.direction=i8(0)
						coloring_events.push(evt)
				mask0=mask
		//the first TOKEN may start before the block...
		testEvent(-s_context.n-1,0)
		n_tokens=ld.m_n_tokens
		tokens=GetTokenList(s_context,s,s.n)
		I_next=0
		foreach tok_I in tokens
			I=tok_I>>16
			tok=(tok_I&0xffff)
			if I<I_next||!(token_masks[bst]&(1<<tok)):continue
			lg_token=int(token_lengths[tok])
			I_next=I+lg_token
			//ignore nest-only brackets
			tran=bdfa[bst*n_tokens+tok]
			//Writeln(I,' ',bst/ld.m_n_tokens,' ',tok,' ',tran,' ',mask)
			bst=int(tran.m_next_state)
			mask&=tran.m_and
			mask^=tran.m_xor
			testEvent(I_next,lg_token)
		coloring_events.Sortby(inline(evt){return evt.ofs*2+(evt.direction)})
		//Writeln(coloring_events)
		crule_activation=new i8[crules.n]
		ret=new u8[s.n]
		ofs_last=0L
		active_color=0
		foreach evt in coloring_events
			crule_activation[evt.rule_id]=int(evt.direction)
			if ofs_last<evt.ofs:
				for j=ofs_last:evt.ofs-1
					ret[j]=active_color
				ofs_last=evt.ofs
			active_color=0
			for ci=crule_activation.n-1:-1:0
				if crule_activation[ci]:
					active_color=ci+1
					break
		for j=ofs_last:ret.n-1
			ret[j]=active_color
		//Writeln(coloring_events)
		//Writeln(ret)
		return ret
	}
	/////////////////////////////
	//bracket seeking
	SEEK_MODE_BRACKET=0LL
	SEEK_MODE_STATE=1LL
	hasValidResult=function(i64[] a,i64[] da, i64[] b){
		if b[0]==SEEK_MODE_BRACKET:
			ld=m_lang
			key_mask=(1<<ld.m_n_key_states)-1
			and_maska=~int(a[0]>>32)
			xor_maska=int(a[0])
			pb=3*ld.m_id_from_key_state[((ld.m_all_key_states[0]&and_maska)^xor_maska)&key_mask]
			return a[1]+da[pb+2]<=b[1]
		else
			assert(0)
			return 0
	}
	QueryPerCharValidity=function(i64[] a,i64[] pp,string s_context,string s, i64[] b){
		if b[0]==SEEK_MODE_BRACKET:
			ld=m_lang
			key_mask=(1<<ld.m_n_key_states)-1
			bdfa=ld.m_bracket_dfa
			token_masks=ld.m_token_enabling_masks
			token_lengths=ld.m_token_lengths
			cur_delta=(a[1]-b[1])
			and_mask=~int(a[0]>>32)
			xor_mask=int(a[0])
			st=ld.m_id_from_key_state[((ld.m_all_key_states[0]&and_mask)^xor_mask)&key_mask]//*ld.m_n_tokens
			ret=new i8[s.n+1]
			ofs_last=0L
			is_valid=i8(cur_delta<=0LL)
			n_tokens=ld.m_n_tokens
			tokens=GetTokenList(s_context,s,s.n)
			I_next=0
			//foreach tok,I in EnumTokens(s_context,s)
			foreach tok_I in tokens
				I=tok_I>>16
				tok=(tok_I&0xffff)
				if I<I_next||!(token_masks[st]&(1<<tok)):continue
				lg_token=int(token_lengths[tok])
				I_next=I+lg_token
				for i=ofs_last:I_next-1
					ret[i]=is_valid
				ofs_last=I_next
				tran=bdfa[st*n_tokens+int(tok)]
				and_mask&=tran.m_and
				xor_mask&=tran.m_and
				xor_mask^=tran.m_xor
				st=int(tran.m_next_state)
				//Writeln(tok,' ',tran.m_delta,' ',I_next,' ',cur_delta,' ',int(is_valid))
				cur_delta+=i64(tran.m_delta)
				is_valid=i8(cur_delta<=0LL)
			for i=ofs_last:ret.n-1
				ret[i]=is_valid
			return ret
		else
			assert(0)
			return i8[].NULL
	}
	////////////////////
	//for JS operations
	__JS_prototype=function(JSObject proto){}

registerUIExtension(function(JSObject JS_UI,CUISandbox sbox,int is_real){
	JS_UI["CreateLanguageDefinition"]=function(JSContext JS){
		//create from a LanguageDefinition object
		obj=JS.Param(0).as(JSObject)
		if !obj:return JS.ReturnError("undefined language definition object")
		ret=new CLanguageDescription
		//bigchar part
		m_big_chars=obj["m_big_chars"].as(JSObject)
		if !m_big_chars:return JS.ReturnError("undefined token list")
		m_big_char_lengths=obj["m_big_char_lengths"].as(JSObject)
		native_bigchars=new string[]
		token_lengths=new u8[]
		char_map=new u8[256]
		context_size=0L
		for i=0:m_big_chars.length()-1
			s_bigchar_i=m_big_chars[i].or("")
			if !s_bigchar_i.n:return JS.ReturnError("tokens cannot be empty")
			native_bigchars.push(s_bigchar_i)
			lg_token=int(s_bigchar_i.n)
			if m_big_char_lengths:
				lg_token=m_big_char_lengths[s_bigchar_i].or(lg_token)
			token_lengths.push(lg_token)
			foreach ch in s_bigchar_i
				char_map[int(u8(ch))]=1
			context_size=max(context_size,s_bigchar_i.n)
			//Writeln('token ',i,': ',s_bigchar_i)
		ret.m_context_size=int(context_size)
		////////////////////////////
		//we need bigchars to be a prefix code, but no checking yet
		//it's just AhoCorasick... but the builtin implementation is not for this
		//here we can affored precomputation, but runtime cost should be minimized: no funny business with next
		//and we can do it 8-bit - don't need awareness to handle UTF8
		assert(native_bigchars.n<128)
		n_char_types=1
		for i=0:255
			if char_map[i]:
				char_map[i]=n_char_types
				n_char_types++
		assert(n_char_types<=256)
		fc_lists=new int[][n_char_types]
		for i=0:fc_lists.n-1
			fc_lists[i]=new int[]
		foreach spattern,I in native_bigchars
			ch0=int(u8(spattern[0]))
			if spattern.n==1:
				//state=~int(I<<8)
				state=0x40000000+int(I)
			else
				state=int(I)|(1<<16)
			fc_lists[int(char_map[ch0])].push(state)
		//multi-state DFA -> single-state DFA
		state_map=new int[int[]]
		ops_map=new int[u16[]]
		state_addrs=[0]
		Q=[new int[]]
		depths=[0]
		dfa=new u16[n_char_types]
		dfa_ops=new i16[]
		reached=new i8[native_bigchars.n]
		for(i=0L;i<Q.n;i++)
			cur_states=Q[i]
			cur_depth=depths[i]
			my_addr=i*n_char_types
			tran=new int[][n_char_types]
			if cur_states.n&&cur_states[0]<0:
				//we have deferred tokens, DO NOT RESTART
				for j=0:tran.n-1
					tran[j]=new int[]
			else
				for j=0:tran.n-1
					tran[j]=new(fc_lists[j])
			//fc_lists
			foreach stpacked in cur_states
				//if stpacked<0:
				//	//deferred token, increase rollback but keep it
				//	for j=0:tran.n-1
				//		tran[j].push(stpacked-1)
				//	continue
				pid=(stpacked&0xffff)
				pos=(stpacked>>16)
				s_pid=native_bigchars[pid]
				ch_std=int(char_map[int(u8(s_pid[pos]))])
				pos++
				if pos>=s_pid.n:
					//add action
					tran[ch_std].push(0x40000000+pid)
				else
					tran[ch_std].push(pid+(pos<<16))
			//Write(cur_states,' ')
			for j=0:tran.n-1
				new_states=tran[j]
				new_states.Sort()
				new_states.Unique()
				actions=u16[].NULL
				p_ops=-1L
				if new_states.n&&new_states.back()>=0x40000000:
					p_ops=dfa_ops.n
					while new_states.n&&new_states.back()>=0x40000000:
						tok_id_j=(new_states.back()&0xffff)
						reached[tok_id_j]=i8(1)
						dfa_ops.push(i16(~tok_id_j))
						new_states.n--
				new_stid=state_map[new_states]
				if !new_stid:
					if new_states.n:
						new_stid=int(Q.n)
						Q.push(new_states)
						depths.push(cur_depth+1)
						dfa.resize(dfa.n+n_char_types)
						assert(dfa.n==n_char_types*Q.n)
						state_map[new_states]=new_stid
				if p_ops>=0L:
					assert(p_ops<32768)
					assert(new_stid<32768)
					dfa_ops.push(i16(new_stid))
					dfa[my_addr+j]=u16(u32(~p_ops))
				else
					dfa[my_addr+j]=u16(new_stid)
		ret.m_char_map=char_map
		ret.m_n_char_types=n_char_types
		ret.m_bigchar_dfa=dfa
		ret.m_bigchar_dfa_ops=dfa_ops
		if Platform.BUILD=="debug":
			for i=0:reached.n-1
				if !reached[i]:
					Writeln("warning: big char '@1' can never get triggered".Replace(["@1",native_bigchars[i]]))
		/////////////
		//the list of brackets
		m_bracket_types=obj["m_bracket_types"].as(JSObject)
		if !m_bracket_types:return JS.ReturnError("undefined bracket types")
		n_key_brackets=0
		brackets=new TBracketType[]
		auto parseTokenSet(JSObject obj,string s_name)
			auto obj_set=obj[s_name].as(JSObject)
			auto n=obj_set.length()
			auto ret_set=new int[n]
			for j=0:n-1
				ret_set[j]=obj_set[j].or(0)
			return ret_set
		for i=0:m_bracket_types.length()-1
			obj_i=m_bracket_types[i].as(JSObject)
			if !obj_i:return JS.ReturnError("undefined bracket type")
			type=obj_i["type"].or(REAL_TYPE_MOV)
			is_key=obj_i["is_key"].or(0)
			if is_key:
				assert(n_key_brackets==i)
				n_key_brackets=i+1
			tok0=parseTokenSet(obj_i,"tok0")
			tok1=parseTokenSet(obj_i,"tok1")
			brackets.push(TBracketType(){type:type,tok0:tok0,tok1:tok1})
		assert(n_key_brackets<=12)
		/////////////
		//the state masking rules
		m_enabled_from_inside=new int[1<<n_key_brackets]
		m_id_from_key_state=new int[1<<n_key_brackets]
		m_all_key_states=new int[]
		m_token_enabling_masks=new int[]
		m_entry_states=obj["m_entry_states"].as(JSObject)
		if !m_entry_states:return JS.ReturnError("undefined entry states")
		for i=0:m_entry_states.length()-1
			obj_i=m_entry_states[i].as(JSObject)
			if !obj_i:return JS.ReturnError("undefined entry state")
			inside_mask=obj_i["inside"].or(0)
			m_enabled_from_inside[inside_mask]=obj_i["enabled"].or(0)
			m_token_enabling_mask_i=obj_i["token_enabled"].or(-1)
			m_id_from_key_state[inside_mask]=i+1
			m_all_key_states.push(inside_mask)
			m_token_enabling_masks.push(m_token_enabling_mask_i)
			//Writeln(inside_mask,' ',m_token_enabling_mask_i)
		for i=0:m_id_from_key_state.n-1
			m_id_from_key_state[i]--
		ret.m_all_key_states=m_all_key_states
		ret.m_token_enabling_masks=m_token_enabling_masks
		/////////////
		//the bracket DFA
		m_contradiction_fixes=obj["m_contradiction_fixes"].as(JSObject)
		n_key_states=m_all_key_states.n
		n_tokens=native_bigchars.n
		bdfa=new TBDFATransition[n_key_states*n_tokens]
		assert(bdfa.n<32768)
		for sti=0:n_key_states-1
			st=sti*n_tokens
			key_state=m_all_key_states[sti]
			enabled_mask=m_enabled_from_inside[key_state]
			for i=0:brackets.n-1
				if !(enabled_mask&(1<<i)):continue
				type=brackets[i].type
				tok0=brackets[i].tok0
				tok1=brackets[i].tok1
				mask_i=1<<i
				if type==REAL_TYPE_MOV:
					//m_and will be not-ed later
					foreach tok in tok0
						bdfa[st+tok].m_and|=mask_i
						bdfa[st+tok].m_xor|=mask_i
					foreach tok in tok1
						bdfa[st+tok].m_and|=mask_i
				else if type==REAL_TYPE_XOR:
					foreach tok in tok0
						bdfa[st+tok].m_xor|=mask_i
					foreach tok in tok1
						bdfa[st+tok].m_xor|=mask_i
				else if type==REAL_TYPE_ADD:
					foreach tok in tok0
						assert(!bdfa[st+tok].m_delta)
						bdfa[st+tok].m_delta+=i16(1)
					foreach tok in tok1
						assert(!bdfa[st+tok].m_delta)
						bdfa[st+tok].m_delta+=i16(-1)
				else
					assert(0)
			for i=0:n_tokens-1
				bdfa[st+i].m_and=~bdfa[st+i].m_and
				key_state_i=((key_state&bdfa[st+i].m_and)^bdfa[st+i].m_xor)
				if m_id_from_key_state[key_state_i]<0:
					//self-contradicting transition, correct it by anding the enabling mask
					key_state_i=m_contradiction_fixes[key_state_i].as(int)
				assert(m_id_from_key_state[key_state_i]>=0)
				//bdfa[st+i].m_next_state=u16((m_id_from_key_state[key_state_i])*n_tokens)
				bdfa[st+i].m_next_state=u16(m_id_from_key_state[key_state_i])
		for i=0:m_id_from_key_state.n-1
			if m_id_from_key_state[i]<0:
				m_id_from_key_state[i]=m_id_from_key_state[m_contradiction_fixes[i].as(int)]
		ret.m_id_from_key_state=m_id_from_key_state
		ret.m_n_key_states=n_key_states
		ret.m_token_lengths=token_lengths
		ret.m_n_tokens=n_tokens
		ret.m_bracket_dfa=bdfa
		/////////////
		//the coloring rules
		m_coloring_rules=obj["m_coloring_rules"].as(JSObject)
		ret.m_coloring_rules=new TColorRule[]
		for i=0:m_coloring_rules.length()-1
			obj_i=m_coloring_rules[i].as(JSObject)
			if !obj_i:return JS.ReturnError("undefined coloring rules")
			bid=obj_i["bid"].or(0)
			ret.m_coloring_rules.push(TColorRule(){
				color_name:obj_i["color_name"].or(""),
				bmask:1<<bid,
				extend_flags:obj_i["extend_flags"].or(3),
			})
		/////////
		//1 bitmask + 1 counter for each nested + 1 min
		ret.m_total_state_size=3*m_all_key_states.n
		/////////
		//the word colorer, which is stand-alone
		//we have keywords and starting chars
		ret.m_default_color_name=obj["m_color_default"].as(string)
		///////
		clunky_dfa=new int[]
		word_char_map=new u8[256]
		word_char_set=new u32[4]
		for ch=0:255
			if (ch<128&&isWordChar(ch)):
				word_char_set[ch>>5]|=1u<<(ch&31)
			else
				word_char_map[ch]=1
		s_non_default_word_chars=obj["m_non_default_word_chars"].as(string)
		if s_non_default_word_chars:
			foreach ch in Utf8Chars(s_non_default_word_chars)
				if ch<128:
					word_char_set[ch>>5]^=1u<<(ch&31)
					word_char_map[ch]=!word_char_map[ch]
		n_word_char_types=2
		word_color_id_map=new int[string]
		/////////////
		ret.m_word_color_names=new string[]
		ret.m_word_color_names.push("<none>")
		auto getWordColorID(string s_color)
			auto color_id=word_color_id_map[s_color]-1
			if color_id<0:
				color_id=int(ret.m_word_color_names.n)
				ret.m_word_color_names.push(s_color)
				word_color_id_map[s_color]=color_id+1
			return color_id
		m_keyword_sets=obj["m_keyword_sets"].as(JSObject)
		s_spell_color=obj["m_color_id_spell_check"].as(string)
		if s_spell_color:
			ret.m_color_id_spell_check=getWordColorID(s_spell_color)
		else
			ret.m_color_id_spell_check=-1
		s_kd_color=obj["m_color_id_key_decl"].as(string)
		if s_kd_color:
			ret.m_kd_color=getWordColorID(s_kd_color)
		else
			ret.m_kd_color=-1
		//a unified color theme for now
		ret.m_key_decl_color_ids=[
			getWordColorID("color_key_decl_func"),
			getWordColorID("color_key_decl_class"),
			getWordColorID("color_key_decl_macro")]
		init_state_by_kwset=new int[]
		for ksi=0:m_keyword_sets.length()-1
			keyword_set_i=m_keyword_sets[ksi].as(JSObject)
			id_default=getWordColorID(keyword_set_i["m_word_color_default"].as(string))
			st0=int(clunky_dfa.n>>8)
			init_state_by_kwset.push(st0)
			clunky_dfa.resize(st0*256+256)
			for i=0:255
				clunky_dfa[st0*256+i]=~id_default
			//[word,color, ...]
			keywords=keyword_set_i["m_keywords"].as(JSObject)
			//[MakeCharSet,color, ...]
			word_openers=keyword_set_i["m_word_openers"].as(JSObject)
			for i=0:2:keywords.length()-2
				s_word=keywords[i+0].as(string)
				s_color=keywords[i+1].as(string)
				color_id=word_color_id_map[s_color]
				if !color_id:
					color_id=int(ret.m_word_color_names.n)
					ret.m_word_color_names.push(s_color)
					word_color_id_map[s_color]=color_id
				//DFA insertion
				st=st0
				foreach ch,I in s_word
					//all keyword chars are unique
					chi=int(u8(ch))
					if !word_char_map[chi]:
						word_char_map[chi]=n_word_char_types
						n_word_char_types++
					if clunky_dfa[st*256+chi]<0:
						n0=int(clunky_dfa.n)
						clunky_dfa[st*256+chi]=(n0>>8)
						clunky_dfa.resize(n0+256)
						for j=0:255
							clunky_dfa[n0+j]=~id_default
					st=clunky_dfa[st*256+chi]
				clunky_dfa[st*256+0]=(~color_id)
			for i=0:2:word_openers.length()-2
				cset=MakeCharSet(word_openers[i+0].as(string))
				s_color=word_openers[i+1].as(string)
				color_id=word_color_id_map[s_color]
				if !color_id:
					color_id=int(ret.m_word_color_names.n)
					ret.m_word_color_names.push(s_color)
					word_color_id_map[s_color]=color_id
				for ch=0:255
					if isInCharSet(cset,ch):
						if !word_char_map[ch]:
							word_char_map[ch]=n_word_char_types
						clunky_dfa[st0*256+ch]=~color_id
				n_word_char_types++
		ret.m_word_char_set=uint4(word_char_set[0],word_char_set[1],word_char_set[2],word_char_set[3])
		ret.m_word_char_map=word_char_map
		ret.m_n_word_char_types=n_word_char_types
		//compact the clunky_dfa
		word_char_representatives=new int[n_word_char_types]
		for ch=255:-1:0
			word_char_representatives[word_char_map[ch]]=ch
		word_dfa=new int[(clunky_dfa.n>>8)*n_word_char_types]
		for sti=0:256:clunky_dfa.n-256
			st_final=(sti>>8)*n_word_char_types
			for i=0:n_word_char_types-1
				tran_i=clunky_dfa[sti+word_char_representatives[i]]
				if tran_i>=0:tran_i*=n_word_char_types
				word_dfa[st_final+i]=tran_i
		ret.m_word_dfa=word_dfa
		//set the per-rule initial states
		ret.m_trigger_chars=obj["m_trigger_char"].as(string)
		m_word_dfa_initial_state=obj["m_word_dfa_initial_state"].as(JSObject)
		m_word_dfa_initial_state_triggered=obj["m_word_dfa_initial_state_triggered"].as(JSObject)
		n=m_word_dfa_initial_state.length()
		assert(n==ret.m_coloring_rules.n+1)
		ret.m_word_dfa_initial_state=new int[n]
		ret.m_word_dfa_initial_state_triggered=new int[n]
		//////////////
		for i=0:m_word_dfa_initial_state.length()-1
			st=m_word_dfa_initial_state[i].as(int)
			if st>=0:
				st=init_state_by_kwset[st]*n_word_char_types
			stt=m_word_dfa_initial_state_triggered[i].as(int)
			if stt>=0:
				stt=init_state_by_kwset[stt]*n_word_char_types
			else
				stt=st
			ret.m_word_dfa_initial_state[i]=st
			ret.m_word_dfa_initial_state_triggered[i]=stt
		return JS.Return(ret)
	}
})

class CSeeker_indentation
	name=function(){return "seeker_indentation"}
	stateSize=function(){return 1}
	contextSize=function(){return MAX_ALLOWED_INDENTATION}
	/////////
	inline EnumLineIndentation(string s_context,string s)
		return {'forEach':inline(fbody_outer){
			sz_context=s_context.n
			container={'forEach':inline(fbody){
				for i=0:sz_context-1
					fbody(s_context[s_context.n-sz_context+i],~i)
				foreach ch,I in s
					fbody(ch,int(I))
			}}
			//place the values at the enhanced homes
			//blank lines do not count
			n_ind=0
			foreach ch,I in container
				if ch==' '||ch=='\t':
					if n_ind>=0:n_ind++
				else
					if ch=='\r':
						//ignore, make it invalid
						n_ind=-1
						continue
					else if ch=='\n':
						//new line, reset n_ind without triggering outer loop
						n_ind=0
						continue
					if n_ind>=0:
						if I>=0:
							fbody_outer(min(n_ind,MAX_ALLOWED_INDENTATION),I)
						n_ind=-1
		}}
	/////////
	AddString=function(i64[] a,i64[] pp,string s_context,string s,iptr ofs){
		ind_min=int(a[0])+MAX_ALLOWED_INDENTATION
		foreach ind,I in EnumLineIndentation(s_context,s[:ofs-1])
			if ind_min>ind:
				ind_min=ind
		a[0]=i64(ind_min-MAX_ALLOWED_INDENTATION)
	}
	Add=function(i64[] a,i64[] b){
		a[0]=min(a[0],b[0])
	}
	hasValidResult=function(i64[] a,i64[] da, i64[] b){
		return da[0]+i64(MAX_ALLOWED_INDENTATION)<=b[0]
	}
	QueryPerCharValidity=function(i64[] a,i64[] pp,string s_context,string s, i64[] b){
		ret=new i8[s.n]
		goal=int(b[0])
		foreach ind,I in EnumLineIndentation(s_context,s)
			if ind<=goal:
				ret[I]=1
		return ret
	}

registerStateHandler("renderer_programmer",CLayouter_programmer)
registerStateHandler("colorer_programmer",CColorer_programmer)
registerStateHandler("seeker_indentation",CSeeker_indentation)

///////////////////////////////////////////
NEXT_READ_SIZE=4194304
INITIAL_READ_SIZE=16777216//2097152
WRITE_BATCH=4194304
//NEXT_READ_SIZE=233
//INITIAL_READ_SIZE=233
//WRITE_BATCH=4194304
class CLoadingContext
	i64 sz,sz_read
	int encoding
	//////////
	//string fn
	System.IO.CFile hf
	string s_lingering
	//////////
	float progress
	JS_discard=function(JSContext JS){
		if hf:
			hf.Close()
			hf=System.IO.CFile.NULL
		return 0
	}
	__JS_prototype=function(JSObject proto){
		proto.ExportProperty(this,"progress")
		proto.ExportMethod(this,"discard",JS_discard)
	}

class CSavingContext
	i64 ofs
	//////////
	string fn
	System.IO.CFile hf
	//////////
	float progress
	auto __done__()
		if hf:
			hf.Close()
			hf=System.IO.CFile.NULL
	JS_discard=function(JSContext JS){
		if hf:
			hf.Close()
			hf=System.IO.CFile.NULL
		return 0
	}
	__JS_prototype=function(JSObject proto){
		proto.ExportProperty(this,"progress")
		proto.ExportMethod(this,"discard",JS_discard)
	}

///////////////////////////////////////////
//inline chrequi(ch0,chw0)
//	ch=int(ch0)
//	chw=int(chw0)
//	return ch0==chw0||(ch^chw)==0x20&&u32((ch|0x20)-int('a'))<26u

auto KmpBuildTable(string s,int ocase)
	if !s.n:return [-1]
	next=new int[s.n+1]
	next[0]=-1
	for i=1:s.n
		i0=next[i-1]
		ch=s[i-1]
		while i0>=0:
			if s[i0]==ch||!ocase&&chrequi(s[i0],ch):
				break
			i0=next[i0]
		next[i]=i0+1
	for i=1:s.n-1
		x=next[i]
		while x>0&&(s[x]==s[i]||!ocase&&chrequi(s[x],s[i])):
			x=next[x]
		next[i]=x
	//use next[s.n] for match denial
	return next

auto SearchPlainText(CEditableText ed,i64 ccnt_starting,i64 ccnt_end,const direction, string s,int ocase,function(i64,i64):int ReportMatch, int budget)
	//use KMP: two-part is not worth it here
	sfind=(direction>0?s:[ch for ch in s.ReverseOrder()])
	if ocase:
		sfind2=sfind
	else
		sfind2=sfind.ToLower()
		sfind=sfind.ToUpper()
	lg=sfind.n
	fnext=KmpBuildTable(sfind,ocase)
	pbudget=budget
	w=0
	for ch,ccnt in direction>0?ed.enumCharsForward(ccnt_starting):ed.enumCharsBackward(ccnt_starting)
		if ccnt_end!=-1LL&&(direction>0?(ccnt>=ccnt_end):(ccnt<ccnt_end)):
			return -1LL
		for(;;)
			if ch==sfind[w]:break
			if ch==sfind2[w]:break
			w=fnext[w]
			if w<0:break
		w++
		if w>=lg:
			//got match
			if direction<0:
				ccnt0=ccnt
				ccnt1=ccnt+lg
			else
				ccnt1=ccnt+1
				ccnt0=ccnt1-lg
			pbudget-=ReportMatch(ccnt0,ccnt1)
			w=0
		pbudget--
		if pbudget<=0:
			//we are out of budget, exit
			return ccnt+w*i64(-direction)
	return -1LL

SEARCH_FLAG_CASE_SENSITIVE=1
SEARCH_FLAG_WHOLE_WORD=2
SEARCH_FLAG_REGEXP=4
SEARCH_FLAG_FUZZY=8
class CRegexpSearchContext
	int has6,has4
	i64 ccnt,ccnt_base
	RegexIncrementalMatcher matcher
	iptr[] match0
	__JS_prototype=function(JSObject proto){
		proto.ExportProperty(this,"ccnt")
	};

class CProgramWrapper
	TProgramItem[] prg
auto SearchRegexp(JSContext JS,CEditableText ed,i64 ccnt_end,const dir,string sregexp,int flags,function(i64,i64):int ReportMatch, int budget)
	//use the old regexp code - duk code too complicated
	ctx=JS.Param(1).as(CRegexpSearchContext)
	js_report_callback=JS.Param(6).as(JSObject)
	js_this=JS.Param(7).as(JSObject)
	match_cost=64
	if !js_report_callback:
		rjob=js_this["m_current_replace_job"].as(CReplaceJob)
		js_replace_callback=js_this["m_s_replace_callback"].as(JSObject)
		//js_doc=js_this["m_owner"].as(JSObject)
		match_cost=js_this["m_match_cost"].or(match_cost)
	else
		rjob=CReplaceJob.NULL
		js_replace_callback=JSObject.NULL
	native_replace_ctx=js_this["m_ae_ctx"].as(CReplaceContext)
	native_replace_prg=js_this["m_ae_prg"].as(CProgramWrapper)
	if !ctx:
		ccnt_starting=JS.Param(1).as(i64)
		//6:^, 4:$
		has6=0;has4=0
		se=sregexp
		if se.n&&se[0]=='^':
			se=se[1:]
			has6=1
		if se.n&&se.back()=='$':
			se=se[:se.n-2]
			has4=1
		if se=="":se="\"\""
		reo=ParseRegex(se)
		if !(flags&SEARCH_FLAG_CASE_SENSITIVE):reo=RegexMakeCaseInsensitive(reo)
		reo=RegexBracket(reo)
		if has6&&dir>0:
			reo=ParseRegex("\n")+reo
		if has4&&dir<0:
			reo=reo+ParseRegex("\r?\n")
		if dir<0:
			reo=reo+ParseRegex("[\\x00-\\xff]*?")
			regex=RegexReverse(reo)
		else
			reo=ParseRegex("[\\x00-\\xff]*?")+reo
			regex=new Regex(reo)
		matcher=regex.Matcher()
		ccnt_base=ccnt_starting
		if dir>0?has6:has4:
			matcher.Add('\n')
			ccnt_base-=dir
		match0=iptr[].NULL
		ctx=new CRegexpSearchContext(){
			matcher:matcher,
			has4:has4,has6:has6,
			ccnt:ccnt_starting,
			ccnt_base:ccnt_base,
			match0:match0
		}
	else
		matcher=ctx.matcher
		ccnt_starting=ctx.ccnt
		ccnt_base=ctx.ccnt_base
		has4=ctx.has4
		has6=ctx.has6
		match0=ctx.match0
	has_tail_enter=0
	if dir>0?has4:has6:
		has_tail_enter=1
	pbudget=budget
	//Writeln(!!matcher.ex.dfa)
	testMatch=function(int ch,i64 ccnt,iptr[] match){
		assert(match.n>=2)
		auto ccnt0=ccnt_base+dir*match[match.n-2]
		auto ccnt1=ccnt_base+dir*match[match.n-1]
		if dir<0:
			tmp=ccnt0;ccnt0=ccnt1;ccnt1=tmp
		auto match_is_invalid=0
		if ccnt0==ccnt1&&!has6&&!has4:
			//ignore zero-sized matches except when we have $/^
			match_is_invalid=1
		if !match_is_invalid&&(flags&SEARCH_FLAG_WHOLE_WORD):
			(ch0,ch1)=ed.GetUtf8CharNeighborhood(ccnt0)
			(ch0x,ch1x)=ed.GetUtf8CharNeighborhood(ccnt1)
			if isWordChar(ch0)==isWordChar(ch1)||isWordChar(ch0x)==isWordChar(ch1x):
				match_is_invalid=1
		if !match_is_invalid:
			(ch0,ch1)=ed.GetCharNeighborhood(ccnt0)
			if has6&&ch0!='\n':
				match_is_invalid=1
			(ch0,ch1)=ed.GetCharNeighborhood(ccnt1)
			if has4&&ch1!='\n'&&ch1!='\r':
				match_is_invalid=1
		if !match_is_invalid:
			if js_replace_callback:
				//match contains shit - the first pair includes .*
				assert(dir==1)
				js_replace_callback.PushAsFunction()
				JS._push_value(ed.GetText(ccnt0,ccnt1-ccnt0))
				for i=1:(match.n>>1)-2
					JS._push_value(ed.GetText(ccnt_base+i64(match[i*2]),i64(match[i*2]-match[i*2+1])))
				JS._push_value(ccnt0)
				//JS._push_value(js_doc)
				s_ret=JS.VCall(string,(match.n>>1))
				if s_ret:
					rjob.m_ops.push(TEditop(){ccnt:ccnt0,sz:ccnt1-ccnt0,s:s_ret})
				pbudget-=match_cost
			else if native_replace_prg:
				auto stext=ed.GetText(i64(ccnt0),i64(ccnt1-ccnt0))
				(s_unicode,nbras_old)=TextToAutoEditText(1,1,stext)
				auto utf8_utf32_map=new int[stext.n+1]
				auto pu=0
				foreach ch,I in Utf8Chars(stext)
					utf8_utf32_map[I]=pu
					pu++
				utf8_utf32_map[stext.n]=pu
				match_positions=[int(utf8_utf32_map[max(a-match[match.n-2],0L)]+1) for a in match[2:]]
				//Writeln(s_unicode,' ',match_positions)
				(s_replaced,errs,edhint0)=native_replace_ctx.ApplyReplaceProgram(
					native_replace_prg.prg,s_unicode,nbras_old,match_positions,0, 0)
				if s_replaced:
					rjob.m_ops.push(TEditop(){ccnt:ccnt0,sz:ccnt1-ccnt0,s:Unicode32ToUtf8(s_replaced)})
				pbudget-=match_cost
			else 
				pbudget-=ReportMatch(ccnt0,ccnt1)
		matcher.Clear()
		matcher.Add(char(ch))
		ccnt_base=ccnt+(dir<0)
		match0=matcher.GetMatch()
	}
	ccnt_final=(dir>0?ed.GetTextSize():-1LL)
	for ch,ccnt in dir>0?ed.enumCharsForward(ccnt_starting):ed.enumCharsBackward(ccnt_starting)
		if ccnt_end!=-1LL&&(dir>0?(ccnt>=ccnt_end):(ccnt<ccnt_end)):
			ccnt_final=ccnt
			break
		matcher.Add(char(ch))
		auto match=matcher.GetMatch()
		is_sliding=0
		if match0&&match&&(match0[match0.n-2]!=match[match.n-2]):
			is_sliding=1
			match=match0
		match0=match
		if (is_sliding||!matcher.is_matching())&&match:
			testMatch(int(u8(ch)),ccnt,match)
		////////////////////////
		pbudget-=16
		if pbudget<=0:
			//we are out of budget, exit
			ctx.match0=match0
			ctx.ccnt=ccnt+(dir>0)
			ctx.ccnt_base=ccnt_base
			return JS.Return(ctx)
	ch=(has_tail_enter?int('\n'):-1)
	if ch!=-1:matcher.Add(char(ch))
	match=matcher.GetMatch()
	is_sliding=0
	if match0&&match&&(match0[match.n-2]!=match[match.n-2]):
		is_sliding=1
		match=match0
	match0=match
	if (is_sliding||!matcher.is_matching()||ch==-1)&&match:
		testMatch(ch,ccnt_final,match)
	return JS.Return(-1LL)

class CFuzzySearchContext
	int[] chtab
	int[] dfa
	i64 ccnt,ccnt_base
	last_acode=9999
	last_match_ccnt0=0LL
	last_match_ccnt1=0LL
	st=0
	__JS_prototype=function(JSObject proto){
		proto.ExportProperty(this,"ccnt")
	};

inline absEncode(int a)
	return (a*2)^(a>>31)

inline absDecode(int a)
	return (a>>1)^-(a&1)
	
auto CreateFuzzyDFA(string s,int oword,int maxdist, int budget)
	struct TFrontier
		int pos
		int dist
		int dlength
	(TFrontier<TFrontier)=inline(a,b){
		return a.pos<b.pos||a.pos==b.pos&&(a.dist<b.dist||a.dist==b.dist&&absEncode(a.dlength)<absEncode(b.dlength))
	}
	//(TFrontier==TFrontier)=inline(a,b){
	//	return a.pos==b.pos
	//}
	if s.n<=1||maxdist>s.n-1||maxdist<1:
		ret=CFuzzySearchContext.NULL
	else
		//we may be limited to a distance of 2 - one bad char
		//but we could incorporate swap? swap is 2. it doesn't get along with others
		//(s.n+1)*(maxdist+1)
		chset=(new(s)).ConvertToAsBinary(u8)
		//always include " and ' as special chars
		chset.push(u8('"'))
		chset.push(u8('\''))
		chset.Sort()
		chset.Unique()
		chtab=[0 for i=0:256]
		if oword:
			foreach c,I in chset
				chtab[int(c)+1]=int(I+2)
			nc=int(chset.n+2)
		else
			foreach c,I in chset
				chtab[int(c)+1]=int(I+1)
			nc=int(chset.n+1)
		//do the NFA -> DFA deed
		state_id=new int[int[]]
		tran=new int[]
		Q=new TFrontier[]
		if !oword:
			//manual restart for whole-word states
			for i=0:maxdist
				Q.push(TFrontier(){pos:i,dist:i,dlength:-i})
			Q.Sort()
		ikey=Q[0:].ConvertToAsBinary(int)
		tran.resize(tran.n+nc);state_id[ikey]=int(tran.n)
		Q.push(TFrontier(){pos:0,dist:-1,dlength:0})
		fcur=new TFrontier[]
		fnext=new TFrontier[]
		advanced_by=[new int[] for i=0:nc-1]
		head=0L
		my_sid=nc
		ret=new CFuzzySearchContext(){chtab:chtab,dfa:tran}
		while head<Q.n&&ret:
			fcur.clear()
			fnext.clear()
			//n0=maxdist+1
			while Q[head].dist>=0:
				fcur.push(Q[head])
				head++
			head++
			//Writeln(head,' ',Q.n,' ',fcur)
			//there is SPL: increase one distance and one char
			//it's better to do SPL-out: avoiding duplicate ins
			//then it's just a matter of who's remaining -- everyone remaining advances by one and repopulates the deleters
			foreach ids in advanced_by
				ids.clear()
			//Writeln('>>>')
			foreach st,I in fcur
				ch8=int(u8(s[st.pos]))
				advanced_by[chtab[ch8+1]].push(int(I))
				//" ' rule
				if ch8=='"'||ch8=='\'':
					advanced_by[chtab[(ch8^('"'^'\''))+1]].push(int(I))
			//	Write(st.pos,' ')
			//Writeln()
			foreach ids,ch in advanced_by
				//we can always restart
				fnext.clear()
				if oword&&ch==1:
					//hack char for restartable point
					fnext.push(fcur)
				else
					//states advanced by ch
					foreach id in ids
						st=fcur[id]
						st.pos++
						fnext.push(st)
				if !(oword&&ch==1):
					//mistaken edit: advance pos regardless of the char
					//we go from fcur, NOT fnext!
					//foreach sti in fcur
					//	st=sti
					//	st.pos++
					//	st.dist++
					//	if st.dist<maxdist:
					//		fnext.push(st)
					//mistaken insertion: ignore the current character and just bump the dist
					//for(i=0;i<fnext.n;i++)
					//	st=fnext[i]
					foreach sti in fcur
						st=sti
						st.dlength++
						st.dist++
						if st.dist<=maxdist:
							fnext.push(st)
				//restart
				if !oword||oword&&ch==1:
					fnext.push(TFrontier(){pos:0})
				//avoid explosions
				fnext.Sort()
				fnext.UniqueBy(byMember("pos"))
				//mistaken deletion: ignore the current template character and bump pos/dist
				for(i=0;i<fnext.n;i++)
					st=fnext[i]
					st.pos++
					st.dlength--
					st.dist++
					if st.dist<=maxdist:
						fnext.push(st)
				fnext.Sort()
				fnext.UniqueBy(byMember("pos"))
				//remove acceptance, record the best one
				acc_code=0
				if fnext.n&&fnext.back().pos>=s.n:
					sacc=fnext.back()
					while fnext.n&&fnext.back().pos>=s.n:
						sacc=fnext.pop()
					acc_code=sacc.dist*(maxdist*2+1)+absEncode(sacc.dlength)+1
					if oword&&ch==1:
						//assert(0)
						//this could happen: when restarting from an originally-accepting state
						acc_code=0
				ikey=fnext[0:].ConvertToAsBinary(int)
				sid=state_id[ikey]
				if !sid:
					if tran.n+nc>budget:
						ret=CFuzzySearchContext.NULL
						break
					tran.resize(tran.n+nc);state_id[ikey]=int(tran.n)
					sid=int(tran.n)
					//Writeln(sid,' ',ikey)
					Q.push(fnext)
					Q.push(TFrontier(){pos:0,dist:-1,dlength:0})
				ikey.discard()
				//ch -> sid, my sid
				tran[my_sid-nc+ch]=int(sid-nc+((acc_code)<<24))
			my_sid+=nc
	return ret

FUZZY_DFA_BUDGET=131072//65536
auto SearchFuzzy(JSContext JS,CEditableText ed,i64 ccnt_end,const dir,string s,int flags,function(i64,i64):int ReportMatch, int budget)
	assert(ccnt_end==-1LL)
	ctx=JS.Param(1).as(CFuzzySearchContext)
	maxdist=int(max(min((s.n-2)/3+1,3),1))
	if !ctx:
		if !(flags&SEARCH_FLAG_CASE_SENSITIVE):
			scased=s.ToLower()
		else
			scased=s
		if dir<0:
			scased=[ch foreach ch in scased.ReverseOrder()]
		//Writeln(s,' ',scased)
		ctx=CreateFuzzyDFA(scased,!!(flags&SEARCH_FLAG_WHOLE_WORD),maxdist, FUZZY_DFA_BUDGET)
		if !ctx:
			return JS.Return(-1LL)
		ctx.ccnt=JS.Param(1).as(i64)
	chtab=ctx.chtab
	tran=ctx.dfa
	ccnt_starting=ctx.ccnt
	last_acode=ctx.last_acode
	last_match_ccnt0=ctx.last_match_ccnt0
	last_match_ccnt1=ctx.last_match_ccnt1
	st=ctx.st
	(ch0,ch1)=ed.GetCharNeighborhood(ccnt_starting)
	isa0=isWordChar(dir>0?ch0:ch1)
	is_done=1
	pbudget=budget
	foreach ch0,ccnt in dir>0?ed.enumCharsForward(ccnt_starting):ed.enumCharsBackward(ccnt_starting)
		//Writeln('>>> ',ccnt,' ',dir)
		ch=int(u8(ch0))
		//if ch==-1:continue
		if !(flags&SEARCH_FLAG_CASE_SENSITIVE):
			if u32(ch-int('A'))<26u:
				ch+=0x20
		pbudget--
		if pbudget<=0:
			ccnt_starting=ccnt+(dir<0)
			is_done=0
			break
		if flags&SEARCH_FLAG_WHOLE_WORD:
			isa1=isWordChar(ch)
			if !isa0||!isa1:
				//manual restart at word boundary
				st=tran[st+1]
			isa0=isa1
		chid=chtab[ch+1]
		st=tran[st+chid]
		if st&0xff000000:
			//accepted
			acode=(st>>24)-1
			dlg=absDecode(acode%(2*maxdist+1))
			st&=0xffffff
			//word boundary test
			if flags&SEARCH_FLAG_WHOLE_WORD:
				(nch0,nch1)=ed.GetUtf8CharNeighborhood(ccnt)
				if isWordChar(nch0)==isWordChar(nch1):continue
			lgmatch=s.n+dlg
			//Writeln(ccnt-lgmatch,' ',ccnt_stop_at)
			//if ccnt+1-lgmatch>=ccnt_stop_at:
			//	break
			if (dir>0?(ccnt+1-lgmatch<last_match_ccnt1):(ccnt-1+lgmatch>last_match_ccnt1)):
				//there's overlap
				if last_acode>acode:
					last_acode=acode
					if dir>0:
						last_match_ccnt0=ccnt+1-lgmatch
						last_match_ccnt1=ccnt+1
					else
						last_match_ccnt0=ccnt+lgmatch
						last_match_ccnt1=ccnt
			else
				if last_acode<9999:
					if dir<0:
						pbudget-=ReportMatch(last_match_ccnt1,last_match_ccnt0)*16
					else
						pbudget-=ReportMatch(last_match_ccnt0,last_match_ccnt1)*16
				last_acode=acode
				if dir>0:
					last_match_ccnt0=ccnt+1-lgmatch
					last_match_ccnt1=ccnt+1
				else
					last_match_ccnt0=ccnt+lgmatch
					last_match_ccnt1=ccnt
	//Writeln('fuzzy search! ',is_done,' ',ccnt_starting,' ',dir)
	ret=0
	if is_done:
		if last_acode<9999:
			if dir<0:
				ReportMatch(last_match_ccnt1,last_match_ccnt0)
			else
				ReportMatch(last_match_ccnt0,last_match_ccnt1)
		ctx.ccnt=-1LL
		ret=JS.Return(-1)
	else
		ctx.ccnt=ccnt_starting
		ctx.last_acode=last_acode
		ctx.last_match_ccnt0=last_match_ccnt0
		ctx.last_match_ccnt1=last_match_ccnt1
		ctx.st=st
		ret=JS.Return(ctx)
	//}}
	//Writeln(last_acode,' ',last_match_ccnt0,' ',last_match_ccnt1)
	return ret

///////////////////////////////////////////
class CReplaceJob
	m_ops=new TEditop[]
	string m_s_replace
	m_match_cost=64
	m_direction=1
	JS_GetLastMatch=function(JSContext JS){
		if !m_ops.n:return 0
		delta=0LL
		if m_direction<0:
			op=m_ops[0]
		else
			op=m_ops[m_ops.n-1]
			for i=0:m_ops.n-2
				delta+=m_ops[i].s.n-m_ops[i].sz
		ret=JS.New()
		ret[0]=delta+op.ccnt
		ret[1]=delta+op.ccnt+op.s.n
		return JS.Return(ret)
	}
	__JS_prototype=function(JSObject proto){
		proto.ExportMethod(this,"GetLastMatch",JS_GetLastMatch)
	}

inline isSpaceOrNewline(int ch)
	return u32(ch-9)<=4u||ch==32||ch==160||ch==5760||u32(ch-8192)<=10u||ch==8239||ch==8287||ch==12288
	
//this just returns a list of ccnts indicating the ccnt range for each "line" (if they are similar enough)
//everything works within stext
AUTO_EDIT_SIMILARITY_THRESHOLD=0.3f
AUTO_EDIT_SIMILARITY_THRESHOLD_TWOGROUPER=0.5f
AUTO_EDIT_SIMILARITY_THRESHOLD_MULTILINE_PERIOD=0.7f
AUTO_EDIT_SIMILARITY_THRESHOLD_SYM=0.5f
AUTO_EDIT_SIMILARITY_THRESHOLD_SYM_TWOGROUPER=0.6f
AUTO_EDIT_SIMILARITY_THRESHOLD_SYM_MULTILINE_PERIOD=0.8f
AUTO_EDIT_MAX_LINE_LENGTH=400
AUTO_EDIT_MAX_TOTAL_LENGTH=20480
AUTO_EDIT_MAX_NLINES=256
AUTO_EDIT_MIN_LINE_LENGTH=5
auto AutoEdit_Detect(string stext,iptr ccnt_middle)
	cur_gapprg=int[].NULL
	cclines=iptr[].NULL
	best_covered_sym=0
	best_total_sym=0
	best_covered_alnum=0
	best_total_alnum=0
	best=0
	bnl=0
	best_gapprg=int[].NULL
	nl=0
	is_completely_equal=0
	test_sameline_fix=0
	fisalnum=TextBox.detail.isWordChar
	line_seps=[i for i=0:stext.n if !i||stext[i-1]=='\n']
	pl_middle=line_seps.Bisect(function(iptr ccnt_i){return ccnt_i<=ccnt_middle})-1
	if pl_middle<0:
		pl_middle=0
	else if pl_middle>=line_seps.n:
		pl_middle=line_seps.n-1
	auto ComputeOptimalGapProgram(string stext,int delta_line)
		nsstd=0
		//min_covered=0
		sum_total_sym=0
		sum_total_alnum=0
		//foreach sline,cc0,cc1 in stext.Tokenize("\n")
		cclines=new iptr[]
		for(line_i=0;;line_i+=delta_line)
			nl++
			if nl>AUTO_EDIT_MAX_NLINES:break
			if pl_middle+line_i+delta_line>=line_seps.n:
				nl--
				break
			cc0=line_seps[pl_middle+line_i]
			cc1=line_seps[pl_middle+line_i+delta_line]-1
			sline=stext[cc0:cc1-1]
			uline=Utf8ToUnicode32(sline)
			if !uline.n:
				nl--
				break
			if uline.n>AUTO_EDIT_MAX_LINE_LENGTH:
				nl--
				break
			//Writeln(side,' ',pl_middle,' ',line_i,'>> ',sline)
			if !cur_gapprg:
				cur_gapprg=uline
				(wt_sym,wt_alnum)=SF.ComputeWeightForString(uline,fisalnum)
				sum_total_sym=wt_sym
				sum_total_alnum=wt_alnum
				cclines.push(cc0)
				cclines.push(cc1)
				bnl=2//avoid resize failure
				//min_covered=wt
			else
				ns0=0
				for i=0:cur_gapprg.n-1
					if isSpaceOrNewline(cur_gapprg[i]):
						ns0++
					else
						break
				ns1=0
				for i=0:uline.n-1
					if isSpaceOrNewline(uline[i]):
						ns1++
					else
						break
				if ns0!=ns1||cur_gapprg[:ns1-1]!=uline[:ns1-1]:
					//Writeln('break: ',ns0,' ',ns1,' ',cur_gapprg[:ns1-1],' ',uline[:ns1-1])
					nl--
					break
				nsstd=ns0
				if nl==2&&uline==cur_gapprg:
					is_completely_equal=1
				(cur_gapprg,wgt,wt_covered_sym,wt_total_sym,wt_covered_alnum,wt_total_alnum)=SF.WeightedGapMerge(cur_gapprg,uline,fisalnum)
				wgt++//dodge the warning
				//Writeln(side,' ',line_i,'>> ',wt_covered_alnum,' ',wt_total_alnum,' ',cur_gapprg)
				//min_covered=min(min_covered,wt_covered)
				sum_total_sym+=wt_total_sym
				sum_total_alnum+=wt_total_alnum
				//dmp_prg0=new string[]
				//dmp_sprg=new string
				//foreach ch in cur_gapprg
				//	if ch<0:
				//		if !dmp_prg0.n||dmp_sprg.n:
				//			dmp_prg0.push(dmp_sprg)
				//			dmp_sprg=new string
				//	else
				//		dmp_sprg.push(Unicode32ToUtf8([ch]))
				//dmp_prg0.push(dmp_sprg)
				//Writeln(wgt*nl>best?"(BEST) ":"",nl,' ',wgt,' ',dmp_prg0)
				//percentage_sym=f32(wt_covered_sym*nl)/f32(sum_total_sym+1)
				//percentage_alnum=f32(wt_covered_alnum*nl)/f32(sum_total_alnum+1)
				//use valid percentage + area best
				//if wgt*nl>best:
				//if !best||wt_covered_alnum&&percentage_sym>=AUTO_EDIT_SIMILARITY_THRESHOLD_SYM&&percentage_alnum>=AUTO_EDIT_SIMILARITY_THRESHOLD:
				//	if !(cur_gapprg.n&&cur_gapprg[0]==-1&&cur_gapprg.back()==-1):
				if !best||_isGapProgramOK(cur_gapprg,wt_covered_sym*nl,sum_total_sym, wt_covered_alnum*nl,sum_total_alnum,delta_line):
					if wgt*nl>best:
						best=wgt*nl
						//best=percentage
						bnl=cclines.n+2
						best_gapprg=cur_gapprg
						best_covered_sym=wt_covered_sym*nl
						best_covered_alnum=wt_covered_alnum*nl
						best_total_sym=sum_total_sym
						best_total_alnum=sum_total_alnum
				//if f32(wt_covered_sym*AUTO_EDIT_MAX_NLINES)/f32(sum_total_sym+1)<AUTO_EDIT_SIMILARITY_THRESHOLD_SYM:
				//	break
				cclines.push(cc0)
				cclines.push(cc1)
				if wgt*AUTO_EDIT_MAX_NLINES<=best:
					break
		//Writeln(side,' ',best,' ',bnl,' ',cclines.n)
		cclines.resize(bnl)
		return nsstd
	inline _isGapProgramOK(int[] best_gapprg,int best_covered_sym,int best_total_sym,int best_covered_alnum,int best_total_alnum,int delta_line)
		if best_gapprg.n&&best_gapprg[0]==-1&&best_gapprg.back()==-1:
			return 0
		//don't auto-edit empty lines
		if !best_covered_alnum:return 0
		//Writeln(best_covered_sym,' ',best_total_sym)
		//Writeln(best_covered_alnum,' ',best_total_alnum)
		auto threshold=AUTO_EDIT_SIMILARITY_THRESHOLD
		auto threshold_sym=AUTO_EDIT_SIMILARITY_THRESHOLD_SYM
		if delta_line>1:
			threshold=AUTO_EDIT_SIMILARITY_THRESHOLD_MULTILINE_PERIOD
			threshold_sym=AUTO_EDIT_SIMILARITY_THRESHOLD_SYM_MULTILINE_PERIOD
		else
			if bnl<=2:
				threshold=AUTO_EDIT_SIMILARITY_THRESHOLD_TWOGROUPER
				threshold_sym=AUTO_EDIT_SIMILARITY_THRESHOLD_SYM_TWOGROUPER
		if f32(best_covered_sym)<f32(best_total_sym)*threshold_sym:
			return 0
		if f32(best_covered_alnum)<f32(best_total_alnum)*threshold:
			return 0
		return 1
	inline isGapProgramOK(int delta_line)
		return _isGapProgramOK(best_gapprg,best_covered_sym,best_total_sym,best_covered_alnum,best_total_alnum,delta_line)
	//smartedit test
	//ccnt_tot=.doc.l00.TotalCcnt()
	//stext=.doc.GetText(ccnt_lh0,min(ccnt_tot-ccnt_lh0,AUTO_EDIT_MAX_TOTAL_LENGTH))
	//plastline=stext.LastIndexOf('\n')
	//stext.resize(plastline+1)
	//test 2/3 lines too
	for delta_line=1:3
		cur_gapprg=int[].NULL
		cclines=iptr[].NULL
		best_covered_sym=0
		best_total_sym=0
		best_covered_alnum=0
		best_total_alnum=0
		best=0
		bnl=0
		best_gapprg=int[].NULL
		nl=0
		is_completely_equal=0
		test_sameline_fix=0
		/////////////
		nsstd=ComputeOptimalGapProgram(stext,delta_line)
		//if is_completely_equal:test_sameline_fix=1
		if !best_gapprg||bnl<2:
			continue
		nsegs=1
		foreach ch in best_gapprg
			if ch==-1:
				nsegs++
		if !isGapProgramOK(delta_line):
			continue
		//Writeln(Unicode32ToUtf8([ch<0?0x2026:ch foreach ch in best_gapprg]))
		//for i=0:2:cclines.n-2
		//	cc0=cclines[i]
		//	cc1=cclines[i+1]
		//	sline=stext[cc0:cc1-1]
		//	Writeln(i>>1,'>>> ',sline)
		return cclines
	return iptr[].NULL

auto TextToAutoEditText(int is_bof,int is_eof,string stext)
	nbra=0
	s_unicode=new int[]
	nbras=new int[]
	if is_bof:
		s_unicode.push(int('\n'))
		nbras.push(nbra)
	foreach ch,I in Utf8Chars(stext)
		s_unicode.push(ch)
		nbras.push(nbra)
		if ch=='('||ch=='['||ch=='{':
			nbra++
		else if ch==')'||ch==']'||ch=='}':
			nbra--
	if is_eof:
		s_unicode.push(int('\n'))
		nbras.push(nbra)
	return (s_unicode,nbras)

auto AutoEdit_Precompute(string stext0,iptr[] cclines)
	auto AutoEdit_GetText(iptr _ccnt0,iptr _ccnt1)
		auto ccnt0=_ccnt0
		auto ccnt1=_ccnt1
		auto is_bof=0
		auto is_eof=0
		if ccnt0>0:
			ccnt0--
		else
			is_bof=1
		if ccnt1<stext0.n:
			ccnt1++
		else
			is_eof=1
		stext=stext0[ccnt0:ccnt1-1]
		return TextToAutoEditText(is_bof,is_eof,stext)
	if !cclines.n:return CReplaceContext.NULL
	assert(cclines.n%2==0)
	inputs=new TReplaceInput[]
	for i=0:2:cclines.n-2
		ccnt0=cclines[i]
		ccnt1=cclines[i+1]
		(s_unicode,nbras)=AutoEdit_GetText(ccnt0,ccnt1)
		//Writeln('<<<',s_unicode,'>>>')
		inputs.push(TReplaceInput(){s_unicode:s_unicode,nbras:nbras})
	return SF.CreateReplaceInstance(inputs)

auto AutoEdit_SingleExamplePrecompute(string stext,int[] match_positions)
	(s_unicode,nbras)=TextToAutoEditText(1,1,stext)
	return SF.CreateReplaceInstance([TReplaceInput(){
		s_unicode:s_unicode,nbras:nbras,
		match_positions:match_positions,
	}])

auto AutoEdit_SetExample(CReplaceContext ctx,int input_id,string s_new)
	return ctx.SetReplaceExample(
		input_id,Utf8ToUnicode32(s_new),
		function(int a){return isWordChar(a)})

auto ProcessEditDistance(TProgramMatch[] matches,int[] ssrc,int[] sret)
	ccntmap=new int[ssrc.n]
	c=0
	for i=1:ssrc.n-1
		ccntmap[i]=c
		c+=Utf8Length(ssrc[i])
	ret=new TEditop[]
	psrc=1L
	ptar=0L
	foreach pm in matches
		op=TEditop(){ccnt:ccntmap[psrc]}
		if pm.pm0>psrc:
			ret.push(TEditop(){ccnt:ccntmap[psrc],sz:ccntmap[pm.pm0]-ccntmap[psrc]})
		psrc=pm.pm0
		if pm.pret>ptar:
			ret.push(TEditop(){ccnt:ccntmap[psrc],s:Unicode32ToUtf8(sret[ptar:pm.pret-1])})
		ptar=pm.pret+pm.pm1-pm.pm0
		psrc=pm.pm1
	if ssrc.n-1>psrc:
		ret.push(TEditop(){ccnt:ccntmap[psrc],sz:ccntmap[ssrc.n-1]-ccntmap[psrc]})
		psrc=ssrc.n-1
	if sret.n>ptar:
		ret.push(TEditop(){ccnt:ccntmap[psrc],s:Unicode32ToUtf8(sret[ptar:])})
	return ret

auto RawEditDistance(int[] su0,int[] su1, int ocase)//(string ss0,string ss1)
	MAX_DIST=4
	n0=su0.n
	n1=su1.n
	//last op: copy 01 / delete 0 / insert 1
	struct TState
		int best
		int op_from
	st=new TState[(n0+1)*(n1+1)]
	st[0].op_from=1
	inline stateid(iptr a,iptr b)
		return (b*(n0+1)+a)
	//del_cost=[COST_BASE+COST_CHAR,COST_CHAR,COST_BASE+COST_CHAR]
	//ins_cost=[COST_BASE+COST_CHAR,COST_BASE+COST_CHAR,COST_CHAR]
	//cpy_cost=[0,0,0]
	for j=0:n1
		for i=max(!j,j-MAX_DIST):min(n0,j+MAX_DIST)
			best=0
			bestop=-1
			//delete
			if i>0:
				sid0=stateid(i-1,j)
				if st[sid0].op_from>0:
					cost=st[sid0].best+1
					if bestop<0||best>cost:
						best=cost
						bestop=1
			//insert
			if j>0:
				sid0=stateid(i,j-1)
				if st[sid0].op_from>0:
					cost=st[sid0].best+1
					if bestop<0||best>cost:
						best=cost
						bestop=2
			//cpy
			if i>0&&j>0&&(su0[i-1]==su1[j-1]||!ocase&&chrequi(su0[i-1],su1[j-1])):
				sid0=stateid(i-1,j-1)
				if st[sid0].op_from>0:
					cost=st[sid0].best
					if bestop<0||best>cost:
						best=cost
						bestop=0
			sid=stateid(i,j)
			st[sid].best=best
			st[sid].op_from=bestop+1
	sid=stateid(n0,n1)
	pi=n0
	pj=n1
	cc=0
	op=-1
	raw_ret=new int4[]
	while pi||pj:
		sid=stateid(pi,pj)
		op0=st[sid].op_from-1
		if op0!=op:
			//we're at a boundary, record one item
			if cc:raw_ret.push(int4(int(pi),int(pj),int(cc),op))
			cc=0
		if op0<0:
			break
		op=op0
		pi0=pi
		pj0=pj
		if op==0:
			//copy
			pi0--
			pj0--
		else if op==1:
			pi0--
		else
			assert(op==2)
			pj0--
		cc++
		pi=pi0
		pj=pj0
	if cc:raw_ret.push(int4(int(pi),int(pj),int(cc),op))
	cc=0
	///
	ccnt_tran=new int[]
	c=0
	ccnt_tran.push(c)
	for i=0:n0-1
		c+=Utf8Length(su0[i])
		ccnt_tran.push(c)
	ret=new TEditop[]
	foreach rawitem in raw_ret.ReverseOrder()
		if rawitem.w==1:
			//delete
			ret.push(TEditop(){ccnt:ccnt_tran[rawitem[0]],sz:ccnt_tran[rawitem[0]+rawitem[2]]-ccnt_tran[rawitem[0]]})
		else if rawitem.w==2:
			//delete
			ret.push(TEditop(){ccnt:ccnt_tran[rawitem[0]],s:Unicode32ToUtf8(su1[rawitem[1]:rawitem[1]+rawitem[2]-1])})
	return ret

auto AutoEdit_Evaluate(TEditop[] ops,i64 ccnt_base, CReplaceContext ctx, TProgramItem[] prg, int line_id,int[] s_unicode,int[] nbras_old)
	//just return the edit ops?
	(s_replaced,errs,edhint0)=ctx.ApplyReplaceProgram(prg,s_unicode,nbras_old,int[].NULL,line_id, 1)
	if errs&&errs.n:
		return 0
	edhint=ProcessEditDistance(edhint0, s_unicode, s_replaced)
	foreach op in edhint
		op2=op
		op2.ccnt+=ccnt_base
		ops.push(op2)
	return 1

class CDiffBitmap
	u8[] data

class CRichTextImage
	GLuint texid
	int[] cpu_data
	int w,h
	auto GetTexture()
		if !texid:
			texid=glCreateTexture(GL_RGBA8,w,h, GL_LINEAR,GL_CLAMP_TO_EDGE,GL_CLAMP_TO_EDGE,__pointer(cpu_data.d))
			glBindTexture(GL_TEXTURE_2D,texid)
			glGenerateMipmap(GL_TEXTURE_2D)
			glBindTexture(GL_TEXTURE_2D,0u)
			cpu_data.discard()
			cpu_data=int[].NULL
		return texid
	auto __done__()
		if texid:
			ptexid=[texid]
			glDeleteTextures(1,__pointer(ptexid.d))
			texid=0u

g_richtext_img_tech=GLTechnique.NULL
auto RenderRichTextObject(JSContext JS,float x0,float y0,float w0,JSObject objs,int oid)
	auto x=x0
	auto y=y0
	auto w=w0
	auto obj_help_page=JS["UI"]["default_styles"]["help_page"].as(JSObject)
	obj_i=objs[oid].as(CEmbededObject).content
	stype=obj_i["m_type"].as(string)
	if stype=="hr":
		auto h_hr=obj_help_page["hr_h"].as(float)
		auto h_hr_fill=obj_help_page["hr_h_fill"].as(float)
		auto C_hr_fill=obj_help_page["hr_color"].as(int)
		g_renderer.DrawRectangle(x,y+(h_hr-h_hr_fill)*0.5f,w,h_hr_fill,C_hr_fill)
	else if stype=="img":
		img=obj_i["m_tex"].as(CRichTextImage)
		ui_scale=g_renderer.m_pixels_per_unit
		w_render=min(float(img.w),obj_help_page["w_max_img_width_percentage"].as(float)*w)*ui_scale
		h_render=float(img.h)/float(img.w)*w_render
		///////////
		//clipping
		u0=0.f
		v0=0.f
		cu=1.f
		cv=1.f
		clipped=0
		x=x0;y=y0;
		auto w=w_render
		auto h=h_render
		m_clip=Gui2D.detail.g_renderer.m_clip
		if x<m_clip.x:
			dx=m_clip.x-x
			t=dx/w
			x=m_clip.x;w-=dx
			du=cu*t
			u0+=du;cu-=du
		if m_clip.z<x+w:
			dx=m_clip.z-x
			t=dx/w
			w=dx
			cu*=t
		//use negated tests against NaN
		if !(cu>0.f)||!(x+w>x):return
		if y<m_clip.y:
			dy=m_clip.y-y
			t=dy/h
			y=m_clip.y;h-=dy
			dv=cv*t
			v0+=dv;cv-=dv
			clipped=1
		if m_clip.w<y+h:
			dy=m_clip.w-y
			t=dy/h
			h=dy
			cv*=t
			clipped=1
		if !(cv>0.f)||!(y+h>y):return
		///////////
		g_renderer.InsertNativeDrawCall(function(){
			auto texid=img.GetTexture()
			if !g_richtext_img_tech:
				g_richtext_img_tech=new GLTechnique
				g_richtext_img_tech.SetVarying("vec2 uv")
				g_richtext_img_tech.SetVertexShader("
					void main(){
						vec2 P_scr=P*scale;
						uv=uv_vert;
						gl_Position=vec4(P_scr.x-1.0,1.0-P_scr.y,1.0,1.0);
					}")
				if g_renderer.m_srgb_supported:
					g_richtext_img_tech.SetFragmentShader("void main(){
						vec4 C=texture2D(tex0,uv);
						C=vec4(pow(C.xyz,vec3("+formatNumber(g_renderer.m_gamma,{frac:7})+")),C.w);
						gl_FragColor=C;
					}")
				else
					g_richtext_img_tech.SetFragmentShader("void main(){gl_FragColor=texture2D(tex0,uv);}")
			vbo=g_renderer.UploadMiniVBO([
				__float_as_int((x)),__float_as_int((y)),
				__float_as_int((x+w)),__float_as_int((y)),
				__float_as_int((x+w)),__float_as_int((y+h)),
				__float_as_int((x)),__float_as_int((y+h)),
				__float_as_int(u0),__float_as_int(v0),
				__float_as_int(u0+cu),__float_as_int(v0),
				__float_as_int(u0+cu),__float_as_int(v0+cv),
				__float_as_int(u0),__float_as_int(v0+cv)])
			g_richtext_img_tech.SetVertexPointer("P", 2,GL_FLOAT,0, 2*sizeof(int),0L)
			g_richtext_img_tech.SetVertexPointer("uv_vert", 2,GL_FLOAT,0, 2*sizeof(int),0L+8*sizeof(float))
			prev_viewport=new int[4]
			glGetIntegerv(GL_VIEWPORT,__pointer(prev_viewport.d));
			//Writeln('render: ',x,' ',y,' ',w_render,' ',h_render)
			g_richtext_img_tech.SetUniform("scale",float2(2.f/f32(prev_viewport[2]),2.f/f32(prev_viewport[3])))
			g_richtext_img_tech.SetTexture2D("tex0",texid);
			g_richtext_img_tech.Draw(vbo,GL_TRIANGLE_FAN,4)
		})
	else if stype=="pre":
		JS["UI"].CallMethod(int,"RenderEmbededCodeBox",
			x/g_renderer.m_pixels_per_unit,
			y/g_renderer.m_pixels_per_unit,
			obj_i)
	else if stype=="qtag":
		JS["UI"].CallMethod(int,"RenderQTagReference",
			x/g_renderer.m_pixels_per_unit,
			y/g_renderer.m_pixels_per_unit,
			obj_i)

auto ReplaceFile(string fntar,string fnsrc)
	if !System.IO.FileExists(fntar):
		return System.IO.MoveFile(fnsrc,fntar)
	if Platform.IS_WINDOWS:
		WinReplaceFile=__c_function(int,"ReplaceFileW","windows.h")
		fntaru=System.detail.toNativeString(fntar.Replace(["/","\\"]))
		fnsrcu=System.detail.toNativeString(fnsrc.Replace(["/","\\"]))
		return WinReplaceFile(fntaru,fnsrcu,NULL,0,NULL,NULL)
	else if Platform.IS_UNIX:
		UnixMatchFileAttributes=__c_function(int,"UnixMatchFileAttributes","c_helper.h","c_files","c_helper.c")
		fntaru=System.detail.toNativeString(fntar)
		fnsrcu=System.detail.toNativeString(fnsrc)
		if !UnixMatchFileAttributes(fntaru,fnsrcu):return 0
		if !System.IO.DeleteFile(fntar):return 0
		if !System.IO.MoveFile(fnsrc,fntar):return 0
		return 1
	else
		assert(0)
		if !System.IO.DeleteFile(fntar):return 0
		if !System.IO.MoveFile(fnsrc,fntar):return 0
		return 1

isWesternLetter=inline(ch){
	chi=int(u8(ch))
	return chi>=0x80||isWordChar(chi)
}

CASE_UNKNOWN=0
CASE_ALL_LOWER=1
CASE_ALL_UPPER=2
CASE_LEADING_CAPITAL=3
MAX_CASE_ASSESSABLE=256
AssessCase=function(string s){
	if s.n>=MAX_CASE_ASSESSABLE:return 0
	flags=0
	//1: lower, 2: upper, 4: other
	//*1: first, *8: after that
	flag_shift=0
	for ch in Utf8Chars(s)
		if ch>='a'&&ch<='z':
			flags|=1<<flag_shift
			flag_shift=3
		else if ch>='A'&&ch<='Z':
			flags|=2<<flag_shift
			flag_shift=3
		else
			flags|=4<<flag_shift
	switch(flags&(3*8+3)){
	case 1,9:
		return CASE_ALL_LOWER
	case 2,18:
		return CASE_ALL_UPPER
	case 10:
		return CASE_LEADING_CAPITAL
	default:
		return CASE_UNKNOWN
	}
}

ApplyCase=function(string s,int case_id){
	switch case_id:{
	case CASE_ALL_LOWER:
		return s.ToLower()
	case CASE_ALL_UPPER:
		return s.ToUpper()
	case CASE_LEADING_CAPITAL:
		s1=s.ToLower()
		for i=0:s1.n-1
			if s1[i]>='a'&&s1[i]<='z':
				s1[i]-=0x20
				break
		return s1
	default:
		return s
	}
}

//g_rtt_tab_backup=CJSGLRenderToTextureContext.NULL
registerUIExtension(function(JSObject JS_UI,CUISandbox sbox,int is_real){
	JS_UI["EDLoader_Open"]=function(JSContext JS){
		//initial read, which is a raw edit
		ed=JS.Param(0).as(CEditableText)
		params=JS.Param(1).as(JSObject)
		fn=params["file_name"].or(new string)
		szread=params["read_batch"].or(INITIAL_READ_SIZE)
		offset0=params["offset0"].or(0LL)
		offset1=params["offset1"].or(-1LL)
		hf=System.IO.OpenFile(fn)
		if !hf:return 0
		if offset0:
			hf.Seek(iptr(offset0))
		szread_real=int(min(u64(offset1-offset0),u64(szread)))
		s=hf.Read(szread_real)
		szread_returned=s.n
		if s.n:
			//encoding detection
			encoding=DetectEncoding(s)
			if encoding!=ENCODING_UTF8&&encoding!=ENCODING_INVALID:
				fwarning=params["OnEncodingDetected"].as(JSObject)
				fwarning.Call(int,encoding)
			(s_utf8,s_lingering)=ConvertToUTF8(encoding,s)
			if s_utf8.n:
				ed.LoaderEdit([TEditop(){s:s_utf8}])
		else
			s_utf8=string.NULL
			s_lingering=string.NULL
		if szread_returned<szread_real:
			if s_lingering&&s_lingering.n:
				ed.LoaderEdit([TEditop(){ccnt:ed.GetTextSize(),s:s_lingering}])
			hf.Close()
			return JS.Return(0)
		ret=new CLoadingContext
		ret.encoding=encoding
		ret.sz=i64(min(u64(System.IO.GetFileSize(fn)-offset0),u64(offset1-offset0)))
		ret.sz_read=szread_returned
		ret.s_lingering=s_lingering
		//ret.fn=fn
		ret.hf=hf
		ret.progress=float(min(double(hf.Position())/double(max(ret.sz,1LL)),1.0))
		return JS.Return(ret)
	}
	JS_UI["EDLoader_Read"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		ret=JS.Param(1).as(CLoadingContext)
		szread=iptr(min(JS.Param(2).or(NEXT_READ_SIZE),ret.sz-ret.sz_read))
		hf=ret.hf
		//if ret.s_lingering:
		//	ed.LoaderEdit([TEditop(){ccnt:ed.GetTextSize(),s:ret.s_lingering}])
		//	ret.s_lingering=string.NULL
		//after encoding
		s=hf.Read(szread)
		n_read=s.n
		if ret.s_lingering:
			s=ret.s_lingering+s
			ret.s_lingering=string.NULL
		(s_utf8,s_lingering)=ConvertToUTF8(ret.encoding,s)
		ret.s_lingering=s_lingering
		ret.sz_read+=n_read
		if s_utf8.n:
			ed.LoaderEdit([TEditop(){ccnt:ed.GetTextSize(),s:s_utf8}])
		if ret.sz_read>=ret.sz||!n_read:
			if ret.s_lingering:
				ed.LoaderEdit([TEditop(){ccnt:ed.GetTextSize(),s:ret.s_lingering}])
				ret.s_lingering=string.NULL
			hf.Close()
			return JS.Return(0)
		ret.progress=float(min(double(hf.Position())/double(max(ret.sz,1LL)),1.0))
		return JS.Return(ret)
	}
	JS_UI["EDSaver_Open"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		fn=JS.Param(1).or(new string)
		ret=new CSavingContext
		ret.fn=fn
		ret.hf=System.IO.CreateFile(fn+".$$$")
		if !ret.hf:return 0
		return JS.Return(ret)
	}
	JS_UI["EDSaver_Write"]=function(JSContext JS){
		ret=JS.Param(0).as(CSavingContext)
		ed=JS.Param(1).as(CEditableText)
		ofs=ret.ofs
		szmax=ed.GetTextSize()
		szwrite=int(min(szmax-ofs,i64(WRITE_BATCH)))
		if szwrite>0:
			s=ed.GetText(ofs,i64(szwrite))
			if ret.hf.Write(s)<s.n:
				return JS.Return("failed")
		ret.ofs+=i64(szwrite)
		if ret.ofs>=szmax:
			ret.hf.Close()
			if !ReplaceFile(ret.fn,ret.fn+".$$$"):
				return JS.Return("failed")
			else
				return JS.Return("done")
		ret.progress=f32(ret.ofs)/f32(szmax)
		return JS.Return("continue")
	}
	/**
	\brief Native function to search in a document
	\param js_callback is the JS-side per-match callback, if it's NULL, it's interpreted as a replace request and a "replace job" is constructed in js_this
	\param js_this holds the replace request in the replace mode
	*/
	JS_UI["ED_Search"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		direction=JS.Param(2).or(1)
		s=JS.Param(3).as(string)
		flags=JS.Param(4).as(int)
		budget=JS.Param(5).as(int)
		js_callback=JS.Param(6).as(JSObject)
		js_this=JS.Param(7).as(JSObject)
		/////////////
		range_ccnt0=-1LL
		range_ccnt1=-1LL
		if !js_callback:
			//need a context for m_match_cost and stuff
			range_ccnt0=js_this["m_ccnt0"].as(i64)
			range_ccnt1=js_this["m_ccnt1"].as(i64)
			rjob=js_this["m_current_replace_job"].as(CReplaceJob)
			if !rjob:
				rjob=new CReplaceJob
				rjob.m_match_cost=js_this["m_match_cost"].or(rjob.m_match_cost)
				rjob.m_s_replace=js_this["m_s_replace"].as(string)
				rjob.m_direction=direction
				js_this["m_current_replace_job"]=rjob
			ops=rjob.m_ops
			//replace mode
			assert(!(flags&SEARCH_FLAG_FUZZY))
			if flags&SEARCH_FLAG_REGEXP:
				//this ReportMatch callback is ignored inside SearchRegexp if an autoedit program is provided in m_ae_prg
				ReportMatch=function(i64 ccnt0,i64 ccnt1){
					ops.push(TEditop(){ccnt:ccnt0,sz:ccnt1-ccnt0,s:rjob.m_s_replace})
					return rjob.m_match_cost
				}
			else
				preserve_case=0
				if !(flags&SEARCH_FLAG_CASE_SENSITIVE):
					case0=AssessCase(s)
					case1=AssessCase(rjob.m_s_replace)
					if case0==case1&&case0!=CASE_UNKNOWN:
						preserve_case=1
				if preserve_case:
					ReportMatch=function(i64 ccnt0,i64 ccnt1){
						if flags&SEARCH_FLAG_WHOLE_WORD:
							(ch0,ch1)=ed.GetUtf8CharNeighborhood(ccnt0)
							if isWordChar(ch0)==isWordChar(ch1):return 0
							(ch0,ch1)=ed.GetUtf8CharNeighborhood(ccnt1)
							if isWordChar(ch0)==isWordChar(ch1):return 0
						auto s_replacement=rjob.m_s_replace
						//make an attempt to preserve case
						if ccnt1-ccnt0<MAX_CASE_ASSESSABLE:
							case_i=AssessCase(ed.GetText(ccnt0,ccnt1-ccnt0))
							if case_i!=0:
								s_replacement=ApplyCase(s_replacement,case_i)
						//s vs rjob.m_s_replace
						ops.push(TEditop(){ccnt:ccnt0,sz:ccnt1-ccnt0,s:s_replacement})
						return rjob.m_match_cost
					}
				else
					ReportMatch=function(i64 ccnt0,i64 ccnt1){
						if flags&SEARCH_FLAG_WHOLE_WORD:
							(ch0,ch1)=ed.GetUtf8CharNeighborhood(ccnt0)
							if isWordChar(ch0)==isWordChar(ch1):return 0
							(ch0,ch1)=ed.GetUtf8CharNeighborhood(ccnt1)
							if isWordChar(ch0)==isWordChar(ch1):return 0
						ops.push(TEditop(){ccnt:ccnt0,sz:ccnt1-ccnt0,s:rjob.m_s_replace})
						return rjob.m_match_cost
					}
		else
			if flags&SEARCH_FLAG_REGEXP:
				assert(!(flags&SEARCH_FLAG_FUZZY))
				ReportMatch=function(i64 ccnt0,i64 ccnt1){
					return js_callback.Call(int,ccnt0,ccnt1)
				}
			else
				ReportMatch=function(i64 ccnt0,i64 ccnt1){
					if flags&SEARCH_FLAG_WHOLE_WORD:
						(ch0,ch1)=ed.GetUtf8CharNeighborhood(ccnt0)
						if isWordChar(ch0)==isWordChar(ch1):return 0
						(ch0,ch1)=ed.GetUtf8CharNeighborhood(ccnt1)
						if isWordChar(ch0)==isWordChar(ch1):return 0
					return js_callback.Call(int,ccnt0,ccnt1)
				}
		if flags&SEARCH_FLAG_REGEXP:
			assert(!(flags&SEARCH_FLAG_FUZZY))
			//the regexp version returns an object to JS
			if direction>0:
				return SearchRegexp(JS,ed,range_ccnt1,1, s,flags,ReportMatch, budget)
			else
				return SearchRegexp(JS,ed,range_ccnt0,-1, s,flags,ReportMatch, budget)
		else if flags&SEARCH_FLAG_FUZZY:
			if direction>0:
				return SearchFuzzy(JS,ed,range_ccnt1,1, s,flags,ReportMatch, budget)
			else
				return SearchFuzzy(JS,ed,range_ccnt0,-1, s,flags,ReportMatch, budget)
		else
			ocase=(flags&SEARCH_FLAG_CASE_SENSITIVE)
			ccnt0=JS.Param(1).as(i64)
			if direction>0:
				ret=SearchPlainText(ed,ccnt0,range_ccnt1,1, s,ocase,ReportMatch, budget)
			else
				ret=SearchPlainText(ed,ccnt0,range_ccnt0,-1, s,ocase,ReportMatch, budget)
		return JS.Return(ret)
	}
	//this is not hook-friendly
	JS_UI["ED_ApplyReplaceOps"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		rjob=JS.Param(1).as(CReplaceJob)
		if !ed||!rjob:return JS.ReturnError("invalid parameters")
		//for now, just do it the dumb way
		n=rjob.m_ops.n
		if n:
			ed.Edit(rjob.m_ops)
		return JS.Return(n)
	}
	//
	JS_UI["ED_RawEditDistance"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		ccnt0=JS.Param(1).as(i64)
		ccnt1=JS.Param(2).as(i64)
		s_tar=JS.Param(3).as(string)
		ocase=JS.Param(4).as(int)
		s_src=ed.GetText(ccnt0,ccnt1-ccnt0)
		ops=RawEditDistance(Utf8ToUnicode32(s_src),Utf8ToUnicode32(s_tar),ocase)
		ret=JS.NewArray()
		foreach op,I in ops
			ret[I*3+0]=op.ccnt+ccnt0
			ret[I*3+1]=op.sz
			ret[I*3+2]=op.s
		return JS.Return(ret)
	}
	//smart paste - it's slow, do it natively
	JS_UI["ED_GetClipboardTextSmart"]=function(JSContext JS){
		MAX_INDENT=256
		str=JS.Param(1).as(string)
		if !str:
			s_pchar=__pointer(SDL.detail.SDL_GetClipboardText())
			if !s_pchar:return 0
			str=System.detail.pcharToString(s_pchar)
		if str.IndexOf('\n')<0L:return 0
		s_target_indent=JS.Param(0).or("")
		indent_in_front=JS.Param(2).as(int)
		if ENABLE_EXPERIMENTAL_FEATURES:
			s_tag_tail=string.NULL
			if str.n>=4&&(int(str[str.n-4])&0xf0)==0xf0:
				s_tag_tail=str[str.n-4:]
				str=str[:str.n-5]
		is_folded=0
		if str.n&&str[0]=='\n':
			//could be folded text, go into smart paste with the initial newline stripped
			str=str[1:]
			is_folded=1
		else if str.n>=2&&str[0]=='\r'&&str[1]=='\n':
			str=str[2:]
			is_folded=1
		p_trailing_space=str.n
		while p_trailing_space>0&&(str[p_trailing_space-1]==' '||str[p_trailing_space-1]=='\t')&&p_trailing_space>str.n-MAX_INDENT:
			p_trailing_space--
		if p_trailing_space>0&&str[p_trailing_space-1]=='\n':
			//indent in the end, gotta rearrange it
			if is_folded:
				//downright ignore the space in the folding mode
				str2=str[:p_trailing_space-1]
			else
				//move it to the front in the non-folding mode
				str2=str[p_trailing_space:]+str[:p_trailing_space-1]
		else
			str2=str
		if str2.n&&str2.back()=='\n':
			str2=str2[:str2.n-2]
		if str2.n&&str2.back()=='\r':
			str2=str2[:str2.n-2]
		got_first_indent=0
		pindent_first=0
		sinsert=new string
		foreach sline,I0,I1 in str2.TokenizeEx("\n",str2.TOKENIZE_ALLOW_EMPTY)
			pindent=0
			if ENABLE_EXPERIMENTAL_FEATURES:
				s_tag_char=string.NULL
				if sline.n>=4&&((int(sline[0])&0xf0)==0xf0):
					//tag char
					s_tag_char=sline[0:3]
					sline=sline[4:]
			while pindent<sline.n&&pindent<MAX_INDENT&&(sline[pindent]==' '||sline[pindent]=='\t'):
				pindent++
			if !got_first_indent:
				pindent_first=pindent
				got_first_indent=1
			if ENABLE_EXPERIMENTAL_FEATURES:
				if s_tag_char:
					sinsert.push(s_tag_char)
			if pindent<pindent_first:
				if !pindent&&!sline.n:
					//empty line, keep it empty but add the full indent
					sinsert.push(s_target_indent)
				else
					//subtract something
					sinsert.push(s_target_indent[:max(s_target_indent.n+pindent-pindent_first,0)-1])
					sinsert.push(sline[pindent:])
			else
				if sinsert.n||indent_in_front:
					sinsert.push(s_target_indent)
				sinsert.push(sline[pindent_first:])
			if sinsert.n&&sinsert[sinsert.n-1]=='\r':
				sinsert.pop()
			sinsert.push('\n')
		if sinsert.n&&!indent_in_front:
			sinsert.push(s_target_indent)
		if ENABLE_EXPERIMENTAL_FEATURES:
			if s_tag_tail:
				sinsert.push(s_tag_tail)
		//sinsert.pop()
		return JS.Return(sinsert)
	}
	//avoid going throught JS
	JS_UI["ED_AutoEdit_Detect"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		if !ed:return JS.ReturnError("invalid editor")
		ccnt_lh=JS.Param(1).as(i64)
		ccnt_get=max(ccnt_lh-(AUTO_EDIT_MAX_TOTAL_LENGTH>>1),0LL)
		stext=ed.GetText(ccnt_get,i64(min(AUTO_EDIT_MAX_TOTAL_LENGTH,ed.GetTextSize()-ccnt_get)))
		cclines=AutoEdit_Detect(stext,iptr(ccnt_lh-ccnt_get))
		if !cclines:
			return 0
		else
			ctx=AutoEdit_Precompute(stext,cclines)
			if !ctx:
				return 0
			else
				ret=JS.New()
				ret["m_cclines"]=[ccnt+ccnt_get foreach ccnt in cclines]
				ret["m_ctx"]=ctx
				ret["m_owner"]=ed
				ret["m_example_lines"]=JS.New()
				return JS.Return(ret)
	}
	JS_UI["ED_AutoEdit_Start"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		if !ed:return JS.ReturnError("invalid editor")
		js_cclines=JS.Param(1).as(JSObject)
		n=js_cclines["length"].as(iptr)
		if n<=1L:return 0
		cclines=new i64[(n-1)*2]
		for i=0:n-2
			cclines[i*2+0]=js_cclines[i].as(i64)
			cclines[i*2+1]=js_cclines[i+1].as(i64)-1LL
		ccnt_get=cclines[0]
		lg_max=i64(min(AUTO_EDIT_MAX_TOTAL_LENGTH,ed.GetTextSize()-ccnt_get))
		if cclines[cclines.n-1]-ccnt_get>lg_max:return 0
		stext=ed.GetText(ccnt_get,lg_max)
		ctx=AutoEdit_Precompute(stext,[iptr(ccnt-ccnt_get) foreach ccnt in cclines])
		if !ctx:
			return 0
		else
			ret=JS.New()
			ret["m_cclines"]=cclines
			ret["m_ctx"]=ctx
			ret["m_owner"]=ed
			ret["m_example_lines"]=JS.New()
			return JS.Return(ret)
	}
	JS_UI["ED_AutoEdit_SetExample"]=function(JSContext JS){
		obj=JS.Param(0).as(JSObject)
		if !obj:return JS.ReturnError("invalid object")
		line_id=JS.Param(1).as(int)
		s_new=JS.Param(2).as(string)
		ctx=obj["m_ctx"].as(CReplaceContext)
		example_lines=obj["m_example_lines"].as(JSObject)
		(prg,match_table)=AutoEdit_SetExample(ctx,line_id,s_new)
		if prg:
			obj["m_prg"]=new CProgramWrapper(){prg:prg}
			example_lines[line_id]=1
			return JS.Return(1)
		else
			return 0
	}
	JS_UI["ED_AutoEdit_Evaluate"]=function(JSContext JS){
		obj=JS.Param(0).as(JSObject)
		if !obj:return JS.ReturnError("invalid object")
		wprg=obj["m_prg"].as(CProgramWrapper)
		if !wprg:return JS.ReturnError("invalid program")
		locs=JS.Param(1).as(JSObject)
		if !locs:return JS.ReturnError("invalid locators")
		include_examples=JS.Param(2).or(0)
		prg=wprg.prg
		ctx=obj["m_ctx"].as(CReplaceContext)
		ed=obj["m_owner"].as(CEditableText)
		example_lines=obj["m_example_lines"].as(JSObject)
		ops=new TEditop[]
		n=locs.length()
		for i=0:2:n-2
			if example_lines[i>>1].as(int)&&!include_examples:continue
			ccnt0=(locs[i].as(CLocator)).ccnt
			ccnt1=(locs[i+1].as(CLocator)).ccnt
			(s_unicode,nbras_old)=TextToAutoEditText(1,1,ed.GetText(i64(ccnt0),i64(ccnt1-ccnt0)))
			if !AutoEdit_Evaluate(ops,i64(ccnt0), ctx, prg, int(i)>>1,s_unicode,nbras_old):
				break
		ret=JS.NewArray()
		foreach op,I in ops
			ret[I*3+0]=op.ccnt
			ret[I*3+1]=op.sz
			ret[I*3+2]=op.s
		return JS.Return(ret)
	}
	//////////////
	JS_UI["ED_AutoEdit_RegexpCtxCreate"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		if !ed:return JS.ReturnError("invalid editor")
		js_cc_matches=JS.Param(1).as(JSObject)
		n=js_cc_matches["length"].as(iptr)
		ccnt0=js_cc_matches[0].as(i64)
		ccnt1=js_cc_matches[1].as(i64)
		match_positions=[js_cc_matches[i].as(int) for i=2:n-1]
		//Writeln(match_positions)
		stext=ed.GetText(ccnt0,ccnt1-ccnt0)
		//Writeln('match_positions=',match_positions)
		ctx=AutoEdit_SingleExamplePrecompute(stext,match_positions)
		return ctx?JS.Return(ctx):0
	}
	JS_UI["ED_AutoEdit_RegexpCtxSetExample"]=function(JSContext JS){
		ctx=JS.Param(0).as(CReplaceContext)
		if !ctx:return JS.ReturnError("invalid context")
		s_new=JS.Param(1).as(string)
		(prg,match_table)=AutoEdit_SetExample(ctx,0,s_new)
		//just a colorer
		if prg:
			ret=JS.New()
			ret["m_prg"]=new CProgramWrapper(){prg:prg}
			ret["m_match_table"]=match_table
			return JS.Return(ret)
		else
			return 0
	}
	JS_UI["ED_AutoEdit_RegexpMatch"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		if !ed:return JS.ReturnError("invalid editor")
		ccnt0=JS.Param(1).as(i64)
		ccnt1=JS.Param(2).as(i64)
		sregexp=JS.Param(3).as(string)
		flags=JS.Param(4).as(int)
		stext=ed.GetText(ccnt0,ccnt1-ccnt0)
		se=sregexp
		if se.n&&se[0]=='^':
			se=se[1:]
		if se.n&&se.back()=='$':
			se=se[:se.n-2]
		if se=="":se="\"\""
		reo=ParseRegex(se)
		if !(flags&SEARCH_FLAG_CASE_SENSITIVE):reo=RegexMakeCaseInsensitive(reo)
		reo=RegexBracket(reo)
		regex=new Regex(reo)
		match=regex.MatchExi(stext)
		if !match:
			return 0
		else
			//we need UNICODE ccnt
			utf8_utf32_map=new int[stext.n+1]
			pu=0
			foreach ch,I in Utf8Chars(stext)
				utf8_utf32_map[I]=pu
				pu++
			utf8_utf32_map[stext.n]=pu
			auto ret=[double(I>=2?utf8_utf32_map[p]:p) foreach p,I in match]
			ret[0]+=double(ccnt0)
			ret[1]+=double(ccnt0)
			return JS.Return(ret)
	}
	//////////////
	JS_UI["ED_CreateDiffTrackerBitmap"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		if !ed:return 0
		diff=JS.Param(1).as(CDiffTracker)
		if !diff:return 0
		h_screen=min(int(JS.Param(2).as(float)),2048)
		bmp=new u8[h_screen]
		//////
		ytot=ed.XYFromCcnt(ed.GetTextSize()).y
		modified_ccnt_ranges=new i64[]
		DEPTH_THRESHOLD=16
		auto dfs(CDiffSLNode nd,i64 ccnt_current_base,int depth)
			if nd.ccnts[0]==nd.ccnts[2]&&nd.ccnts[1]==nd.ccnts[2]:
				//ignore unchanged parts
				return
			if !nd.ccnts[1]||!nd.ccnts[0]:
				//ignore completely deleted / inserted parts
				modified_ccnt_ranges.push(ccnt_current_base)
				modified_ccnt_ranges.push(ccnt_current_base+nd.ccnts[1])
				return
			if depth>DEPTH_THRESHOLD:
				//cost-control: switch to GetXY-h_screen test when depth goes beyond a threshold
				auto boundary_xys=ed.GetXYEnMasse([ccnt_current_base,ccnt_current_base+nd.ccnts[1]])
				auto y0=min(max(int(boundary_xys[1]*i64(h_screen)/ytot),0),h_screen-1)
				auto y1=min(max(int(boundary_xys[3]*i64(h_screen)/ytot),0),h_screen-1)
				if y1-y0<=2:
					modified_ccnt_ranges.push(ccnt_current_base)
					modified_ccnt_ranges.push(ccnt_current_base+nd.ccnts[1])
					return
			auto pc=nd.pchild
			auto ccnt_acc=ccnt_current_base
			assert(!!pc)
			for(;pc;pc=pc.pnext)
				dfs(pc,ccnt_acc,depth+1)
				ccnt_acc+=pc.ccnts[1]
		dfs(diff.m_skiplist,0LL,0)
		if modified_ccnt_ranges.n:
			xys=ed.GetXYEnMasse(modified_ccnt_ranges)
			hc=ed.GetCharacterHeightAt(0LL)
			ytot+=hc
			if !(ytot>0LL):
				ytot=1LL
			for i=0:4:xys.n-4
				y0=min(max(int(xys[i+1]*i64(h_screen)/ytot),0),h_screen-1)
				y1=min(max(int((xys[i+3]+hc)*i64(h_screen)/ytot),0),h_screen-1)
				for j=y0:y1
					bmp[j]=u8(255)
		return JS.Return(new CDiffBitmap(){data:bmp})
	}
	JS_UI["ED_GetFindLocatorXYEnMasse"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		if !ed:return 0
		locators=JS.Param(1).as(JSObject)
		n=locators["length"].as(iptr)
		ccnts=new i64[]
		for i=0:2:n-2
			ccnts.push(locators[i].as(CLocator).ccnt)
		ccnts.Sort()
		xys=ed.GetXYEnMasse(ccnts)
		return JS.Return([fixed2double(d) for d in xys])
	}
	spaceTabWidth=function(string smatch,int tab_width){
		cw=0
		for ch in smatch
			if ch=='\t':
				cw=(cw/tab_width+1)*tab_width
			else
				cw++
		return cw
	}
	JS_UI["ED_NativeToSpace"]=function(JSContext JS){
		smatch=JS.Param(0).as(string)
		tab_width=JS.Param(1).as(int)
		lg=spaceTabWidth(smatch,tab_width)
		return JS.Return([' ' for i=0:lg-1])
	}
	JS_UI["ED_NativeToTab"]=function(JSContext JS){
		smatch=JS.Param(0).as(string)
		tab_width=JS.Param(1).as(int)
		lg=spaceTabWidth(smatch,tab_width)
		return JS.Return(['\t' for i=0:(lg+(tab_width-1))/tab_width-1])
	}
	JS_UI["ED_DrawDiffMinimap"]=function(JSContext JS){
		x=JS.Param(0).as(float)
		y=JS.Param(1).as(float)
		w=JS.Param(2).as(float)
		h=JS.Param(3).as(float)
		C=JS.Param(4).as(int)
		dbmp=JS.Param(5).as(CDiffBitmap)
		if !dbmp:return 0
		bmp=dbmp.data
		texid=JS_UI["g_diff_minimap_texture"].as(GLuint)
		tech=JS_UI["g_diff_minimap_technique"].as(GLTechnique)
		if !texid:
			texid=glCreateTexture(GL_ALPHA8,2048,1, GL_LINEAR,GL_CLAMP_TO_EDGE,GL_CLAMP_TO_EDGE,NULL)
			tech=new GLTechnique
			tech.SetVarying("vec4 C;")
			tech.SetVarying("float u;")
			tech.SetVertexShader("
			void main(){
				vec2 P_scr=P*scale;
				"+(Gui2D.detail.g_renderer.m_srgb_supported?"C=vec4(pow(C_vert.xyz,vec3("+formatNumber(Gui2D.detail.g_renderer.m_gamma,{frac:7})+")),C_vert.w);":"C=C_vert;")+"
				gl_Position=vec4(P_scr.x-1.0,1.0-P_scr.y,1.0,1.0);
				u=u_vert;
			}")
			tech.SetFragmentShader("void main(){gl_FragColor=vec4(1.0,1.0,1.0,texture2D(tex0,vec2(u,0.5)).w)*C;}")
			JS_UI["g_diff_minimap_texture"]=texid
			JS_UI["g_diff_minimap_technique"]=tech
		glBindTexture(GL_TEXTURE_2D,texid)
		glTexSubImage2D(GL_TEXTURE_2D,0,0,0,int(bmp.n),1,GL_ALPHA,GL_UNSIGNED_BYTE,__pointer(bmp.d))
		glBindTexture(GL_TEXTURE_2D,0u)
		u_max=f32(bmp.n)/2048.f
		vbo=g_renderer.UploadMiniVBO([
			__float_as_int(x),__float_as_int(y),
			__float_as_int(x+w),__float_as_int(y),
			__float_as_int(x+w),__float_as_int(y+h),
			__float_as_int(x),__float_as_int(y+h),
			C,C,C,C,
			0,0,__float_as_int(u_max),__float_as_int(u_max)])
		tech.SetVertexPointer("P", 2,GL_FLOAT,0, 2*sizeof(int),0L)
		tech.SetVertexPointer("C_vert", 4,GL_UNSIGNED_BYTE,1, sizeof(int),0L+8*sizeof(float))
		tech.SetVertexPointer("u_vert", 1,GL_FLOAT,1, sizeof(int),0L+12*sizeof(float))
		prev_viewport=new int[4]
		glGetIntegerv(GL_VIEWPORT,__pointer(prev_viewport.d));
		tech.SetUniform("scale",float2(2.f/f32(prev_viewport[2]),2.f/f32(prev_viewport[3])))
		tech.SetTexture2D("tex0",texid)
		tech.Draw(vbo,GL_TRIANGLE_FAN,4)
		return 0
	}
	SetUniformJS=function(GLTechnique tech,JSObject uniforms)
		if !uniforms:return;
		auto arr_uniforms=JS_UI.CallMethod(JSObject,'Map2Array',uniforms)
		SetUniformJSArray(tech,arr_uniforms)
	SetUniformJSArray=function(GLTechnique tech,JSObject arr_uniforms)
		if !arr_uniforms:return;
		auto n=arr_uniforms["length"].as(int)
		for i=0:2:n-2
			auto s_name=arr_uniforms[i].as(string)
			if s_name.StartsWith("tex_"):
				tech.SetTexture2D(s_name,arr_uniforms[i+1].as(GLuint))
			else if s_name.StartsWith("color_"):
				C=arr_uniforms[i+1].as(int)
				C4=float4(
					float((C>>0)&0xff)/255.f,
					float((C>>8)&0xff)/255.f,
					float((C>>16)&0xff)/255.f,
					float((C>>24)&0xff)/255.f)
				if C4.x>0:C4.x=pow(C4.x,1.f/g_renderer.m_gamma)
				if C4.y>0:C4.y=pow(C4.y,1.f/g_renderer.m_gamma)
				if C4.z>0:C4.z=pow(C4.z,1.f/g_renderer.m_gamma)
				tech.SetUniform(s_name,C4)
			else
				if arr_uniforms[i+1].has("length"):
					auto lg_arr_i=arr_uniforms[i+1]["length"].as(int)
					auto param_i_x=arr_uniforms[i+1][0].as(float)
					auto param_i_y=arr_uniforms[i+1][1].as(float)
					auto param_i_z=arr_uniforms[i+1][2].as(float)
					auto param_i_w=arr_uniforms[i+1][3].as(float)
					if lg_arr_i==2:
						tech.SetUniform(s_name,float2(param_i_x,param_i_y))
					else if lg_arr_i==3:
						tech.SetUniform(s_name,float3(param_i_x,param_i_y,param_i_z))
					else if lg_arr_i==4:
						tech.SetUniform(s_name,float4(param_i_x,param_i_y,param_i_z,param_i_w))
					else if lg_arr_i==16:
						auto mat=[arr_uniforms[i+1][j].as(float) for j=0:15]
						tech.SetUniform(s_name,mat)
				else
					tech.SetUniform(s_name,arr_uniforms[i+1].as(float))
	g_fse_techs=new GLTechnique[string]
	JS_UI["ED_DrawFullScreenEffect"]=function(JSContext JS){
		auto s_shader=JS.Param(0).as(string)
		auto uniforms=JS.Param(1).as(JSObject)
		tech=g_fse_techs[s_shader]
		if !tech:
			tech=new GLTechnique
			g_fse_techs[s_shader]=tech
		tech.SetFragmentShader(s_shader+"void main(){
			vec4 C=shader_main(st);
			C=vec4(pow(C.xyz,vec3("+formatNumber(g_renderer.m_gamma,{frac:7})+")),C.w);
			gl_FragColor=C;
		}")
		SetUniformJS(tech,uniforms);
		tech.DrawScreenQuad()
		return 0;
	}
	JS_UI["ED_isWordChar"]=function(JSContext JS){
		auto ch=JS.Param(0).as(int)
		return JS.Return(isWordChar(ch));
	}
	JS_UI["ED_8bitStringSort"]=function(JSContext JS){
		auto ss=JS.Param(0).as(JSObject)
		n=ss["length"].as(iptr)
		ret=[ss[i].as(string) for i=0:n-1]
		ret.Sort()
		for i=0:n-1
			ss[i]=ret[i]
		return 0
	}
	/////////////////////////////
	struct TRenderJob
		float x,y
		int style_id
		int ccnt0,ccnt1
	class CPreprocessedRichText
		TRenderJob[] m_rjobs
		CStyleHolder m_styles
		float m_h_text
		float m_scale0,m_scale_cur,m_w_line
		TFont[] m_emboldened_fonts
		__JS_prototype=function(JSObject proto){
			proto.ExportProperty(this,"m_h_text")
			proto.ExportProperty(this,"m_w_line")
		};
	JS_UI["ED_ProcessHelp"]=function(JSContext JS){
		//do it in native for speed, maybe we could have a highlighter like this
		auto sblock=JS.Param(0).as(string)
		auto js_styles=JS.Param(1).as(JSObject)
		auto fsearchImage=JS.Param(2).as(JSObject)
		auto w_linef=JS.Param(3).as(float)
		auto STYLE_ID_NORMAL=0
		auto STYLE_ID_EMPH=1
		auto STYLE_ID_BOLD=2
		auto STYLE_ID_CODE=3
		auto STYLE_ID_LIST=4
		auto STYLE_ID_QUOTE=5
		auto STYLE_ID_HEADINGS=6
		auto STYLE_ID_N_HEADINGS=4
		auto CODE_MAX_LINES=12
		auto sret=new string
		auto is_in_code=JSObject.NULL
		auto scode=string.NULL
		auto nlines_code=0LL
		auto objs=new CEmbededObject[]
		auto hc_code=float2fixed(g_renderer.GetCharacterHeight(js_styles[STYLE_ID_CODE]["font"].as(TFont)))
		auto h_hr=double2fixed(JS["UI"]["default_styles"]["help_page"]["hr_h"].as(double))
		auto heading_seq=new int[]
		auto ops=JS.NewArray()
		auto ops_length=0
		auto has_dangling_op=0
		auto w_image_max=JS["UI"]["default_styles"]["help_page"]["w_max_img_width_percentage"].as(float)*w_linef
		auto w_code_box=JS["UI"]["default_styles"]["help_page"]["w_code_box_percentage"].as(float)*w_linef
		auto fparseop=JS["UI"]["ParseHelpCommand"].as(JSObject)
		JS["UI"]["PrecomputeHelpCommands"].Call(int)
		if !sblock.n||sblock.back()!='\n':
			sblock=new(sblock)
			sblock.push('\n')
		FormatNormalText=function(string stext,int style0){
			auto in_emph=0
			auto in_code=0
			auto last_star=stext.LastIndexOf('*')
			for(auto i=0L;i<stext.n;i++)
				ch=stext[i]
				if !in_code:
					if ch=='\'':
						if !i||!isWesternLetter(stext[i-1]):
							sret.PushUnicode(0x2018)
						else if i==stext.n-1||!isWesternLetter(stext[i+1]):
							sret.PushUnicode(0x2019)
						else
							sret.push(ch)
						continue
					else if ch=='"':
						if !i||!isWesternLetter(stext[i-1]):
							sret.PushUnicode(0x201C)
						else if i==stext.n-1||!isWesternLetter(stext[i+1]):
							sret.PushUnicode(0x201D)
						else
							sret.push(ch)
						continue
					else if ch=='*':
						n_stars=1
						if i<stext.n-1&&stext[i+1]=='*':
							i++
							n_stars++
						if in_emph==n_stars:
							in_emph=0
							sret.PushUnicode(COMMAND_SET_STYLE+style0)
						else if i==last_star:
							sret.push('*')
							if n_stars>1:sret.push('*')
						else
							in_emph=n_stars
							sret.PushUnicode(COMMAND_SET_STYLE+(n_stars==1?STYLE_ID_EMPH:STYLE_ID_BOLD))
						continue
				if !in_emph&&ch=='`':
					if in_code:
						sret.PushUnicode(COMMAND_SET_STYLE+style0)
						in_code=0
					else
						sret.PushUnicode(COMMAND_SET_STYLE+STYLE_ID_CODE)
						in_code=1
					continue
				sret.push(ch)
		}
		code_box_id=0
		is_after_caption=0
		fseektag=JS["UI"]["SeekTag"].as(JSObject)
		foreach sline,I in sblock.TokenizeEx("\n",sblock.TOKENIZE_ALLOW_EMPTY|sblock.TOKENIZE_INCLUDE_SEPARATOR)
			if sline.StartsWith('```'):
				//code
				if !is_in_code:
					s_language=sline[3:sline.n-2]
					if !s_language.n:
						s_language="txt"
					scode=new string
					nlines_code=1LL//leave 1 empty line there...
					//coulddo: alternative names for each language, use extension for now
					is_in_code=JS.New()
					is_in_code["m_type"]="pre"
					is_in_code["m_language"]=s_language
					is_in_code["m_id"]=code_box_id
					if has_dangling_op:
						has_dangling_op=0
						ops[ops_length-1]["obj_code"]=is_in_code
					code_box_id++
				else
					is_in_code["m_code"]=scode
					is_in_code["m_width"]=w_code_box
					is_in_code["m_height"]=fixed2float(min(nlines_code,CODE_MAX_LINES)*hc_code)
					if sret.n&&sret.back()!='\n':sret.push('\n')
					sret.PushUnicode(COMMAND_RUBBER_SPACE)
					sret.PushUnicode(COMMAND_INSERT_OBJECT+int(objs.n))
					sret.PushUnicode(COMMAND_RUBBER_SPACE)
					sret.push('\n')
					objs.push(new CEmbededObject(){
						content:is_in_code,
						w:float2fixed(w_code_box),
						h:min(nlines_code,CODE_MAX_LINES)*hc_code,
						y_baseline:0LL,
					})
					is_in_code=JSObject.NULL
				continue
			if is_in_code:
				scode.push(sline)
				nlines_code++
				continue
			////////////
			if sline.n>1&&is_after_caption:
				if sret.n&&sret.back()!='\n':sret.push('\n')
				sret.push('\n')
				is_after_caption=0
			if sline.StartsWith("#"):
				if sret.n&&sret.back()!='\n':sret.push('\n')
				if sret.n<2||sret[sret.n-2]!='\n':sret.push('\n')
				//heading
				level=0L
				for j=1:sline.n-2
					if sline[j]!='#':
						level=j
						break
				//resize resets the lower levels
				heading_seq.resize(level)
				heading_seq[level-1]++
				seq_id=heading_seq[level-1]
				//if level==1L:
				//	//do not number the top level heading
				//	//center it
				//	sret.PushUnicode(COMMAND_RUBBER_SPACE)
				sret.PushUnicode(COMMAND_SET_STYLE+STYLE_ID_HEADINGS+min(int(level)-1,STYLE_ID_N_HEADINGS))
				for j=1:level-1
					if j>1L:sret.push('.')
					SWrite(sret,heading_seq[j])
				if level>1L:
					sret.push(' ')
					sret.push(' ')
				sret.push(sline[(sline[level]==' '?level+1:level):sline.n-2])
				//if level==1L:
				//	//center it
				//	sret.PushUnicode(COMMAND_RUBBER_SPACE)
				is_after_caption=1
				continue
			if sline.StartsWith("\t")||sline.StartsWith("    "):
				//inactive code-like
				sret.PushUnicode(COMMAND_SET_STYLE+STYLE_ID_CODE)
				sret.push(sline)
				continue
			if sline.StartsWith("* ")||sline.StartsWith("- ")||sline.StartsWith("+ "):
				//lists
				if sret.n&&sret.back()!='\n':sret.push('\n')
				sret.PushUnicode(COMMAND_SET_STYLE+STYLE_ID_LIST)
				sret.PushUnicode(0x2022)
				sret.PushUnicode(0x00a0)
				sret.PushUnicode(COMMAND_INDENT_HERE)
				FormatNormalText(sline[2:],STYLE_ID_LIST)
				continue
			if sline.StartsWith("> ")
				//quotes
				if sret.n&&sret.back()!='\n':sret.push('\n')
				if sline.n==3:
					sret.push('\n')
				else
					sret.PushUnicode(0x00a0)
					sret.PushUnicode(0x00a0)
					sret.PushUnicode(COMMAND_INDENT_HERE)
					sret.PushUnicode(COMMAND_SET_STYLE+STYLE_ID_QUOTE)
					FormatNormalText(sline[2:sline.n-2],STYLE_ID_QUOTE)
				continue
			if sline.StartsWith("!["):
				pbracket=sline.IndexOf(']')
				if pbracket+1<sline.n&&sline[pbracket+1]=='(':
					sline=sline[pbracket+2:]
					pspace=sline.IndexOf(' ')
					if pspace>=0:
						sline.n=pspace
					else
						sline.n--
						if sline.n>0&&sline[sline.n-1]==')':
							sline.n--
					fn_image=sline
					/*!if fn_image.StartsWith("qtag://"):
						//code reference case
						//tag locating - per-qpad-installation cache, do not overdesign
						ptag=CodeParser.g_tag_by_id[CodeParser.getid(fn_image[7:])]
						if !ptag:
							//#b+, #b-
							fn_tag_cache=JS["UI"]["m_ui_metadata"]["<tag_cache>"][fn_image[7:]].as(string)
							if fn_tag_cache:
								//trigger parsing
								CodeParser.g_c_like_parse_queue.push(
									CodeParser.getid(System.Env.NormalizeFileName(fn_tag_cache)))
								JS["UI"].CallMethod(int,"ED_ParseMore");
							ptag=CodeParser.g_tag_by_id[CodeParser.getid(fn_image[7:])]
						obj=JS.New()
						obj["m_type"]="qtag"
						if ptag:
							s_fn=CodeParser.getIdString(ptag.idfn)
							obj["m_fn"]=s_fn
							obj["m_epos0"]=ptag.epos0
							obj["m_epos1"]=ptag.epos1
							//create an op
							obj_op=JS.New()
							obj_op["match"]=JS.NewArray()
							obj_op["match"][0]=s_fn
							obj_op["match"][1]=fn_image[7:]
							obj_op["action"]=fseektag
							obj_op["ccnt"]=sret.n
							ops[ops_length]=obj_op;ops_length++
							has_dangling_op=0
							SWrite(sret,'Tag ',fn_image[7:],' in ',s_fn,':\n')
						obj["m_width"]=w_code_box
						obj["m_height"]=fixed2float(CODE_MAX_LINES*hc_code)
						obj["m_id"]=code_box_id
						code_box_id++
						sret.PushUnicode(COMMAND_RUBBER_SPACE)
						sret.PushUnicode(COMMAND_INSERT_OBJECT+int(objs.n))
						sret.PushUnicode(COMMAND_RUBBER_SPACE)
						sret.push('\n')
						objs.push(new CEmbededObject(){
							content:obj,
							w:float2fixed(w_code_box),
							h:CODE_MAX_LINES*hc_code,
							y_baseline:0LL,
						})
					else*/
					//image case
					if fsearchImage:
						fn_image=fsearchImage.Call(string,fn_image)
					sdata_image=System.IO.ReadAll(fn_image)
					//Writeln('img:',fn_image,' ',!!sdata_image)
					if sdata_image:
						(img,wimg,himg)=g_renderer.LoadImage(sdata_image)
						//Writeln('img:',fn_image,' ',wimg,' ',himg)
						if img:
							obj=JS.New()
							obj["m_type"]="img"
							obj["m_tex"]=new CRichTextImage(){
								cpu_data:img,
								w:wimg,
								h:himg,
							}
							if sret.n&&sret.back()!='\n':sret.push('\n')
							sret.PushUnicode(COMMAND_RUBBER_SPACE)
							sret.PushUnicode(COMMAND_INSERT_OBJECT+int(objs.n))
							sret.PushUnicode(COMMAND_RUBBER_SPACE)
							sret.push('\n')
							scale_img=min(float(wimg),w_image_max)/float(wimg)
							objs.push(new CEmbededObject(){
								content:obj,
								w:float2fixed(float(wimg)*scale_img),
								h:float2fixed(float(himg)*scale_img),
								y_baseline:0LL,
							})
				continue
			is_hr=0
			if sline.n>=4&&(sline[0]=='*'||sline[0]=='-'||sline[0]=='_'):
				is_hr=1
				for j=1:sline.n-2
					if sline[j]!=sline[0]:
						is_hr=0
						break
			if is_hr:
				obj=JS.New()
				obj["m_type"]="hr"
				if sret.n&&sret.back()!='\n':sret.push('\n')
				sret.PushUnicode(COMMAND_INSERT_OBJECT+int(objs.n))
				sret.push('\n')
				objs.push(new CEmbededObject(){
					content:obj,
					w:1LL,
					h:h_hr,
					y_baseline:0LL,
				})
				continue
			if sline.n==1:
				if sret.n&&sret.back()!='\n':sret.push('\n')
				sret.push('\n')
				is_after_caption=0
			else
				if !sret.n||sret.back()=='\n':
					//detect action descriptions - ops
					//use bgcolor to highlight this line later
					obj_op=fparseop.Call(JSObject,sline)
					if obj_op:
						if has_dangling_op:ops_length--
						ops[ops_length]=obj_op;ops_length++
						obj_op["ccnt"]=sret.n
						has_dangling_op=obj_op["need_code"].as(int)
				FormatNormalText(sline[:sline.n-2],STYLE_ID_NORMAL)
		obj_ret=JS.New()
		obj_ret["m_text"]=sret
		obj_ret["m_objs"]=objs
		obj_ret["m_ops"]=ops
		obj_ret["m_n_code_boxes"]=code_box_id
		return JS.Return(obj_ret)
	}
	JS_UI["ED_FormatRichText"]=function(JSContext JS){
		//leave objects for later
		auto hyp=JS.Param(0).as(CHyphenator)
		auto sblock=JS.Param(1).as(string).Replace(["\r"," "])
		auto tab_width=JS.Param(2).or(4)
		auto w_line=double2fixed(JS.Param(3).as(double))
		auto js_styles=JS.Param(4).as(JSObject)
		auto objs=JS.Param(5).as(JSObject)
		auto w_linef=fixed2float(w_line)
		n=js_styles["length"].as(iptr)
		styles=new CStyleHolder(){m_styles:new CStyle[n],m_enable_ligatures:1}
		for i=0:n-1
			style_i=new CStyle
			styles.m_styles[i]=style_i
			js_style_i=js_styles[i].as(JSObject)
			style_i.color=js_style_i["color"].as(int)
			fnt=js_style_i["font"].as(TFont)
			//fnt.h*=g_renderer.m_pixels_per_unit
			style_i.font=fnt
			style_i.flags=js_style_i["flags"].or(0)
			style_i.line_space=int(double2fixed(js_style_i["line_space"].or(0.0)))
			style_i.paragraph_space=int(double2fixed(js_style_i["paragraph_space"].or(0.0)))
			style_i.raise_height=int(float2fixed(g_renderer.GetFontBaseline(fnt))+double2fixed(js_style_i["raise_height"].or(0.0)))
		if objs:
			n_objs=objs["length"].as(iptr)
			objs_native=[objs[i].as(CEmbededObject) for i=0:n_objs-1]
		else
			objs_native=CEmbededObject[].NULL
		x=0LL
		y=0LL
		y_next=0LL
		hyphen_next=0
		prev_style_id=0
		rjobs=new TRenderJob[]
		foreach s,I in sblock.TokenizeEx("\n",sblock.TOKENIZE_ALLOW_EMPTY|sblock.TOKENIZE_INCLUDE_SEPARATOR)
			(atoms,tail_style_id,indent_point_atom)=TextToLayoutAtom(hyp,s,tab_width,w_line,1, styles,objs_native)
			x_indent=0LL
			for i=0:indent_point_atom-1
				x_indent+=atoms[i].w+atoms[i].tail_kerning
			if x_indent>w_line*2LL/3LL:
				x_indent=0LL
				indent_point_atom=0L
			line_breaks=GreedyLayoutGeneral(atoms[indent_point_atom:],w_line-x_indent)
			for i=1:line_breaks.n-1
				line_breaks[i]+=indent_point_atom
			x_next=0LL
			GenerateTextLayout(
				styles,
				s,atoms,line_breaks,tail_style_id,
				int(I),x_indent,w_line,s.EndsWith("\n"),1,
				inline(int style_id, int ccnt0,int ccnt1){
					//char range
					assert(ccnt0>=0&&ccnt1>ccnt0)
					rjobs.push(TRenderJob(){
						x:fixed2float(x),
						y:fixed2float(y-(ccnt1==ccnt0+1&&sblock[ccnt0]=='\n'?0:styles.m_styles[style_id].raise_height)),
						style_id:style_id,ccnt0:ccnt0,ccnt1:ccnt1-(sblock[ccnt1-1]=='\n')})
					for ch in Utf8Chars(sblock[ccnt0:ccnt1-1])
						x+=styles.charWidth(style_id,ch)
					prev_style_id=style_id
				},
				inline(i64 dw,int ccnt){
					//space
					x+=dw
				},
				inline(i64 h_up,i64 h_line,int aflag_ccnt){
					//new line
					if hyphen_next:
						rjobs.push(TRenderJob(){
							x:fixed2float(x),
							y:fixed2float(y-styles.m_styles[tail_style_id].raise_height),
							style_id:prev_style_id,ccnt0:-1,ccnt1:-1})
					x=x_next
					y=y_next
					x_next=x_indent
					y_next=y+h_line
					hyphen_next=!!(aflag_ccnt&ATOM_FLAG_HYPHEN)
					y+=h_up
				},
				inline(int oid, int ccnt){
					auto obj_i=objs[oid].as(CEmbededObject)
					rjobs.push(TRenderJob(){
						x:fixed2float(x),
						y:fixed2float(y),
						style_id:prev_style_id,ccnt0:-2,ccnt1:oid})
					x+=obj_i.w
				})
		auto ret=new CPreprocessedRichText(){
			m_rjobs:rjobs,m_styles:styles,
			m_h_text:fixed2float(y_next),
			m_w_line:w_linef,
			m_scale0:1.f,
		}
		return JS.Return(ret)
	}
	JS_UI["ED_CreateOpHighlights"]=function(JSContext JS){
		ops=JS.Param(0).as(JSObject)
		prt=JS.Param(1).as(CPreprocessedRichText)
		sblock=JS.Param(2).as(string)
		ops_length=ops["length"].as(iptr)
		ccnts=new iptr[ops_length*2]
		for i=0:ops_length-1
			ops_i=ops[i].as(JSObject)
			ccnt0=ops_i["ccnt"].as(iptr)
			ccnt1=ccnt0+sblock[ccnt0:].IndexOf('\n')+1
			if ccnt1<=ccnt0:
				ccnt1=sblock.n
			ccnts[i*2+0]=ccnt0
			ccnts[i*2+1]=ccnt1
		if Platform.BUILD=="debug":
			for i=1:ccnts.n-1
				assert(ccnts[i]>=ccnts[i-1])
		//ignore x
		pccnts=0L
		foreach rj in prt.m_rjobs
			if rj.ccnt0<0:continue
			while pccnts<ccnts.n&&rj.ccnt0>=ccnts[pccnts]:
				//ops[(pccnts>>1)][(pccnts&1)?"x1":"x0"]=rj.x
				ops[(pccnts>>1)][(pccnts&1)?"y1":"y0"]=rj.y
				pccnts++
		while pccnts<ccnts.n:
			//ops[(pccnts>>1)][(pccnts&1)?"x1":"x0"]=0.f
			ops[(pccnts>>1)][(pccnts&1)?"y1":"y0"]=prt.m_h_text
			pccnts++
		return 0
	}
	JS_UI["ED_RenderRichText"]=function(JSContext JS){
		auto prt=JS.Param(0).as(CPreprocessedRichText)
		auto sblock=JS.Param(1).as(string)
		auto x=JS.Param(2).as(float)*g_renderer.m_pixels_per_unit
		auto y=JS.Param(3).as(float)*g_renderer.m_pixels_per_unit
		auto objs=JS.Param(4).as(JSObject)
		if prt.m_scale_cur!=g_renderer.m_pixels_per_unit:
			prt.m_emboldened_fonts=TFont[].NULL
		if !prt.m_emboldened_fonts:
			auto p_styles=prt.m_styles.m_styles
			prt.m_emboldened_fonts=new TFont[p_styles.n]
			for style_i,I in p_styles
				fnt=style_i.font
				fnt.h*=g_renderer.m_pixels_per_unit/prt.m_scale0
				if g_renderer.m_srgb_supported:
					fnt.SmartEmbolden(style_i.color)
				prt.m_emboldened_fonts[I]=fnt
			prt.m_scale_cur=g_renderer.m_pixels_per_unit
		dist_scale=g_renderer.m_pixels_per_unit/prt.m_scale0
		foreach rj in prt.m_rjobs
			auto xi=x+rj.x*dist_scale
			auto yi=y+rj.y*dist_scale
			auto style_i=prt.m_styles.m_styles[rj.style_id]
			auto C=style_i.color
			auto fnt=prt.m_emboldened_fonts[rj.style_id]
			if rj.ccnt0<0:
				if rj.ccnt0==-1:
					g_renderer.DrawChar(fnt,xi,yi,C,int('-'))
				else if rj.ccnt0==-2:
					//object
					RenderRichTextObject(JS,xi,yi,prt.m_w_line,objs,rj.ccnt1)
			else
				for ch in Utf8Chars(sblock[rj.ccnt0:rj.ccnt1-1])
					//coulddo: UNDERLINED,STRIKED_OUT... or strikeout-y
					dx=g_renderer.DrawChar(fnt,xi,yi,C,ch)
					xi+=dx
		return 0
	}
	JS_UI["ED_RichTextCommandChar"]=function(JSContext JS){
		ch=JS.Param(0).as(int)
		return JS.Return(Unicode32ToUtf8([ch]))
	}
	/////////////////////////////
	/*
	JS_UI["GL_EnterBackupFBO"]=function(JSContext JS){
		wnd_w=JS["UI"]["m_gl_curwindow_w"].as(int)
		wnd_h=JS["UI"]["m_gl_curwindow_h"].as(int)
		if !g_rtt_tab_backup||g_rtt_tab_backup.w!=wnd_w||g_rtt_tab_backup.h!=wnd_h:
			fbo_w=wnd_w
			fbo_h=wnd_h
			if g_rtt_tab_backup:
				//fbo_w=max(fbo_w,g_rtt_tab_backup.w)
				//fbo_h=max(fbo_h,g_rtt_tab_backup.h)
				g_rtt_tab_backup.discard()
			if Platform.BUILD=="debug":
				Writeln('creating FBO: ',fbo_w,' ',fbo_h)
			g_rtt_tab_backup=glCreateRenderToTextureContext(GL_RGBA8,fbo_w,fbo_h,0)
		tab_viewport=new int[4]
		glGetIntegerv(GL_VIEWPORT,__pointer(tab_viewport.d));
		pdraw_fbo=new u32[1]
		glGetIntegerv(GL_FRAMEBUFFER_BINDING,__pointer(pdraw_fbo.d))
		glBindFramebuffer(GL_FRAMEBUFFER,g_rtt_tab_backup.m_fbo)
		glViewport(tab_viewport[0],tab_viewport[1],tab_viewport[2],tab_viewport[3])
		JS["UI"]["m_saved_render_fbo"]=pdraw_fbo[0]
		return 0
	}
	myBlitFBO=function(JS,x0,y0,x1,y1,rtt_src,draw_fbo){
		glBindFramebuffer(GL_FRAMEBUFFER,draw_fbo)
		glViewport(x0,y0,x1-x0,y1-y0)
		tech=JS["UI"]["m_blit_framebuffer_tech"].as(GLTechnique)
		if !tech:
			tech=new GLTechnique
			tech.SetFragmentShader("
				void main(){
					gl_FragColor=texture2D(tex0,base+st*size);
				}
			")
			JS["UI"]["m_blit_framebuffer_tech"]=tech
		tech.SetTexture2D("tex0",rtt_src.m_tex)
		tech.SetUniform("base",float2(float(x0),float(y0))/float2(float(rtt_src.w),float(rtt_src.h)))
		tech.SetUniform("size",float2(float(x1-x0),float(y1-y0))/float2(float(rtt_src.w),float(rtt_src.h)))
		glDisable(GL_BLEND)
		tech.DrawScreenQuad()
		glEnable(GL_BLEND)
	}
	JS_UI["GL_LeaveBackupFBO"]=function(JSContext JS){
		tab_viewport=new int[4]
		glGetIntegerv(GL_VIEWPORT,__pointer(tab_viewport.d));
		draw_fbo=JS["UI"]["m_saved_render_fbo"].as(GLuint)
		///////////////
		x0=tab_viewport[0]
		y0=tab_viewport[1]
		x1=x0+tab_viewport[2]
		y1=y0+tab_viewport[3]
		if USE_BLIT_FRAMEBUFFER:
			glBindFramebuffer(GL_READ_FRAMEBUFFER,g_rtt_tab_backup.m_fbo)
			glBindFramebuffer(GL_DRAW_FRAMEBUFFER,draw_fbo)
			glBlitFramebuffer(x0,y0,x1,y1, x0,y0,x1,y1, GL_COLOR_BUFFER_BIT,GL_NEAREST)
			glBindFramebuffer(GL_FRAMEBUFFER,draw_fbo)
		else
			myBlitFBO(JS,x0,y0,x1,y1,g_rtt_tab_backup,draw_fbo)
		return 0;
	}
	JS_UI["GL_RestoreFromBackupFBO"]=function(JSContext JS){
		tab_viewport=new int[4]
		glGetIntegerv(GL_VIEWPORT,__pointer(tab_viewport.d));
		draw_fbo=JS["UI"]["m_saved_render_fbo"].as(int)
		///////////////
		pdraw_fbo=new u32[1]
		glGetIntegerv(GL_FRAMEBUFFER_BINDING,__pointer(pdraw_fbo.d))
		x0=tab_viewport[0]
		y0=tab_viewport[1]
		x1=x0+tab_viewport[2]
		y1=y0+tab_viewport[3]
		if USE_BLIT_FRAMEBUFFER:
			glBindFramebuffer(GL_READ_FRAMEBUFFER,g_rtt_tab_backup.m_fbo)
			glBindFramebuffer(GL_DRAW_FRAMEBUFFER,pdraw_fbo[0])
			glBlitFramebuffer(x0,y0,x1,y1, x0,y0,x1,y1, GL_COLOR_BUFFER_BIT,GL_NEAREST)
			glBindFramebuffer(GL_FRAMEBUFFER,pdraw_fbo[0])
		else
			myBlitFBO(JS,x0,y0,x1,y1,g_rtt_tab_backup,pdraw_fbo[0])
		return 0;
	}
	*/
	JS_UI["ED_DiffUpdateToFile"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		if !ed:return 0
		s_file_name=JS.Param(1).as(string)
		scode_new=System.IO.ReadAll(s_file_name);
		if !scode_new:return 0
		encoding=DetectEncoding(scode_new)
		if encoding!=ENCODING_UTF8&&encoding!=ENCODING_INVALID:
			(s_utf8,s_lingering)=ConvertToUTF8(encoding,scode_new)
			scode_new=s_utf8
		do_real_diff=JS.Param(2).as(int)
		if !do_real_diff:
			ops=new TextBox.detail.TEditop[]
			ops.push(TextBox.detail.TEditop(){
				ccnt:0LL,
				sz:ed.GetTextSize(),
				s:scode_new,
			})
		else
			scode=ed.GetText(0LL,ed.GetTextSize())
			dmp_diff_to_i64_list=__c_function(int,"dmp_diff_to_i64_list","dmp/dmp.h","c_files","dmp/dmp.c")
			dmp_diff_new=__c_function(int,"dmp_diff_new","dmp/dmp.h","c_files","dmp/dmp.c")
			dmp_diff_free=__c_function(int,"dmp_diff_free","dmp/dmp.h","c_files","dmp/dmp.c")
			diff=NULL
			dmp_diff_new(__C(__pointer,"(dmp_diff**)@1",&diff),NULL, scode,scode.n, scode_new,scode_new.n);
			if !diff:return 0
			n=dmp_diff_to_i64_list(diff,NULL)
			rawdiff=new i64[n]
			n=dmp_diff_to_i64_list(diff,rawdiff)
			assert(n==rawdiff.n)
			dmp_diff_free(diff)
			diff=NULL
			ops=new TextBox.detail.TEditop[]
			for i=0:3:rawdiff.n-3
				if rawdiff[i+2]:
					//insert
					ops.push(TextBox.detail.TEditop(){
						ccnt:rawdiff[i+0],
						sz:0LL,
						s:scode_new[iptr(rawdiff[i+2])-scode_new.d:iptr(rawdiff[i+2]+rawdiff[i+1])-scode_new.d-1]
					})
				else
					//delete
					ops.push(TextBox.detail.TEditop(){
						ccnt:rawdiff[i+0],
						sz:rawdiff[i+1],
					})
		if ops.n:
			ed.Edit(ops)
			return JS.Return(1)
		else
			return 0
	}
	JS_UI["ED_DetectBinaryFile"]=function(JSContext JS){
		fn=JS.Param(0).as(string)
		if !fn:return 0
		f=System.IO.OpenFile(fn)
		if !f:return 0
		s=f.Read(65536)
		f.Close()
		if !s||!s.n:return 0
		ret=0
		for ch in s
			chi=i32(u32(u8(ch)))
			if chi<32&&chi!=9&&chi!=10&&chi!=13:
				ret=1
				break
		return JS.Return(ret)
	}
	/////////////////////////////
	g_model_cn=new CEncodingModel(sbox.UIReadAll("assets/bayesian_cn.bin").ConvertToAsBinary(u32))
	g_model_jp=new CEncodingModel(sbox.UIReadAll("assets/bayesian_jp.bin").ConvertToAsBinary(u32))
	g_model_b5=new CEncodingModel(sbox.UIReadAll("assets/bayesian_b5.bin").ConvertToAsBinary(u32))
	g_model_jpgb=new CEncodingModel(sbox.UIReadAll("assets/bayesian_jpgb.bin").ConvertToAsBinary(u32))
	g_model_jp.sjis=1
})
