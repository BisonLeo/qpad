import "system.jc"
import "gui2d.jc"
import "javascript.jc"
import "text-box.jc"
import "tex-like.jc"
import "hunspell.jc"
import "smart-find.jc"
import "code-parser.jc"
import System.Math.*
import System.Algorithm.*
import System.Console.*
import Gui2D.detail.*
import Javascript.*
import TextBox.*
import TextBox.detail.*
import TexLike.*
import SmartFind.*
import CodeParser.*

//text -> i64[]
auto WrapTextSimple(CHyphenator hyp,string sblock, TFont font,i64 w_line)
	styles=new CStyleHolder(){m_styles:[new CStyle(){font:font}],m_enable_ligatures:0}
	ret=new i64[]
	foreach s,I in sblock.TokenizeEx("\n",sblock.TOKENIZE_ALLOW_EMPTY|sblock.TOKENIZE_INCLUDE_SEPARATOR)
		n0=ret.n
		(atoms,eatoms,tail_style_id)=TextToLayoutAtom(hyp,s,0,styles,CEmbededObject[].NULL)
		line_breaks=GreedyLayoutGeneral(atoms,w_line)
		GenerateTextLayout(
			styles,
			s,atoms,eatoms,line_breaks,tail_style_id,
			int(I),w_line,s.EndsWith("\n"),
			function(int style_id, int ccnt0,int ccnt1){
				//char range
				assert(ccnt0>=0&&ccnt1>ccnt0)
				ret.push((i64(ccnt1)<<32)+i64(ccnt0))
				//atom_i=ret.back()
				//value1=int(atom_i>>32)
				//value0=int(atom_i)
				//assert(value0>=0&&value1>value0)
			},
			function(i64 dw,int ccnt){
				//space
				assert(dw>=0LL&&dw==i64(int(dw)))
				ret.push((i64(0x80000000|int(ccnt))<<32)+i64(dw))
				//atom_i=ret.back()
				//value1=int(atom_i>>32)
				//value0=int(atom_i)
				//if value1>=0:
				//	if !(value0>=0&&value1>value0):
				//		Writeln(ccnt,' ',dw)
				//	assert(value0>=0&&value1>value0)
			},
			function(i64 h_up,i64 h_line,int aflag_ccnt){
				//line
				//there is only one style, we know the heights
				assert(aflag_ccnt>=0)
				ret.push((-1LL<<32)+i64(aflag_ccnt))
				//atom_i=ret.back()
				//value1=int(atom_i>>32)
				//value0=int(atom_i)
				//if value1>=0:assert(value0>=0&&value1>value0)
			},
			function(int oid, int ccnt){
				//object
				//do nothing
			})
		if n0<ret.n:
			//shove back real newlines to \n
			high_dword=int(ret[n0]>>32)
			if high_dword==-1:
				ccnt=(int(ret[n0])&ATOM_MASK_CCNT)
				if ccnt>0&&sblock[ccnt-1]=='\n':
					ret[n0]-=1LL
	return ret

/*
or-ing tokens
	<
	<script
failure case:
	a lot of \\ \"
	token ambiguity cross the boundary
	ignore
	---
	an escape char mode
		self-zeroing token eater
	it breaks the tokenization assumption
*/
REAL_TYPE_MOV=0;
REAL_TYPE_XOR=1;
REAL_TYPE_ADD=2;
DEFAULT_WRAP_WIDTH_IN_CHARS=2048LL
GRACEFUL_WORD_SIZE=256
MAX_ALLOWED_INDENTATION=20
MAX_SPECIAL_COLOR_ID_SIZE=iptr(GRACEFUL_WORD_SIZE)

struct TBracketType
	int type
	int[] tok0,tok1

//0+=0 for non-inc
struct TBDFATransition
	i32 m_and
	i32 m_xor
	i16 m_delta
	u16 m_next_state

struct TColorRule
	string color_name
	//int bid
	//int extend_0,extend_1
	int bmask
	int extend_before

struct TKeyword
	string s
	string color_name

class CLanguageDescription
	//int[] m_enabled_from_inside
	int[] m_all_key_states
	int[] m_id_from_key_state
	u8[] m_char_map
	u16[] m_bigchar_dfa
	int m_total_state_size
	int m_context_size
	int m_n_char_types
	int m_n_key_states
	u8[] m_token_lengths
	int m_n_tokens
	//the initial state is always 0
	/////////
	//TBracketType[] m_bracket_types
	TBDFATransition[] m_bracket_dfa
	TColorRule[] m_coloring_rules
	/////////
	string m_default_color_name
	string[] m_word_color_names
	int[] m_word_dfa
	u8[] m_word_char_map
	int m_n_word_char_types
	int[] m_word_dfa_initial_state
	int[] m_word_dfa_initial_state_triggered
	string m_trigger_chars
	/////////
	int m_color_id_spell_check
	/////////
	int[] m_key_decl_color_ids
	int m_kd_color

auto DrawTilde(TFont fnt_tilde,float x0,float x1,float y,int C)
	//just use a glyph - '~' in the icon font!
	//its height is 0.03*h, width is 1*h...
	h_tilde_raw=g_renderer.GetCharacterHeight(fnt_tilde)
	w_tilde=g_renderer.GetCharacterAdvance(fnt_tilde,int('~'))
	for(x=x0;x<x1;x+=w_tilde)
		need_clipping=0
		if x+w_tilde>x1:
			need_clipping=1
			g_renderer.PushCliprect(x,y,x1-x,h_tilde_raw)
		g_renderer.DrawChar(fnt_tilde,x,y,C,int('~'))
		if need_clipping:
			g_renderer.PopCliprect()

HL_DISPLAY_MODE_EMBOLDEN=1
HL_DISPLAY_MODE_TILDE=2
//U_ELLIPSIS=0x2026
struct TEllipsisItem
	float x,y,scale
	int color
struct TOverlayItem
	i64 flatx
	i64 y,delta_x
	string s_text,s_type
	int sel0,sel1
	i64 w_strikeout
struct TTildeItem
	i64 ccnt0,ccnt1
	int color
class CLayouter_programmer
	FLAG_HAS_TAB=1
	FLAG_HAS_ENTER=2
	/////////
	m_wrap_width_in_fp=0LL
	m_tab_width_in_fp=0LL
	m_tab_width=4
	m_wrap_width=0.f
	m_font=TFont()
	m_font_emboldened=TFont()
	m_bgcolor_selection=0xff800000
	m_color_overlay=0xff000000
	//////////////
	m_enable_advanced_wrapping=0
	CHyphenator m_hyp
	//////////////
	__pointer m_spell_checker
	string m_spell_checker_name
	long2[] m_current_frame_spell_errors
	TTildeItem[] m_current_frame_tildes
	float3[] m_current_frame_strikeouts
	int m_temporarily_disable_spell_check
	//////////////
	JSObject m_style
	CLanguageDescription m_lang
	int[] m_cached_colors
	int m_cached_colors_p_word_part
	int m_cached_color_virtual_hyphen
	//////////////
	int[] m_char_width_cache_ascii
	int[int] m_char_width_cache
	int[int] m_char_kerning_cache
	/////////////////
	m_hidden_ranges=new CLocator[]
	i64 m_w_ellipsis
	m_ellipsis_items=new TEllipsisItem[]
	/////////////////
	CFileIndex m_file_index
	/////////////////
	charWidth=function(int ch){
		if u32(ch)<u32(0x80):
			ret=m_char_width_cache_ascii[ch]
			if !ret:
				ret=int(float2fixed(g_renderer.GetCharacterAdvance(m_font,int(ch))))+1
				m_char_width_cache_ascii[ch]=ret
		else
			ret=m_char_width_cache[ch]
			if !ret:
				ret=int(float2fixed(g_renderer.GetCharacterAdvance(m_font,int(ch))))+1
				m_char_width_cache[ch]=ret
		return ret-1
	}
	charKerning=function(int ch0,int ch1){
		if u32(ch0)>=65536u||u32(ch1)>=65536u:return 0
		key=(ch0<<16)+ch1
		ret=m_char_kerning_cache[key]
		if !ret:
			//we can get negative/0/positive, use 0x80000000 as the improbable
			ret=int(float2fixed(g_renderer.GetKerning(m_font,ch0,ch1)))^0x80000000
		return ret^0x80000000
	}
	charHeight=inline(){
		return float2fixed(g_renderer.GetCharacterHeight(m_font))
	}
	/////////////////
	//this thing isn't line-only
	name=function(){return "renderer"}
	stateSize=function(){return 4}
	/////////////////
	isLineOnly=function(){
		return m_enable_advanced_wrapping
	}
	PreprocessBlock=function(CEditableText caller,i64[] a,string s){
		if m_enable_advanced_wrapping:
			//-' '-1LL to avoid OOB values
			return WrapTextSimple(m_hyp,s, m_font,m_wrap_width_in_fp-charWidth(int(' '))-1LL)
		else
			return i64[].NULL
	}
	/////////////////
	//final format: pre-tab width, has-tabbed-ness, tab-enter width, has-enter-ness, post-enter width
	//do not use a render-central design
	AddString=function(i64[] a,i64[] pp,string s_context,string s,iptr ofs){
		w_pre_tab=a[0]
		w_tab_enter=a[1]
		w_post_enter=a[2]
		flags=int(a[3])
		if m_enable_advanced_wrapping:
			//the fancy mode only uses w_pre_tab
			w_pre_tab=_RenderText(MODE_BB,0LL,a,pp,s,ofs, u8[].NULL, 0LL,0LL,0LL,0LL,0.f,0.f,0.f)
			//flags|=FLAG_HAS_ENTER
		else
			foreach ch,I in Utf8Chars(s)
				if I>=ofs:break
				if ch=='\t':
					if !(flags&FLAG_HAS_ENTER):
						if !(flags&FLAG_HAS_TAB):
							flags|=FLAG_HAS_TAB
						else
							w_tab_enter=(w_tab_enter/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
					else
						w_post_enter=(w_post_enter/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
				else if ch=='\n':
					if !(flags&FLAG_HAS_ENTER):
						flags|=FLAG_HAS_ENTER
					else
						w_post_enter=(w_post_enter/m_wrap_width_in_fp+1LL)*m_wrap_width_in_fp
				else if ch!='\r':
					dx=charWidth(ch)
					if !(flags&FLAG_HAS_ENTER):
						if !(flags&FLAG_HAS_TAB):
							w_pre_tab+=dx
						else 
							w_tab_enter+=dx
					else
						w_post_enter+=dx
		a[0]=w_pre_tab
		a[1]=w_tab_enter
		a[2]=w_post_enter
		a[3]=i64(flags)
	}
	Add=function(i64[] a,i64[] b){
		a_w_pre_tab=a[0]
		a_w_tab_enter=a[1]
		a_w_post_enter=a[2]
		a_flags=int(a[3])
		b_w_pre_tab=b[0]
		b_w_tab_enter=b[1]
		b_w_post_enter=b[2]
		b_flags=int(b[3])
		if a_flags&FLAG_HAS_ENTER:
			//a_w_post_enter
			a_w_post_enter+=b_w_pre_tab
			if b_flags&FLAG_HAS_TAB:
				a_w_post_enter=(a_w_post_enter/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
			a_w_post_enter+=b_w_tab_enter
			if b_flags&FLAG_HAS_ENTER:
				a_w_post_enter=(a_w_post_enter/m_wrap_width_in_fp+1LL)*m_wrap_width_in_fp
			a_w_post_enter+=b_w_post_enter
		else if a_flags&FLAG_HAS_TAB:
			a_w_tab_enter+=b_w_pre_tab
			if b_flags&FLAG_HAS_TAB:
				a_w_tab_enter=(a_w_tab_enter/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
			a_w_post_enter+=b_w_tab_enter
			if b_flags&FLAG_HAS_ENTER:
				a_flags|=FLAG_HAS_ENTER
				a_w_post_enter=b_w_post_enter
		else
			a_w_pre_tab+=b_w_pre_tab
			a_flags=b_flags
			a_w_tab_enter=b_w_tab_enter
			a_w_post_enter=b_w_post_enter
		a[0]=a_w_pre_tab
		a[1]=a_w_tab_enter
		a[2]=a_w_post_enter
		a[3]=i64(a_flags)
	}
	GetFlatX=inline(i64[] a){
		w_pre_tab=a[0]
		w_tab_enter=a[1]
		w_post_enter=a[2]
		flags=int(a[3])
		x=w_pre_tab
		if flags&FLAG_HAS_TAB:
			x=(x/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
		x+=w_tab_enter
		if flags&FLAG_HAS_ENTER:
			x=(x/m_wrap_width_in_fp+1LL)*m_wrap_width_in_fp
		x+=w_post_enter
		return x
	}
	XYToX=inline(i64 x,i64 y){
		hc=charHeight()
		return max(min(x,m_wrap_width_in_fp-1LL),0LL)+(y/hc)*m_wrap_width_in_fp
	}
	/////////////////
	//compare known-positive doubles as ints
	Compare=function(CEditableText ed,i64[] a,i64[] b){
		return __C_compare(GetFlatX(a),AddHiddenRanges(ed,b[0],b[1]))
	}
	SeekInBlock=function(CEditableText ed,i64 ccnt_base,i64[] a,i64[] pp,string s,i64[] b){
		if m_enable_advanced_wrapping:
			return iptr(_RenderText(MODE_SEEK,0LL,a,pp,s,s.n, u8[].NULL, b[0],b[1],0LL,0LL,0.f,0.f,0.f))
		//seeked into hidden text?
		x_goal=AddHiddenRanges(ed,b[0],b[1])
		x=GetFlatX(a)
		if b.n>2:
			//hint
			x_last_known=AddHiddenRanges(ed,b[2],b[3])
			ccnt_last_known=b[4]
			if u64(ccnt_last_known-ccnt_base)<u64(s.n):
				p=iptr(ccnt_last_known-ccnt_base)
				x=x_last_known
				foreach ch,I in Utf8Chars(s[p:])
					if x>=x_goal:return I+p
					if ch=='\t':
						x=(x/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
					else if ch=='\n':
						x=(x/m_wrap_width_in_fp+1LL)*m_wrap_width_in_fp
					else if ch!='\r':
						dx=charWidth(ch)
						x+=dx
				return s.n
		foreach ch,I in Utf8Chars(s)
			if x>=x_goal:return I
			if ch=='\t':
				x=(x/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
			else if ch=='\n':
				x=(x/m_wrap_width_in_fp+1LL)*m_wrap_width_in_fp
			else if ch!='\r':
				dx=charWidth(ch)
				x+=dx
		return s.n
	}
	/////////////////
	//long3 m_caret_overlay
	m_overlays=new TOverlayItem[]
	//JSObject m_overlay_obj
	i64 m_caret_offset
	JSObject m_tentative_editops
	TOverlayItem[] m_precomputed_overlays_for_tentative_editops//need to reset in JS
	SetTextStyle=function(JSObject obj){
		m_lang=obj["language"].as(CLanguageDescription)
		m_font=obj["font"].as(TFont)
		m_font_emboldened=obj["font_emboldened"].as(TFont)
		m_char_width_cache_ascii=new int[128]
		m_char_width_cache=new int[int]
		m_char_kerning_cache=new int[int]
		m_tab_width=obj["tab_width"].or(8)
		m_wrap_width=obj["wrap_width"].or(0.f)
		m_tab_width_in_fp=i64(m_tab_width)*charWidth(int(' '))
		if !(m_wrap_width>0.f):
			m_wrap_width_in_fp=DEFAULT_WRAP_WIDTH_IN_CHARS*charWidth(int(' '))
		else
			m_wrap_width_in_fp=(float2fixed(m_wrap_width)/m_tab_width_in_fp)*m_tab_width_in_fp
		obj["displayed_wrap_width"]=fixed2double(m_wrap_width_in_fp)
		////////////
		BeginRender(obj)
		/////////
		m_hyp=obj["hyphenator"].as(CHyphenator)
		m_enable_advanced_wrapping=!!m_hyp
		sname=obj["m_spell_checker"].as(string)
		if sname&&sname.n:
			m_spell_checker=Hunspell.getSpeller(sname)
			if m_spell_checker:
				m_spell_checker_name=sname
	}
	BeginRender=function(JSObject obj){
		if Platform.BUILD=="debug":
			if !m_lang:
				obj.GetContext().evalVoid("UI.DumpCallStack()","<stack>")
		m_cached_colors_p_word_part=m_lang.m_coloring_rules.n+1
		m_cached_colors=new int[m_cached_colors_p_word_part+m_lang.m_word_color_names.n]
		m_cached_colors[0]=obj[m_lang.m_default_color_name].or(0xff000000)
		foreach crule,I in m_lang.m_coloring_rules
			m_cached_colors[I+1]=obj[crule.color_name].or(0xff000000)
		foreach color_name,I in m_lang.m_word_color_names
			m_cached_colors[m_cached_colors_p_word_part+I]=obj[color_name].or(0xff000000)
		m_bgcolor_selection=int(obj["bgcolor_selection"].or(u32(m_bgcolor_selection)))
		m_color_overlay=int(obj["color_overlay"].or(u32(m_color_overlay)))
		m_cached_color_virtual_hyphen=int(obj["color_hyphen"].or(u32(m_cached_color_virtual_hyphen)))
		if m_spell_checker:
			m_current_frame_spell_errors=new long2[]
		m_current_frame_tildes=new TTildeItem[]
		m_current_frame_strikeouts=new float3[]
		m_w_ellipsis=float2fixed(obj["w_ellipsis"].as(float))
		m_ellipsis_items.clear()
		m_file_index=obj["m_file_index"].as(CFileIndex)
	}
	SetCaretOverlay=function(CEditableText caller,i64 x,i64 y,JSObject obj){
		m_overlays.clear()
		//m_overlay_obj=obj
		w_overlayd=0.
		m_caret_offset=0LL
		if obj:
			s=obj["text"].as(string)
			if s:
				w_overlayd=GetStringWidth(m_font,s)
			flatx=XYToX(x,y)
			overlay_sel0=obj["start"].or(0L)
			overlay_sel1=overlay_sel0+obj["length"].or(0L)
			cmap=new iptr[]
			foreach chj,J in Utf8Chars(s)
				cmap.push(J)
			cmap.push(s.n)
			overlay_sel0=min(overlay_sel0,cmap.n-1)
			overlay_sel1=min(overlay_sel1,cmap.n-1)
			x_sel0=0LL
			x_sel1=0LL
			if uptr(overlay_sel0)<uptr(cmap.n)&&uptr(overlay_sel1)<uptr(cmap.n):
				//measuring
				x_sel0=double2fixed(GetStringWidth(m_font,s[:cmap[overlay_sel0]-1]))
				x_sel1=double2fixed(GetStringWidth(m_font,s[:cmap[overlay_sel1]-1]))
				m_caret_offset=max(x_sel0,x_sel1)
			m_overlays.push(TOverlayItem(){
				flatx:flatx,
				y:(flatx+m_wrap_width_in_fp-1LL)/m_wrap_width_in_fp-1LL,
				delta_x:double2fixed(w_overlayd),
				s_text:s,
				s_type:obj["type"].or("IME"),
				sel0:x_sel0,
				sel1:x_sel1,
				w_strikeout:0LL,
			})
		if !m_precomputed_overlays_for_tentative_editops:
			if m_tentative_editops:
				prec_overlays=new TOverlayItem[]
				m_precomputed_overlays_for_tentative_editops=prec_overlays
				n3=m_tentative_editops.length()
				n=n3/3
				ccnts=new i64[]
				for i=0:3:n3-3
					ccnt_i=m_tentative_editops[i+0].as(i64)
					ccnts.push(ccnt_i)
					ccnts.push(ccnt_i+m_tentative_editops[i+1].as(i64))
				//////
				hid=caller.m_handler_registration["renderer"].as(int)
				a=caller.GetStateEnMasse(hid,ccnts)
				flatxs=[GetFlatX(a[i*4:]) for i=0:n*2-1]
				for i=0:n-1
					s_i=m_tentative_editops[i*3+2].as(string)
					if !s_i:s_i=""
					w_overlayd_i=GetStringWidth(m_font,s_i)
					prec_overlays.push(TOverlayItem(){
						flatx:flatxs[i*2+1],
						y:(flatxs[i*2+1]+m_wrap_width_in_fp-1LL)/m_wrap_width_in_fp-1LL,
						delta_x:double2fixed(w_overlayd_i),
						s_text:s_i,
						s_type:"AE",
						sel0:0LL,
						sel1:0LL,
						w_strikeout:flatxs[i*2+1]-flatxs[i*2],
					})
		if m_precomputed_overlays_for_tentative_editops:
			m_overlays.push(m_precomputed_overlays_for_tentative_editops)
		m_overlays.Sortby(inline(item){return item.flatx})
		w_overlay=double2fixed(w_overlayd)
		//m_caret_overlay=long3(,0LL,w_overlay)
		//m_caret_overlay.y=(m_caret_overlay.x+m_wrap_width_in_fp-1LL)/m_wrap_width_in_fp*m_wrap_width_in_fp
		//m_caret_offset=0LL
		return w_overlay
	}
	GetCaretOffset=function(){
		return m_caret_offset
	}
	AddOverlayOffset=function(i64 x0,i64 y){
		flatx0=x0+y*m_wrap_width_in_fp
		p=m_overlays.InlineBisect(inline(a){return a.flatx<=flatx0})
		p--
		x=x0
		for(;p>=0;p--)
			if m_overlays[p].y==y:
				x+=m_overlays[p].delta_x
			else
				break
		return x
	}
	TestOverlay=inline(p_overlay, fnt_scaled,scale,x,projectXY){
		if p_overlay>=m_overlays.n:return 0
		oi=m_overlays[p_overlay]
		if x!=oi.flatx:return 0
		s_overlay=oi.s_text
		auto prj_x=projectXY(x)
		x_sel0=fixed2double(oi.sel0)
		x_sel1=fixed2double(oi.sel1)
		if x_sel0>x_sel1:
			(x_sel0,x_sel1)=(x_sel1,x_sel0)
		if oi.w_strikeout:
			auto dy_strikeout=fnt_scaled.h*fnt_scaled.pfnt.y_baseline_per_height*0.46875f
			y_s0=(x-oi.w_strikeout)/m_wrap_width_in_fp
			y_s1=(x)/m_wrap_width_in_fp
			for yi=y_s0:y_s1
				fx0=max(yi*m_wrap_width_in_fp,x-oi.w_strikeout)
				fx1=min((yi+1)*m_wrap_width_in_fp-1,x)
				auto prj_fx0=projectXY(fx0)
				auto prj_fx1=projectXY(fx1)
				m_current_frame_strikeouts.push(float3(prj_fx0.x,prj_fx0.y,prj_fx1.x-prj_fx0.x))
		//selection - pre-draw the highlight
		if x_sel0<x_sel1:
			g_renderer.DrawRectangle(prj_x.x+float(x_sel0)*scale,prj_x.y,float((x_sel1-x_sel0)*scale),g_renderer.GetCharacterHeight(fnt_scaled), m_bgcolor_selection)
		xo=x
		foreach chj,J in Utf8Chars(s_overlay)
			dx_j=charWidth(chj)
			prj_xo=projectXY(xo)
			//g_renderer.DrawChar(fnt_scaled, prj_xo.x,prj_xo.y,m_color_overlay, chj)
			g_renderer.FastDrawChar(prj_xo.x,prj_xo.y,m_color_overlay, chj)
			xo+=dx_j
		if oi.s_type=="IME":
			y_underline=prj_x.y+fnt_scaled.h*(fnt_scaled.pfnt.y_baseline_per_height+0.02f)
			g_renderer.DrawRectangle(prj_x.x,y_underline,fixed2float(oi.delta_x)*scale,max(fnt_scaled.h*0.05f,1.f), m_color_overlay)
		return 1
	}
	RenderText=function(CEditableText ed,i64 ccnt_base,i64[] a,i64[] pp,string s, u8[] color_ids, i64 scroll_x,i64 scroll_y,i64 clip_w,i64 clip_h,float screen_x,float screen_y,float scale){
		//word coloring - update color_ids
		//get a GRACEFUL_WORD_SIZE context on each side - do it per-char
		word_dfa=m_lang.m_word_dfa
		word_char_map=m_lang.m_word_char_map
		n_word_char_types=m_lang.m_n_word_char_types
		color_id_spell_check=m_lang.m_color_id_spell_check
		key_decl_color_ids=m_lang.m_key_decl_color_ids
		kd_color=m_lang.m_kd_color
		//start from word_ccnt0, do per-char enum until we go out of block
		word_ccnt0=ccnt_base
		budget=GRACEFUL_WORD_SIZE
		foreach ch,I in ed.enumUtf8Backward(ccnt_base)
			if !isWordChar(ch):break
			word_ccnt0=I
			budget--
			if budget<0:break
		ccnt_block_end=ccnt_base+i64(s.n)
		ch_before_word=ed.GetUtf8CharNeighborhood(word_ccnt0)[0]
		trigger_chars=m_lang.m_trigger_chars
		word_ccnt0_bak=word_ccnt0-1
		s_word=new string
		file_index=m_file_index
		if file_index:
			BuildColorTable(file_index)
			color_table=file_index.m_temp_color_table
		else
			color_table=int[int].NULL
		s_temp_getid=new char[MAX_SPECIAL_COLOR_ID_SIZE]
		for(;;)
			//Writeln(word_ccnt0)
			ch_first=0
			foreach ch,I,I2 in ed.enumUtf8Forward(word_ccnt0)
				word_ccnt0=I
				if isWordChar(ch):
					ch_first=ch
					break
				ch_before_word=ch
				word_ccnt0=I2
				if word_ccnt0>=ccnt_block_end:
					break
			if word_ccnt0>=ccnt_block_end:break
			//Writeln(word_ccnt0,' ',word_ccnt0_bak)
			if word_ccnt0<=word_ccnt0_bak:
				//blocked by invalid utf8
				break
			word_ccnt0_bak=word_ccnt0
			//Writeln(word_ccnt0,' ',ccnt_block_end,' ',s[word_ccnt0])
			//now we know we have a word
			//non-word chars should immediately terminate the DFA
			color_id=0
			cid=color_ids[max(iptr(word_ccnt0-ccnt_base),0L)]
			st=m_lang.m_word_dfa_initial_state[cid]
			if trigger_chars&&ch_before_word<128&&trigger_chars.IndexOf(char(ch_before_word))>=0:
				//it's immediately after the trigger char, use the alternative initial state
				st=m_lang.m_word_dfa_initial_state_triggered[cid]
			if st>=0:
				budget=GRACEFUL_WORD_SIZE
				foreach ch,I in ed.enumCharsForward(word_ccnt0)//it's 8-bit here, not UTF8!
					//and ch is signed
					//non-word chars would inevitably terminate the DFA
					chi=int(u8(ch))
					st=word_dfa[st+int(word_char_map[chi])]
					if st<0:break
					budget--
					if budget<0:break
			if st>=0:st=word_dfa[st+1]
			//Writeln(word_ccnt0,' ',cid,' ',st)
			if color_table&&st==~kd_color&&key_decl_color_ids:
				//parser-based highlighting
				s_temp_getid.n=MAX_SPECIAL_COLOR_ID_SIZE
				p_s_temp_getid=0L
				foreach ch,I in ed.enumCharsForward(word_ccnt0)//it's 8-bit here, not UTF8!
					if p_s_temp_getid>=MAX_SPECIAL_COLOR_ID_SIZE:break
					chi=int(u8(ch))
					if !CharSet.has(CharSet.idbody,chi):break
					s_temp_getid[p_s_temp_getid++]=char(ch)
				if p_s_temp_getid&&!CharSet.has(CharSet.idhead,int(u8(s_temp_getid[0]))):
					p_s_temp_getid=0L
				if p_s_temp_getid:
					s_temp_getid.n=p_s_temp_getid
					id_temp=getid(s_temp_getid)
					key_decl_type=color_table[id_temp]-1
					//Writeln('>>> ',s_temp_getid,' ',id_temp,' ',key_decl_type)
					if key_decl_type>=0:
						st=~key_decl_color_ids[key_decl_type]
			color_id=~st
			need_spell_check=0
			if m_spell_checker&&!m_temporarily_disable_spell_check:
				ccnt_before_word=word_ccnt0
				if color_id==color_id_spell_check:
					s_word.n=0
					need_spell_check=1
			is_number=(u32(ch_first-int('0'))<10u)
			//. inside numbers
			foreach ch,I,I2 in ed.enumUtf8Forward(word_ccnt0)
				word_ccnt0=I
				if isWordChar(ch)||is_number&&ch=='.':
					ofs=iptr(word_ccnt0-ccnt_base)
					if uptr(ofs)<uptr(color_ids.n):
						if color_id>0:
							color_ids[ofs]=m_cached_colors_p_word_part+color_id
					if need_spell_check:
						if ch>=65536:
							//surrogate pair - 2nd
							s_word.push(char(((ch>>18)&0xf)+0xf0))
							s_word.push(char(0x80+((ch>>12)&63)))
							s_word.push(char(0x80+((ch>>6)&63)))
							s_word.push(char(0x80+(ch&63)))
						else if ch>=2048:
							s_word.push(char(((ch>>12)&0xf)+0xe0))
							s_word.push(char(0x80+((ch>>6)&63)))
							s_word.push(char(0x80+(ch&63)))
						else if ch>=128:
							s_word.push(char((ch>>6)+0xc0))
							s_word.push(char(0x80+(ch&63)))
						else
							s_word.push(char(ch))
				else
					break
				ch_before_word=ch
				word_ccnt0=I2
				if word_ccnt0>=ccnt_block_end:
					break
			if need_spell_check:
				//spell check
				if s_word.n>1:
					s_word.push(char(0))
					if !Hunspell.spell(m_spell_checker,s_word):
						is_bad=1
						if s_word[0]>='A'&&s_word[0]<='Z':
							s_word[0]|=i8(0x20)
							if Hunspell.spell(m_spell_checker,s_word):
								is_bad=0
						if is_bad:
							//not a word
							m_current_frame_spell_errors.push(long2(ccnt_before_word,word_ccnt0))
		///////
		fnt_scaled=m_font
		fnt_scaled.h*=scale
		//smart emboldening for SRGB
		//coulddo: per-color emboldening
		if g_renderer.m_srgb_supported:
			fnt_scaled.SmartEmbolden(0xff000000)
		hc=charHeight()
		x=GetFlatX(a)
		tab_width=m_tab_width_in_fp
		wrap_width=m_wrap_width_in_fp
		iy=x/wrap_width
		ix=x-iy*wrap_width
		dx_extra=0LL
		dy_extra=0LL
		p_overlay=m_overlays.InlineBisect(inline(a){return a.flatx<x})
		inline projectXY(i64 x0)
			auto y=x0/wrap_width
			auto x=x0-y*wrap_width+dx_extra
			y=(y+dy_extra)*hc
			return float2(fixed2float(x-scroll_x)*scale+screen_x,fixed2float(y-scroll_y)*scale+screen_y)
		inline testOverlay()
			if TestOverlay(p_overlay, fnt_scaled,scale,x,projectXY):
				dx_extra+=m_overlays[p_overlay].delta_x
				p_overlay++
			//if m_overlay_obj&&x==m_caret_overlay.x:
			//	DrawOverlay(fnt_scaled,scale,x,projectXY)
			//	dx_extra+=m_caret_overlay.z
		x_right_clip=scroll_x+clip_w
		g_renderer.SetFastDrawCharFont(fnt_scaled)
		if m_enable_advanced_wrapping:
			//we won't need x_right_clip here anyway
			_RenderText(MODE_RENDER,ccnt_base,a,pp,s,s.n, color_ids, scroll_x,scroll_y,clip_w,clip_h,screen_x,screen_y,scale)
			return 
		//the \t\n ignorant hiding
		HideChars(ed,ccnt_base,color_ids)
		enable_hidden=m_enable_hidden
		//it's OK to have a negative dx_extra
		//maintain x normally
		I_query_valid_point=-1LL
		if enable_hidden:
			//query at the first non-hidden char
			if !m_hidden_ranges_prepared:
				PrepareHiddenRanges(ed)
			p=m_hidden_ccnts.Bisect(function(i64 a){return a<=ccnt_base})
			if p<m_hidden_ccnts.n:
				if p&1:
					I_query_valid_point=m_hidden_ccnts[p]-ccnt_base
			///////////
			(ix_visual,iy_visual)=SubHiddenRanges(ed,x)
			dx_extra=ix_visual-ix
			dy_extra=iy_visual-iy
		//if x>m_caret_overlay.x&&x<m_caret_overlay.y:
		//	x+=m_caret_overlay.z
		ix_with_overlay=AddOverlayOffset(ix,iy)
		dx_extra+=ix_with_overlay-ix
		for ch,I in Utf8Chars(s)
			if I==I_query_valid_point:
				//the head query was invalid, reset the stuff
				(ix_visual,iy_visual)=SubHiddenRanges(ed,x)
				dx_extra=ix_visual-ix
				dy_extra=iy_visual-iy
			cidi=color_ids[I]
			if cidi!=u8(255):
				testOverlay()
			//if ccnt_base+I>=980&&ccnt_base+I<=990:
			//	Writeln('  ',ccnt_base+I,' ',dx_extra,' ',dy_extra,' ',cidi,' ',ch)
			if ch=='\r':
				//nothing
			else if ch=='\n':
				if cidi==u8(255):
					dy_extra--
					dx_extra+=ix
				else
					dx_extra=0LL
				x=(x/wrap_width+1LL)*wrap_width
				iy=x/wrap_width
				ix=x-iy*wrap_width
				if (iy+dy_extra)*hc-scroll_y>=clip_h:break
			else if ch==' ':
				dx_i=charWidth(ch)
				x+=dx_i
				ix+=dx_i
				if cidi==u8(255):
					dx_extra-=dx_i
				if ix>=wrap_width:
					if cidi==u8(255):
						dy_extra--
						dx_extra+=ix
					else
						dx_extra=0LL
					ix-=wrap_width
					iy++
			else if ch=='\t':
				if cidi==u8(255):
					dx_extra+=x
					x=(x/tab_width+1LL)*tab_width
					dx_extra-=x
				else
					x=(x/tab_width+1LL)*tab_width
				iy=x/wrap_width
				ix=x-iy*wrap_width
			else
				dx_i=charWidth(ch)
				if cidi!=u8(255):
					if ix+dx_extra<x_right_clip:
						prj_x=float2(fixed2float(ix+dx_extra-scroll_x)*scale+screen_x,fixed2float((iy+dy_extra)*hc-scroll_y)*scale+screen_y)
						//g_renderer.DrawChar(fnt_scaled, prj_x.x,prj_x.y,m_cached_colors[color_ids[I]], ch)
						color=m_cached_colors[int(cidi)&127]
						if !enable_hidden&&(int(cidi)&128):
							color&=0x55ffffff
						g_renderer.FastDrawChar(prj_x.x,prj_x.y,color, ch)
				else
					dx_extra-=dx_i
				x+=dx_i
				ix+=dx_i
				if ix>=wrap_width:
					if cidi==u8(255):
						dy_extra--
						dx_extra+=ix
					else
						dx_extra=0LL
					ix-=wrap_width
					iy++
					if (iy+dy_extra)*hc-scroll_y>=clip_h:break
			if (int(cidi)&128)&&enable_hidden:
				if cidi!=u8(255):
					cidi&=u8(127)
					//dx_i=charWidth(U_ELLIPSIS)
					dx_i=m_w_ellipsis
					if ix<x_right_clip:
						//grey it out to mark it as "hidden"
						prj_x=float2(fixed2float(ix+dx_extra-scroll_x)*scale+screen_x,fixed2float((iy+dy_extra)*hc-scroll_y)*scale+screen_y)
						//g_renderer.FastDrawChar(prj_x.x,prj_x.y,m_cached_colors[cidi]&0x55ffffff, U_ELLIPSIS)
						m_ellipsis_items.push(TEllipsisItem(){x:prj_x.x,y:prj_x.y,scale:scale,color:m_cached_colors[cidi]})
					dx_extra+=dx_i
		//if ccnt_base+s.n>=980&&ccnt_base+s.n<=990:
		//	Writeln('      ',ccnt_base+s.n,' ',dx_extra,' ',dy_extra)
		testOverlay()
	}
	EndRender=function(JSObject obj,CEditableText ed, i64 scroll_x,i64 scroll_y,i64 clip_w,i64 clip_h,float screen_x,float screen_y,float scale){
		if m_current_frame_spell_errors:
			C_spell_error=obj["color_tilde_spell_error"].as(int)
			m_current_frame_spell_errors.Sort()
			foreach se in m_current_frame_spell_errors
				m_current_frame_tildes.push(TTildeItem(){ccnt0:se.x,ccnt1:se.y,color:C_spell_error})
		if m_current_frame_tildes.n:
			//tilde for spell checks / build errors
			spell_error_ccnts=new i64[m_current_frame_tildes.n*2]
			for i=0:m_current_frame_tildes.n-1
				spell_error_ccnts[i*2+0]=m_current_frame_tildes[i].ccnt0
				spell_error_ccnts[i*2+1]=m_current_frame_tildes[i].ccnt1
			spell_error_ccnts_idx=[i for i=0:spell_error_ccnts.n-1]
			spell_error_ccnts_idx.Sortby(inline(a){return spell_error_ccnts[a]})
			spell_error_ccnts=[spell_error_ccnts[id] foreach id in spell_error_ccnts_idx]
			xys_sorted=ed.GetXYEnMasse(spell_error_ccnts)
			xys=new i64[xys_sorted.n]
			foreach id,I in spell_error_ccnts_idx
				xys[id*2+0]=xys_sorted[I*2+0]
				xys[id*2+1]=xys_sorted[I*2+1]
			dy_baseline=(g_renderer.GetFontBaseline(m_font)+0.04f*m_font.h)*scale
			fnt_tilde0=obj["font_tilde"].as(TFont)
			fnt_tilde0.h=m_font.h*scale
			inline xyToFloat(x,y)
				return float2(fixed2float(x-scroll_x)*scale+screen_x,fixed2float(y-scroll_y)*scale+screen_y)
			wf=fixed2float(clip_w)
			hcf=g_renderer.GetCharacterHeight(m_font)*scale
			for i=0:4:xys.n-4
				C_tilde=m_current_frame_tildes[i>>2].color
				fnt_tilde=fnt_tilde0
				fnt_tilde.SmartEmbolden(C_tilde)
				xy0=xyToFloat(xys[i+0],xys[i+1])
				xy1=xyToFloat(xys[i+2],xys[i+3])
				if xy0.y==xy1.y:
					DrawTilde(fnt_tilde,xy0.x,xy1.x,xy0.y+dy_baseline, C_tilde)
				else
					//draw 3 rects, we have a cliprect, don't worry
					DrawTilde(fnt_tilde,xy0.x,max(screen_x+wf*scale,xy0.x),xy0.y+dy_baseline, C_tilde)
					//per-line draw...
					for(y=xy0.y+hcf;y<xy1.y-hcf*0.5f;y+=hcf)
						DrawTilde(fnt_tilde,screen_x,screen_x+wf*scale,y+dy_baseline, C_tilde)
					DrawTilde(fnt_tilde,screen_x,max(xy1.x,screen_x),xy1.y+dy_baseline, C_tilde)
			//m_current_frame_spell_errors=long2[].NULL
		else
			//fnt_scaled=m_font
			//fnt_scaled.h*=scale
			if m_enable_hidden:
				if !m_hidden_ranges_prepared:
					PrepareHiddenRanges(ed)
				if m_hidden_ccnts.n&&m_hidden_ccnts[0]==0LL:
					//draw ... at the zeroth text, if it's visible
					//g_renderer.DrawChar(fnt_scaled, fixed2float(-scroll_x)*scale+screen_x,fixed2float(-scroll_y)+screen_y,
					//	m_cached_colors[0], U_ELLIPSIS)
					m_ellipsis_items.push(TEllipsisItem(){
							x:fixed2float(-scroll_x)*scale+screen_x,
							y:fixed2float(-scroll_y)+screen_y,
							scale:scale,color:m_cached_colors[0]})
				js_callback=obj["DrawEllipsis"].as(JSObject)
				foreach ei in m_ellipsis_items
					js_callback.CallAsMethod(int,obj,ei.x,ei.y,ei.scale,ei.color)
		//draw strikeouts
		if m_current_frame_strikeouts.n:
			C_strikeout=obj["color_strikeout"].as(int)
			fnt_scaled=m_font
			fnt_scaled.h*=scale
			hc=g_renderer.GetCharacterHeight(fnt_scaled)
			h_strikeout=hc*0.1f
			foreach job in m_current_frame_strikeouts
				g_renderer.DrawRectangle(job.x,job.y+(hc-h_strikeout)*0.5f,job.z,h_strikeout,C_strikeout)
		////////////
		m_file_index=CFileIndex.NULL
	}
	DrawEnhancedHighlight=function(JSObject obj,CEditableText ed,CHLRange hl, i64 scroll_x,i64 scroll_y,i64 clip_w,i64 clip_h,float screen_x,float screen_y,float scale){
		hid=ed.m_handler_registration["renderer"].as(int)
		fnt_bold_scaled=m_font_emboldened
		fnt_bold_scaled.h*=scale
		hc=charHeight()
		////////
		ccnt0=hl.p0.ccnt
		ccnt1=hl.p1.ccnt
		mode=int(hl.display_mode)
		if mode==HL_DISPLAY_MODE_EMBOLDEN:
			//only embolden a single char
			ch_prev=ed.GetUtf8CharNeighborhood(ccnt0)[0]
			s_embolden=ed.GetText(ccnt0,ccnt1-ccnt0)
			wrap_width=m_wrap_width_in_fp
			x=GetFlatX(ed.GetStateAt(hid,ccnt0))
			foreach ch in Utf8Chars(s_embolden)
				iy=x/wrap_width
				ix=x-iy*wrap_width
				ix_with_overlay=AddOverlayOffset(ix,iy)
				dx_overlay=ix_with_overlay-ix
				(ix,iy)=SubHiddenRanges(ed,x)
				ix+=dx_overlay
				prj_x=float2(fixed2float(ix-scroll_x)*scale+screen_x,fixed2float(iy*hc-scroll_y)*scale+screen_y)
				g_renderer.DrawChar(fnt_bold_scaled, prj_x.x,prj_x.y,hl.color, ch)
				dx_i=charWidth(ch)
				x+=dx_i
				if m_enable_advanced_wrapping:
					x+=charKerning(ch_prev,ch)
					ch_prev=ch
		else if mode==HL_DISPLAY_MODE_TILDE:
			m_current_frame_tildes.push(TTildeItem(){ccnt0:ccnt0,ccnt1:ccnt1,color:hl.color})
	}
	GetCharacterHeightAt=function(i64 ccnt_base,i64[] a,i64[] pp,string s,iptr ofs){
		return charHeight()
	}
	GetDefaultFont=function(){
		return m_font
	}
	GetXYFromState=function(CEditableText ed,i64[] a){
		(x,y)=SubHiddenRanges(ed,GetFlatX(a))
		y*=charHeight()
		return long2(x,y)
	}
	IsAtLineWrap=function(i64[] a,i64[] pp,string s,iptr ofs){
		if m_enable_advanced_wrapping:
			foreach atom_i,I in pp[1:]
				high_dword=int(atom_i>>32)
				if high_dword==-1:
					ccnt=(int(atom_i)&ATOM_MASK_CCNT)
					if ccnt==ofs&&(ofs>=s.n||s[ofs]!='\n'):
						return 1
					if ccnt>ofs:break
		else
			//not \n and divides m_wrap_width_in_fp
			a2=new(a)
			AddString(a2,pp,new string,s,ofs)
			x0=GetFlatX(a2)
			//we could have \n in the block above... and the test is done outside
			if !(x0%m_wrap_width_in_fp):
				//if ofs&&s[ofs-1]!='\n':
				return -1
		return 0
	}
	//////////////////////////////
	JS_AddWord=function(JSContext JS){
		if !m_spell_checker:return 0
		s_word=JS.Param(0).as(string)
		if !s_word:return 0
		Hunspell.addWord(m_spell_checker,m_spell_checker_name,s_word)
		return JS.Return(1)
	}
	string[] m_cached_suggestion
	string m_cached_suggestion_word
	JS_Suggest=function(JSContext JS){
		if !m_spell_checker:return 0
		ed=JS.Param(0).as(CEditableText)
		ccnt=JS.Param(1).as(i64)
		p=m_current_frame_spell_errors.Bisect(function(long2 a){return a.y<=ccnt})
		if p<m_current_frame_spell_errors.n:
			word_pos=m_current_frame_spell_errors[p]
			if ccnt>=word_pos.x&&ccnt<word_pos.y:
				s_word=ed.GetText(word_pos.x,word_pos.y-word_pos.x)
				if m_cached_suggestion_word&&m_cached_suggestion_word==s_word:
					suggestions=m_cached_suggestion
				else
					suggestions=Hunspell.suggest(m_spell_checker,s_word)
					m_cached_suggestion=suggestions
					m_cached_suggestion_word=s_word
				ret=JS.New()
				ret["suggestions"]=suggestions
				ret["s_prefix"]=s_word
				ret["ccnt0"]=word_pos.x
				return JS.Return(ret)
		return 0
	}
	//////////////////////////////
	MODE_BB=0
	MODE_SEEK=1
	MODE_RENDER=2
	_RenderText=function(int mode,i64 ccnt_base,i64[] a,i64[] pp,string s,iptr ofs0, u8[] color_ids, i64 scroll_x,i64 scroll_y,i64 clip_w,i64 clip_h,float screen_x,float screen_y,float scale){
		//use flat x
		hc=charHeight()
		wrap_width=m_wrap_width_in_fp
		ofs=ofs0
		inline projectX(i64 x)
			return fixed2float(x-scroll_x)*scale+screen_x
		inline projectY(i64 y)
			return fixed2float(y*hc-scroll_y)*scale+screen_y
		//inline projectXY(i64 x0)
		//	auto y=x0/wrap_width
		//	auto x=x0-y*wrap_width
		//	y*=hc
		//	return float2(fixed2float(x-scroll_x)*scale+screen_x,fixed2float(y-scroll_y)*scale+screen_y)
		//re-create the atoms, convert string, then render
		flat_x=a[0]
		y=flat_x/wrap_width
		x=flat_x-y*wrap_width
		x=AddOverlayOffset(x,y)
		p_overlay=m_overlays.InlineBisect(inline(a){return a.flatx<flat_x})
		//if flat_x>m_caret_overlay.x&&flat_x<m_caret_overlay.y:
		//	//it's an abuse of the separate x/y: we must avoid wrapping
		//	x+=m_caret_overlay.z
		//y_overlay=m_caret_overlay.x/wrap_width
		//x_overlay=m_caret_overlay.x-y_overlay*wrap_width
		//////////////////////////////////
		newline_flags=0
		y_baseline=float2fixed(g_renderer.GetFontBaseline(m_font))
		h_line=hc
		fnt_scaled=TFont()
		dy_baseline=0LL
		ch32_prev=int('\n')
		color=m_cached_colors[0]
		if mode==MODE_RENDER:
			fnt_scaled=m_font
			fnt_scaled.h*=scale
			//smart emboldening for SRGB - it has to be done *after* the scale
			if g_renderer.m_srgb_supported:
				fnt_scaled.SmartEmbolden(0xff000000)
		OfsCheck=__inline_loop_body(ccnt){
			if mode==MODE_BB&&h_line:
				//never return before the first newline
				if ccnt>=ofs:return flat_x
		}
		SeekCheck=__inline_loop_body(ccnt){
			if mode==MODE_SEEK:
				auto y_real=y*hc
				if y_real>scroll_y||scroll_y>=y_real&&scroll_y<y_real+h_line&&x>scroll_x:
					return i64(ccnt)
		}
		inline projectXY(i64 x0)
			//DO NOT WRAP DURING DRAWOVERLAY!
			auto x=x0-y*wrap_width
			return float2(fixed2float(x-scroll_x)*scale+screen_x,fixed2float(y*hc-scroll_y)*scale+screen_y)
		myDrawChar=function(int ch32){
			if TestOverlay(p_overlay, fnt_scaled,scale,flat_x,projectXY):
				x+=m_overlays[p_overlay].delta_x
				p_overlay++
			//if m_overlay_obj&&x==x_overlay&&y==y_overlay:
			//	flat_x=y*wrap_width+x
			//	DrawOverlay(fnt_scaled,scale,flat_x,projectXY)
			//	x+=m_caret_overlay.z
			if ch32!=int(' '):
				dy_flags=0LL
				g_renderer.FastDrawChar(projectX(x),projectY(y+dy_baseline+dy_flags),color, ch32)
		}
		NewlineCheck=inline(){
			if mode==MODE_RENDER:myDrawChar(int(' '))
			if newline_flags:
				if mode==MODE_RENDER&&(newline_flags&ATOM_FLAG_HYPHEN):
					color=m_cached_color_virtual_hyphen
					myDrawChar(int('-'))
				flat_x-=x
				flat_x+=wrap_width
				x=0LL
				y++
		}
		//skip to the line
		i_start=0L
		if mode==MODE_BB:
			for i=0L:pp.n-1
				if int(pp[i]>>32)==-1:
					//found a line
					value0=int(pp[i])
					if (value0&ATOM_MASK_CCNT)>=ofs:break
					i_start=i+1
					NewlineCheck()
					newline_flags=(value0&(ATOM_FLAG_NEWLINE|ATOM_FLAG_HYPHEN))
		else if mode==MODE_SEEK:
			for i=0L:pp.n-1
				if int(pp[i]>>32)==-1:
					//found a line
					value0=int(pp[i])
					NewlineCheck()
					auto y_real=y*hc
					if y_real>scroll_y||scroll_y>=y_real&&scroll_y<y_real+h_line&&x>scroll_x:
						y--
						break
					i_start=i+1
					newline_flags=(value0&(ATOM_FLAG_NEWLINE|ATOM_FLAG_HYPHEN))
		foreach atom_i in pp[i_start:]
			value1=int(atom_i>>32)
			value0=int(atom_i)
			if value1==-1:
				//line start
				OfsCheck(value0&ATOM_MASK_CCNT)
				SeekCheck(value0&ATOM_MASK_CCNT)
				NewlineCheck()
				if mode==MODE_RENDER:
					if y*hc-scroll_y>=clip_h:break
				newline_flags=(value0&(ATOM_FLAG_NEWLINE|ATOM_FLAG_HYPHEN))
				ch32_prev=int('\n')
				if !ofs:
					//re-check for block-head case
					if mode==MODE_SEEK:
						return i64(value0)
					else
						//if mode==MODE_BB:
						return flat_x
			else if value1&0x80000000:
				//space
				if mode==MODE_RENDER:
					if TestOverlay(p_overlay, fnt_scaled,scale,flat_x,projectXY):
						x+=m_overlays[p_overlay].delta_x
						p_overlay++
				value1&=0x7fffffff
				OfsCheck(value1)
				x+=i64(value0)
				flat_x+=i64(value0)
				SeekCheck(value1)
				ch32_prev=int(' ')
			else
				//Writeln(value0,' ',value1)
				assert(value0>=0&&value1>value0)
				//ignore RTL reversal here - conceptually it goes LTR, and we just flip it "visually"
				//and precompute the ranges
				//arabic transformations - in the recursion
				__inline_loop_body TranslateArabic(iptr ccnt0,string s_part)
					auto su32=[int2(ch,int(ccnt0+I)) foreach ch,I in Utf8Chars(s_part)]
					for J=0:su32.n-1
						ch32=su32[J].x
						if isArabic(ch32):
							prev_arabic=(J>0&&isArabic(su32[J-1].x))
							next_arabic=(J<su32.n-1&&isArabic(su32[J+1].x))
							ch32=g_arabic_table[(ch32-0x600)*4+next_arabic*2+prev_arabic]
						//ch32
						if ch32=='\t':ch32=int(' ')
						dx_temp=charKerning(ch32_prev,ch32)
						x+=dx_temp
						flat_x+=dx_temp
						OfsCheck(su32[J].y)
						if mode==MODE_RENDER:
							if ch32!=' '&&ch32!='\r'&&ch32!='\n':
								color=m_cached_colors[int(color_ids[su32[J].y])]
								myDrawChar(ch32)
							else
								if TestOverlay(p_overlay, fnt_scaled,scale,flat_x,projectXY):
									x+=m_overlays[p_overlay].delta_x
									p_overlay++
						dx_temp=charWidth(ch32)
						x+=dx_temp
						flat_x+=dx_temp
						ch32_prev=ch32
						SeekCheck(su32[J].y)
				//__inline_loop_body AddLigature(iptr ccnt0,iptr nc,string s_ligature)
				//	ch32=0
				//	foreach ch in Utf8Chars(s_ligature)
				//		ch32=ch
				//		break
				//	x0=x
				//	x+=float2fixed(g_renderer.GetKerning(m_font,ch32_prev,ch32))
				//	auto dx=charWidth(ch32)
				//	if mode==MODE_RENDER:
				//		myDrawChar(ch32)
				//	else if mode==MODE_SEEK:
				//		for j=0:nc-1
				//			xj=x+dx*i64(j+1)/i64(nc)
				//			if y>scroll_y||scroll_y>=y&&scroll_y<y+h_line&&xj>=scroll_x:
				//				return i64(ccnt0+j)
				//	else if mode==MODE_BB:
				//		for j=0:nc-1
				//			if ccnt0+j>=ofs:return x+dx*i64(j)/i64(nc)+y*wrap_width
				//	x+=dx
				//	ch32_prev=ch32
				if mode!=MODE_RENDER||y*hc+hc>scroll_y:
					spart=s[value0:value1-1]
					//ligatures=m_styles[current_style_id].ligatures
					//ligature_poses=spart.FindAll(ligatures)
					//p_last=0L
					//for i=0:2:ligature_poses.n-2
					//	p=ligature_poses[i]
					//	id=ligature_poses[i+1]
					//	if p_last<p:
					//		TranslateArabic(value0+p_last,spart[p_last:p-1])
					//	p_last=p+ligatures[id*2+0].n
					//	AddLigature(value0+p,p_last-p,ligatures[id*2+1])
					//if p_last<spart.n:
					//	TranslateArabic(value0+p_last,spart[p_last:])
					TranslateArabic(value0,spart)
		NewlineCheck()
		if mode==MODE_SEEK:
			return i64(s.n)
		else
			return flat_x
	}
	///////////////////////
	//call onchange in js
	m_hidden_ranges_prepared=0
	long4[] m_hidden_dx_add
	long4[] m_hidden_dx_sub
	i64[] m_hidden_ccnts
	m_enable_hidden=1
	PrepareHiddenRanges=function(CEditableText ed){
		//they must be x-addressible
		m_hidden_ranges_prepared=1
		raw_ccnts=[loc.ccnt*2LL+i64(I&1) foreach loc,I in m_hidden_ranges]
		ccnts=new i64[]
		raw_ccnts.Sort()
		//sort and merge
		cvg=0
		foreach e in raw_ccnts
			if e&1:
				cvg--
				if !cvg:
					if ccnts.back()==(e>>1):
						ccnts.pop()
					else
						ccnts.push(e>>1)
			else
				if !cvg:
					ccnts.push(e>>1)
				cvg++
		assert(!(ccnts.n&1))
		hid=ed.m_handler_registration["renderer"].as(int)
		m_enable_hidden=0
		a=ed.GetStateEnMasse(hid,ccnts)
		m_enable_hidden=1
		all_x=[GetFlatX(a[i:]) for i=0:4:a.n-4]
		dx_add=new long4[all_x.n>>1]
		dx_sub=new long4[all_x.n>>1]
		m_hidden_dx_add=dx_add
		m_hidden_dx_sub=dx_sub
		m_hidden_ccnts=ccnts
		w_hidden=m_w_ellipsis//charWidth(U_ELLIPSIS)
		x_new_cur=0LL;y_new_cur=0LL;flatx_ori_cur=0LL
		wrap_width=m_wrap_width_in_fp
		for i=0:2:all_x.n-2
			y_ori_cur=flatx_ori_cur/wrap_width
			if flatx_ori_cur<all_x[i]:
				//honor and only honor the *original* newlines
				y_ori_next=all_x[i]/wrap_width
				if y_ori_next>y_ori_cur:
					y_new_cur+=y_ori_next-y_ori_cur
					x_new_cur=all_x[i]-y_ori_next*wrap_width
				else
					x_new_cur+=(all_x[i]-flatx_ori_cur)
			x_new_cur+=w_hidden
			flatx_ori_cur=all_x[i+1]
			dx=x_new_cur-(flatx_ori_cur-flatx_ori_cur/wrap_width*wrap_width)
			//assert(dx>=0LL)
			//this is just dy
			dfx=(all_x[i+1]/wrap_width-y_new_cur)*wrap_width
			assert(dfx>=0LL)
			////////////
			dx_add[i>>1]=long4(x_new_cur,y_new_cur,dx,dfx)
			dx_sub[i>>1]=long4(all_x[i],all_x[i+1],dx,dfx)
	}
	AddHiddenRanges=function(CEditableText ed,i64 x,i64 y){
		//it's not necessarily an 'add'
		//test: are we on the last line? same line as last hidden should be enough
		//then again, we can't easily get flat X for the bsearch - precompute needs to be in xy pairs
		if !m_enable_hidden:return XYToX(x,y)
		if !m_hidden_ranges_prepared:
			PrepareHiddenRanges(ed)
		hc=charHeight()
		y_real=y/hc
		p=m_hidden_dx_add.Bisect(function(long4 a){return a.y<y_real||a.y==y_real&&a.x<=x})-1L
		if p>=0:
			dxitem=m_hidden_dx_add[p]
			x_real=x
			if y_real==dxitem.y:
				x_real-=dxitem.z
			return max(min(x_real,m_wrap_width_in_fp-1LL),0LL)+(y_real)*m_wrap_width_in_fp+dxitem.w
		else
			return XYToX(x,y)
	}
	SubHiddenRanges=function(CEditableText ed,i64 fx){
		y=fx/m_wrap_width_in_fp
		x=fx-y*m_wrap_width_in_fp
		if m_enable_hidden:
			if !m_hidden_ranges_prepared:
				PrepareHiddenRanges(ed)
			p=m_hidden_dx_sub.Bisect(function(long4 a){return a.x<fx})-1L
			if p>=0:
				dxitem=m_hidden_dx_sub[p]
				wrap_width=m_wrap_width_in_fp
				dx=0LL
				if dxitem.y/wrap_width==y:
					dx=dxitem.z
				fx=max(fx,dxitem.y)-dxitem.w
				y=fx/m_wrap_width_in_fp
				x=fx-y*m_wrap_width_in_fp
				x+=dx
		return (x,y)
	}
	IsRangeHidden=function(CEditableText ed,i64 ccnt0,i64 ccnt1){
		if !m_enable_hidden:return 0
		if !m_hidden_ranges_prepared:
			PrepareHiddenRanges(ed)
		p0=m_hidden_ccnts.Bisect(function(i64 a){return a<=ccnt0})
		p1=m_hidden_ccnts.Bisect(function(i64 a){return a<=ccnt1})
		return p0==p1&&(p0&1)
	}
	HideChars=function(CEditableText ed,i64 ccnt0,u8[] color_ids){
		//if !m_enable_hidden:return
		if !m_hidden_ranges_prepared:
			PrepareHiddenRanges(ed)
		p=m_hidden_ccnts.Bisect(function(i64 a){return a<=ccnt0})
		if p>=m_hidden_ccnts.n:
			return
		ccnt_next=m_hidden_ccnts[p]-ccnt0
		enable_hidden=m_enable_hidden
		for i=0L:color_ids.n-1
			if i==ccnt_next:
				if i&&enable_hidden:color_ids[i-1]|=u8(128)
				p++
				if p>=m_hidden_ccnts.n:
					return
				ccnt_next=m_hidden_ccnts[p]-ccnt0
			if p&1:
				if enable_hidden:
					color_ids[i]=u8(255)
				else
					color_ids[i]|=u8(128)
		if enable_hidden&&color_ids.n==ccnt_next&&color_ids.n:
			color_ids[color_ids.n-1]|=u8(128)
	}
	JS_HideRange=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		if !ed:return JS.ReturnError("invalid editor")
		ccnt0=JS.Param(1).as(i64)
		ccnt1=JS.Param(2).as(i64)
		loc0=ed.CreateLocator(ccnt0,1)
		loc1=ed.CreateLocator(ccnt1,-1)
		m_hidden_ranges.push(loc0)
		m_hidden_ranges.push(loc1)
		m_hidden_ranges_prepared=0
		return 0
	}
	JS_ShowRange=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		if !ed:return JS.ReturnError("invalid editor")
		ccnt0=JS.Param(1).as(i64)
		ccnt1=JS.Param(2).as(i64)
		ranges0=m_hidden_ranges
		ranges1=new CLocator[]
		for i=0:2:ranges0.n-2
			if ranges0[i].ccnt<=ccnt1&&ccnt0<=ranges0[i+1].ccnt:
				//drop it
				ranges0[i].discarded=i8(1)
				ranges0[i+1].discarded=i8(1)
			else
				ranges1.push(ranges0[i])
				ranges1.push(ranges0[i+1])
		m_hidden_ranges=ranges1
		m_hidden_ranges_prepared=0
		return 0
	}
	JS_SnapToShown=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		if !ed:return JS.ReturnError("invalid editor")
		ccnt=JS.Param(1).as(i64)
		direction=JS.Param(2).or(1)
		if !m_hidden_ranges_prepared:
			PrepareHiddenRanges(ed)
		p0=m_hidden_ccnts.Bisect(function(i64 a){return a<=ccnt})
		if p0<0||!(p0&1):
			//do nothing
		else
			if direction<0:
				ccnt=m_hidden_ccnts[p0-1]
			else
				ccnt=m_hidden_ccnts[p0]
		return JS.Return(ccnt)
	}
	JS_GetHiddenRanges=function(JSContext JS){
		ret=JS.NewArray()
		foreach loc,I in m_hidden_ranges
			ret[I]=loc.ccnt
		return JS.Return(ret)
	}
	JS_ResetWrapping=function(JSContext JS){
		m_wrap_width=JS.Param(0).or(0.f)
		if !(m_wrap_width>0.f):
			m_wrap_width_in_fp=DEFAULT_WRAP_WIDTH_IN_CHARS*charWidth(int(' '))
		else
			m_wrap_width_in_fp=(float2fixed(m_wrap_width)/m_tab_width_in_fp)*m_tab_width_in_fp
		return 0
	}
	JS_ResetTentativeOps=function(JSContext JS){
		m_precomputed_overlays_for_tentative_editops=TOverlayItem[].NULL
		return 0
	}
	///////////////////////
	__JS_prototype=function(JSObject proto){
		proto.ExportMethod(this,"HunspellAddWord",JS_AddWord)
		proto.ExportMethod(this,"HunspellSuggest",JS_Suggest)
		proto.ExportProperty(this,"m_temporarily_disable_spell_check")
		////////////////////
		proto.ExportProperty(this,"m_hidden_ranges_prepared")
		proto.ExportProperty(this,"m_enable_hidden")
		proto.ExportMethod(this,"HideRange",JS_HideRange)
		proto.ExportMethod(this,"ShowRange",JS_ShowRange)
		proto.ExportMethod(this,"SnapToShown",JS_SnapToShown)
		proto.ExportMethod(this,"GetHiddenRanges",JS_GetHiddenRanges)
		proto.ExportMethod(this,"ResetWrapping",JS_ResetWrapping)
		////////////////////
		proto.ExportProperty(this,"m_tentative_editops")
		proto.ExportMethod(this,"ResetTentativeOps",JS_ResetTentativeOps)
	}

class CColorer_programmer
	CLanguageDescription m_lang
	name=function(){return "colorer"}
	stateSize=function(){return int(m_lang.m_total_state_size)}
	contextSize=function(){return int(m_lang.m_context_size)}
	SetTextStyle=function(JSObject obj){
		m_lang=obj["language"].as(CLanguageDescription)
	}
	//state format: ~and_mask|xor_mask, global bracket delta, min brackets
	inline EnumTokens(string s_context,string s)
		//do the dfa and get all tokens
		return {'forEach':inline(fbody_outer){
			auto ld=m_lang
			auto sz_context=ld.m_context_size
			auto n_char_types=ld.m_n_char_types
			auto char_map=ld.m_char_map
			auto dfa=ld.m_bigchar_dfa
			auto token_lengths=ld.m_token_lengths
			//container={'forEach':inline(fbody){
			//	for i=0:sz_context-1
			//		fbody(s_context[s_context.n-sz_context+i],~i)
			//	foreach ch,I in s
			//		fbody(ch,int(I))
			//}}
			st=0
			//foreach ch,I in container
			for(I=-sz_context;I<s.n;I++)
				if st<0:
					//rollback is O(1) so actually rolling back should be OK
					tok_id=~st
					rollback=(tok_id&255);tok_id>>=8
					if I-rollback>=0:
						//this counts the trailing token of sth into the *next* block
						//Writeln('token: ',tok_id,' ',I,' ',rollback)
						fbody_outer(tok_id,I-rollback,token_lengths[tok_id])
						I-=rollback
					st=0
				if I>=0:
					ch=int(u8(s[I]))
				else
					ch=int(u8(s_context[s_context.n+I]))
				chi=int(char_map[ch])
				st=int(i16(dfa[st*n_char_types+chi]))
		}}
	AddString=function(i64[] a,i64[] pp,string s_context,string s,iptr ofs){
		//here it's just the states
		ld=m_lang
		key_mask=(1<<ld.m_n_key_states)-1
		//do the dfa and get all tokens
		tokens=new u8[]
		foreach tok,I in EnumTokens(s_context,s)
			//I is the finishing position
			if I>ofs:break
			tokens.push(u8(tok))
		bdfa=ld.m_bracket_dfa
		for sti=0:ld.m_n_key_states-1
			pa=3*sti
			and_mask=~int(a[pa+0]>>32)
			xor_mask=int(a[pa+0])
			inc_value=0
			min_value=0
			st=ld.m_id_from_key_state[((ld.m_all_key_states[sti]&and_mask)^xor_mask)&key_mask]*ld.m_n_tokens
			foreach tok,I in tokens
				tran=bdfa[st+int(tok)]
				and_mask&=tran.m_and
				xor_mask&=tran.m_and
				xor_mask^=tran.m_xor
				st=int(tran.m_next_state)
				inc_value+=int(tran.m_delta)
				//if !sti:Write(inc_value)
				if min_value>inc_value:
					min_value=inc_value
			//if !sti:Writeln(' ',inc_value,' ',ofs)
			a[pa+0]=((i64(~and_mask)<<32)|i64(u64(u32(xor_mask))))
			a[pa+2]=min(a[pa+2],a[pa+1]+i64(min_value))
			a[pa+1]+=i64(inc_value)
	}
	Add=function(i64[] a,i64[] b){
		ld=m_lang
		m_all_key_states=ld.m_all_key_states
		m_id_from_key_state=ld.m_id_from_key_state
		key_mask=(1<<ld.m_n_key_states)-1
		for sti=0:ld.m_n_key_states-1
			pa=3*sti
			and_maska=~int(a[pa+0]>>32)
			xor_maska=int(a[pa+0])
			//we need a state lookup to cover the happened key transitions
			pb=3*m_id_from_key_state[((m_all_key_states[sti]&and_maska)^xor_maska)&key_mask]
			and_maskb=~int(b[pb+0]>>32)
			xor_maskb=int(b[pb+0])
			and_mask=(and_maska&and_maskb)
			xor_mask=((xor_maska&and_maskb)^xor_maskb)
			a[pa+0]=((i64(~and_mask)<<32)|i64(u32(xor_mask)))
			a[pa+2]=min(a[pa+2],a[pa+1]+b[pb+2])
			a[pa+1]+=b[pb+1]
	}
	//For coloring states, we need a colorer
	//latex \: use word-based highlighting
	ComputeCharColorID=function(i64[] a,string s_context,string s){
		ld=m_lang
		crules=ld.m_coloring_rules
		bdfa=ld.m_bracket_dfa
		//////////////
		key_mask=(1<<ld.m_n_key_states)-1
		and_maska=~int(a[0]>>32)
		xor_maska=int(a[0])
		bst=ld.m_id_from_key_state[xor_maska&key_mask]*ld.m_n_tokens
		mask=xor_maska
		mask0=0
		struct TColoringEvent
			int ofs
			i8 rule_id
			i8 direction
		coloring_events=new TColoringEvent[]
		inline testEvent(I,lg_token)
			//Writeln('testEvent ',I,' ',lg_token,' ',mask)
			if mask!=mask0:
				//test color rules sequentially - they are only tested at color *changes*
				for i=crules.n-1:-1:0
					mask_i=crules[i].bmask
					if (mask^mask0)&mask_i:
						evt=TColoringEvent(){rule_id:i8(i)}
						if mask&mask_i:
							//we're entering, backtrack
							evt.ofs=int(I-iptr(lg_token))
							evt.direction=i8(1)
						else
							evt.ofs=int(I)
							evt.direction=i8(0)
						coloring_events.push(evt)
				mask0=mask
		//the first TOKEN may start before the block...
		testEvent(-s_context.n-1,0)
		foreach tok,I,lg_token in EnumTokens(s_context,s)
			//ignore nest-only brackets
			tran=bdfa[bst+tok]
			//Writeln(I,' ',bst/ld.m_n_tokens,' ',tok,' ',tran,' ',mask)
			bst=int(tran.m_next_state)
			mask&=tran.m_and
			mask^=tran.m_xor
			testEvent(I,lg_token)
		coloring_events.Sortby(inline(evt){return evt.ofs*2+(evt.direction)})
		//Writeln(coloring_events)
		crule_activation=new i8[crules.n]
		ret=new u8[s.n]
		ofs_last=0L
		active_color=0
		foreach evt in coloring_events
			crule_activation[evt.rule_id]=int(evt.direction)
			if ofs_last<evt.ofs:
				for j=ofs_last:evt.ofs-1
					ret[j]=active_color
				ofs_last=evt.ofs
			active_color=0
			for ci=crule_activation.n-1:-1:0
				if crule_activation[ci]:
					active_color=ci+1
					break
		for j=ofs_last:ret.n-1
			ret[j]=active_color
		//Writeln(coloring_events)
		//Writeln(ret)
		return ret
	}
	/////////////////////////////
	//bracket seeking
	SEEK_MODE_BRACKET=0LL
	SEEK_MODE_STATE=1LL
	hasValidResult=function(i64[] a,i64[] da, i64[] b){
		if b[0]==SEEK_MODE_BRACKET:
			ld=m_lang
			key_mask=(1<<ld.m_n_key_states)-1
			and_maska=~int(a[0]>>32)
			xor_maska=int(a[0])
			pb=3*ld.m_id_from_key_state[((ld.m_all_key_states[0]&and_maska)^xor_maska)&key_mask]
			return a[1]+da[pb+2]<=b[1]
		else
			assert(0)
			return 0
	}
	QueryPerCharValidity=function(i64[] a,i64[] pp,string s_context,string s, i64[] b){
		if b[0]==SEEK_MODE_BRACKET:
			ld=m_lang
			key_mask=(1<<ld.m_n_key_states)-1
			bdfa=ld.m_bracket_dfa
			cur_delta=(a[1]-b[1])
			and_mask=~int(a[0]>>32)
			xor_mask=int(a[0])
			st=ld.m_id_from_key_state[((ld.m_all_key_states[0]&and_mask)^xor_mask)&key_mask]*ld.m_n_tokens
			ret=new i8[s.n+1]
			ofs_last=0L
			is_valid=i8(cur_delta<=0LL)
			foreach tok,I in EnumTokens(s_context,s)
				for i=ofs_last:I-1
					ret[i]=is_valid
				ofs_last=I
				tran=bdfa[st+int(tok)]
				and_mask&=tran.m_and
				xor_mask&=tran.m_and
				xor_mask^=tran.m_xor
				st=int(tran.m_next_state)
				cur_delta+=i64(tran.m_delta)
				is_valid=i8(cur_delta<=0LL)
			for i=ofs_last:ret.n-1
				ret[i]=is_valid
			return ret
		else
			assert(0)
			return i8[].NULL
	}
	////////////////////
	//for JS operations
	__JS_prototype=function(JSObject proto){}

registerUIExtension(function(JSObject JS_UI,CUISandbox sbox,int is_real){
	JS_UI["CreateLanguageDefinition"]=function(JSContext JS){
		//create from a LanguageDefinition object
		obj=JS.Param(0).as(JSObject)
		if !obj:return JS.ReturnError("undefined language definition object")
		ret=new CLanguageDescription
		//bigchar part
		m_big_chars=obj["m_big_chars"].as(JSObject)
		if !m_big_chars:return JS.ReturnError("undefined token list")
		native_bigchars=new string[]
		token_lengths=new u8[]
		char_map=new u8[256]
		context_size=0L
		for i=0:m_big_chars.length()-1
			s_bigchar_i=m_big_chars[i].or("")
			if !s_bigchar_i.n:return JS.ReturnError("tokens cannot be empty")
			native_bigchars.push(s_bigchar_i)
			token_lengths.push(int(s_bigchar_i.n))
			foreach ch in s_bigchar_i
				char_map[int(u8(ch))]=1
			context_size=max(context_size,s_bigchar_i.n)
			//Writeln('token ',i,': ',s_bigchar_i)
		ret.m_context_size=int(context_size)
		////////////////////////////
		//we need bigchars to be a prefix code, but no checking yet
		//it's just AhoCorasick... but the builtin implementation is not for this
		//here we can affored precomputation, but runtime cost should be minimized: no funny business with next
		//and we can do it 8-bit - don't need awareness to handle UTF8
		assert(native_bigchars.n<128)
		n_char_types=1
		for i=0:255
			if char_map[i]:
				char_map[i]=n_char_types
				n_char_types++
		assert(n_char_types<=256)
		fc_lists=new int[][n_char_types]
		for i=0:fc_lists.n-1
			fc_lists[i]=new int[]
		foreach spattern,I in native_bigchars
			ch0=int(u8(spattern[0]))
			if spattern.n==1:
				state=~int(I<<8)
			else
				state=int(I)|(1<<16)
			fc_lists[int(char_map[ch0])].push(state)
		//multi-state DFA -> single-state DFA
		state_map=new int[int[]]
		ops_map=new int[u16[]]
		state_addrs=[0]
		Q=[new int[]]
		depths=[0]
		dfa=new u16[n_char_types]
		dfa_ops=new u16[]
		reached=new i8[native_bigchars.n]
		for(i=0L;i<Q.n;i++)
			cur_states=Q[i]
			cur_depth=depths[i]
			my_addr=i*n_char_types
			tran=new int[][n_char_types]
			if cur_states.n&&cur_states[0]<0:
				//we have deferred tokens, DO NOT RESTART
				for j=0:tran.n-1
					tran[j]=new int[]
			else
				for j=0:tran.n-1
					tran[j]=new(fc_lists[j])
			//fc_lists
			foreach stpacked in cur_states
				if stpacked<0:
					//deferred token, increase rollback but keep it
					for j=0:tran.n-1
						tran[j].push(stpacked-1)
					continue
				pid=(stpacked&0xffff)
				pos=(stpacked>>16)
				s_pid=native_bigchars[pid]
				ch_std=int(char_map[int(u8(s_pid[pos]))])
				pos++
				if pos>=s_pid.n:
					//add action
					tran[ch_std].push(~(pid<<8))
				else
					tran[ch_std].push(pid+(pos<<16))
			//Write(cur_states,' ')
			for j=0:tran.n-1
				new_states=tran[j]
				new_states.Sort()
				new_states.Unique()
				actions=u16[].NULL
				if new_states.n&&new_states[0]<0&&new_states.back()>=0:
					//remove the tokens for which the generatable token is not a prefix of
					new_states=[a foreach a in new_states if a<0||(a>>16)==cur_depth+1]
				if new_states.n&&new_states[0]<0&&new_states.back()<0:
					//actions - higher pid should take higher priority and get sorted first
					//coulddo: substring case... defer the action and add a rollback
					new_stid=new_states[0]
					reached[~new_states[0]>>8]=1
					//Writeln('bigchar=',native_bigchars[~new_states[0]>>8],' rollback=',~new_states[0]&255)
				else
					new_stid=state_map[new_states]
					if !new_stid:
						if new_states.n:
							new_stid=int(Q.n)
							Q.push(new_states)
							depths.push(cur_depth+1)
							dfa.resize(dfa.n+n_char_types)
							assert(dfa.n==n_char_types*Q.n)
							state_map[new_states]=new_stid
				dfa[my_addr+j]=u16(new_stid)
		ret.m_char_map=char_map
		ret.m_n_char_types=n_char_types
		ret.m_bigchar_dfa=dfa
		for i=0:reached.n-1
			if !reached[i]:
				Writeln("warning: big char '@1' can never get triggered".Replace(["@1",native_bigchars[i]]))
		/////////////
		//the list of brackets
		m_bracket_types=obj["m_bracket_types"].as(JSObject)
		if !m_bracket_types:return JS.ReturnError("undefined bracket types")
		n_key_brackets=0
		brackets=new TBracketType[]
		auto parseTokenSet(JSObject obj,string s_name)
			auto obj_set=obj[s_name].as(JSObject)
			auto n=obj_set.length()
			auto ret_set=new int[n]
			for j=0:n-1
				ret_set[j]=obj_set[j].or(0)
			return ret_set
		for i=0:m_bracket_types.length()-1
			obj_i=m_bracket_types[i].as(JSObject)
			if !obj_i:return JS.ReturnError("undefined bracket type")
			type=obj_i["type"].or(REAL_TYPE_MOV)
			is_key=obj_i["is_key"].or(0)
			if is_key:
				assert(n_key_brackets==i)
				n_key_brackets=i+1
			tok0=parseTokenSet(obj_i,"tok0")
			tok1=parseTokenSet(obj_i,"tok1")
			brackets.push(TBracketType(){type:type,tok0:tok0,tok1:tok1})
		assert(n_key_brackets<=12)
		/////////////
		//the state masking rules
		m_enabled_from_inside=new int[1<<n_key_brackets]
		m_id_from_key_state=new int[1<<n_key_brackets]
		m_all_key_states=new int[]
		m_entry_states=obj["m_entry_states"].as(JSObject)
		if !m_entry_states:return JS.ReturnError("undefined entry states")
		for i=0:m_entry_states.length()-1
			obj_i=m_entry_states[i].as(JSObject)
			if !obj_i:return JS.ReturnError("undefined entry state")
			inside_mask=obj_i["inside"].or(0)
			m_enabled_from_inside[inside_mask]=obj_i["enabled"].or(0)
			m_id_from_key_state[inside_mask]=i+1
			m_all_key_states.push(inside_mask)
		for i=0:m_id_from_key_state.n-1
			m_id_from_key_state[i]--
		ret.m_all_key_states=m_all_key_states
		/////////////
		//the bracket DFA
		m_contradiction_fixes=obj["m_contradiction_fixes"].as(JSObject)
		n_key_states=m_all_key_states.n
		n_tokens=native_bigchars.n
		bdfa=new TBDFATransition[n_key_states*n_tokens]
		assert(bdfa.n<32768)
		for sti=0:n_key_states-1
			st=sti*n_tokens
			key_state=m_all_key_states[sti]
			enabled_mask=m_enabled_from_inside[key_state]
			for i=0:brackets.n-1
				if !(enabled_mask&(1<<i)):continue
				type=brackets[i].type
				tok0=brackets[i].tok0
				tok1=brackets[i].tok1
				mask_i=1<<i
				if type==REAL_TYPE_MOV:
					//m_and will be not-ed later
					foreach tok in tok0
						bdfa[st+tok].m_and|=mask_i
						bdfa[st+tok].m_xor|=mask_i
					foreach tok in tok1
						bdfa[st+tok].m_and|=mask_i
				else if type==REAL_TYPE_XOR:
					foreach tok in tok0
						bdfa[st+tok].m_xor|=mask_i
					foreach tok in tok1
						bdfa[st+tok].m_xor|=mask_i
				else if type==REAL_TYPE_ADD:
					foreach tok in tok0
						assert(!bdfa[st+tok].m_delta)
						bdfa[st+tok].m_delta+=i16(1)
					foreach tok in tok1
						assert(!bdfa[st+tok].m_delta)
						bdfa[st+tok].m_delta+=i16(-1)
				else
					assert(0)
			for i=0:n_tokens-1
				bdfa[st+i].m_and=~bdfa[st+i].m_and
				key_state_i=((key_state&bdfa[st+i].m_and)^bdfa[st+i].m_xor)
				if m_id_from_key_state[key_state_i]<0:
					//self-contradicting transition, correct it by anding the enabling mask
					key_state_i=m_contradiction_fixes[key_state_i].as(int)
				assert(m_id_from_key_state[key_state_i]>=0)
				bdfa[st+i].m_next_state=u16((m_id_from_key_state[key_state_i])*n_tokens)
		for i=0:m_id_from_key_state.n-1
			if m_id_from_key_state[i]<0:
				m_id_from_key_state[i]=m_id_from_key_state[m_contradiction_fixes[i].as(int)]
		ret.m_id_from_key_state=m_id_from_key_state
		ret.m_n_key_states=n_key_states
		ret.m_token_lengths=token_lengths
		ret.m_n_tokens=n_tokens
		ret.m_bracket_dfa=bdfa
		/////////////
		//the coloring rules
		m_coloring_rules=obj["m_coloring_rules"].as(JSObject)
		ret.m_coloring_rules=new TColorRule[]
		for i=0:m_coloring_rules.length()-1
			obj_i=m_coloring_rules[i].as(JSObject)
			if !obj_i:return JS.ReturnError("undefined coloring rules")
			bid=obj_i["bid"].or(0)
			ret.m_coloring_rules.push(TColorRule(){
				color_name:obj_i["color_name"].or(""),
				bmask:1<<bid})
		/////////
		//1 bitmask + 1 counter for each nested + 1 min
		ret.m_total_state_size=3*m_all_key_states.n
		/////////
		//the word colorer, which is stand-alone
		//we have keywords and starting chars
		ret.m_default_color_name=obj["m_color_default"].as(string)
		///////
		clunky_dfa=new int[]
		word_char_map=new u8[256]
		for ch=0:255
			if !(ch<128&&isWordChar(ch)):
				word_char_map[ch]=1
		n_word_char_types=2
		word_color_id_map=new int[string]
		/////////////
		ret.m_word_color_names=new string[]
		ret.m_word_color_names.push("<none>")
		auto getWordColorID(string s_color)
			auto color_id=word_color_id_map[s_color]-1
			if color_id<0:
				color_id=int(ret.m_word_color_names.n)
				ret.m_word_color_names.push(s_color)
				word_color_id_map[s_color]=color_id+1
			return color_id
		m_keyword_sets=obj["m_keyword_sets"].as(JSObject)
		s_spell_color=obj["m_color_id_spell_check"].as(string)
		if s_spell_color:
			ret.m_color_id_spell_check=getWordColorID(s_spell_color)
		else
			ret.m_color_id_spell_check=-1
		s_kd_color=obj["m_color_id_key_decl"].as(string)
		if s_kd_color:
			ret.m_kd_color=getWordColorID(s_kd_color)
		else
			ret.m_kd_color=-1
		//a unified color theme for now
		ret.m_key_decl_color_ids=[
			getWordColorID("color_key_decl_class"),
			getWordColorID("color_key_decl_func"),
			getWordColorID("color_key_decl_macro")]
		init_state_by_kwset=new int[]
		for ksi=0:m_keyword_sets.length()-1
			keyword_set_i=m_keyword_sets[ksi].as(JSObject)
			id_default=getWordColorID(keyword_set_i["m_word_color_default"].as(string))
			st0=int(clunky_dfa.n>>8)
			init_state_by_kwset.push(st0)
			clunky_dfa.resize(st0*256+256)
			for i=0:255
				clunky_dfa[st0*256+i]=~id_default
			//[word,color, ...]
			keywords=keyword_set_i["m_keywords"].as(JSObject)
			//[MakeCharSet,color, ...]
			word_openers=keyword_set_i["m_word_openers"].as(JSObject)
			for i=0:2:keywords.length()-2
				s_word=keywords[i+0].as(string)
				s_color=keywords[i+1].as(string)
				color_id=word_color_id_map[s_color]
				if !color_id:
					color_id=int(ret.m_word_color_names.n)
					ret.m_word_color_names.push(s_color)
					word_color_id_map[s_color]=color_id
				//DFA insertion
				st=st0
				foreach ch,I in s_word
					//all keyword chars are unique
					chi=int(u8(ch))
					if !word_char_map[chi]:
						word_char_map[chi]=n_word_char_types
						n_word_char_types++
					if clunky_dfa[st*256+chi]<0:
						n0=int(clunky_dfa.n)
						clunky_dfa[st*256+chi]=(n0>>8)
						clunky_dfa.resize(n0+256)
						for j=0:255
							clunky_dfa[n0+j]=~id_default
					st=clunky_dfa[st*256+chi]
				clunky_dfa[st*256+0]=(~color_id)
			for i=0:2:word_openers.length()-2
				cset=MakeCharSet(word_openers[i+0].as(string))
				s_color=word_openers[i+1].as(string)
				color_id=word_color_id_map[s_color]
				if !color_id:
					color_id=int(ret.m_word_color_names.n)
					ret.m_word_color_names.push(s_color)
					word_color_id_map[s_color]=color_id
				for ch=0:255
					if isInCharSet(cset,ch):
						if !word_char_map[ch]:
							word_char_map[ch]=n_word_char_types
						clunky_dfa[st0*256+ch]=~color_id
				n_word_char_types++
		ret.m_word_char_map=word_char_map
		ret.m_n_word_char_types=n_word_char_types
		//compact the clunky_dfa
		word_char_representatives=new int[n_word_char_types]
		for ch=255:-1:0
			word_char_representatives[word_char_map[ch]]=ch
		word_dfa=new int[(clunky_dfa.n>>8)*n_word_char_types]
		for sti=0:256:clunky_dfa.n-256
			st_final=(sti>>8)*n_word_char_types
			for i=0:n_word_char_types-1
				tran_i=clunky_dfa[sti+word_char_representatives[i]]
				if tran_i>=0:tran_i*=n_word_char_types
				word_dfa[st_final+i]=tran_i
		ret.m_word_dfa=word_dfa
		//set the per-rule initial states
		ret.m_trigger_chars=obj["m_trigger_char"].as(string)
		m_word_dfa_initial_state=obj["m_word_dfa_initial_state"].as(JSObject)
		m_word_dfa_initial_state_triggered=obj["m_word_dfa_initial_state_triggered"].as(JSObject)
		n=m_word_dfa_initial_state.length()
		assert(n==ret.m_coloring_rules.n+1)
		ret.m_word_dfa_initial_state=new int[n]
		ret.m_word_dfa_initial_state_triggered=new int[n]
		//////////////
		for i=0:m_word_dfa_initial_state.length()-1
			st=m_word_dfa_initial_state[i].as(int)
			if st>=0:
				st=init_state_by_kwset[st]*n_word_char_types
			stt=m_word_dfa_initial_state_triggered[i].as(int)
			if stt>=0:
				stt=init_state_by_kwset[stt]*n_word_char_types
			else
				stt=st
			ret.m_word_dfa_initial_state[i]=st
			ret.m_word_dfa_initial_state_triggered[i]=stt
		return JS.Return(ret)
	}
})

class CSeeker_indentation
	name=function(){return "seeker_indentation"}
	stateSize=function(){return 1}
	contextSize=function(){return MAX_ALLOWED_INDENTATION}
	/////////
	inline EnumLineIndentation(string s_context,string s)
		return {'forEach':inline(fbody_outer){
			sz_context=s_context.n
			container={'forEach':inline(fbody){
				for i=0:sz_context-1
					fbody(s_context[s_context.n-sz_context+i],~i)
				foreach ch,I in s
					fbody(ch,int(I))
			}}
			//place the values at the enhanced homes
			//blank lines do not count
			n_ind=0
			foreach ch,I in container
				if ch==' '||ch=='\t':
					if n_ind>=0:n_ind++
				else
					if ch=='\r':
						//ignore, make it invalid
						n_ind=-1
						continue
					else if ch=='\n':
						//new line, reset n_ind without triggering outer loop
						n_ind=0
						continue
					if n_ind>=0:
						if I>=0:
							fbody_outer(min(n_ind,MAX_ALLOWED_INDENTATION),I)
						n_ind=-1
		}}
	/////////
	AddString=function(i64[] a,i64[] pp,string s_context,string s,iptr ofs){
		ind_min=int(a[0])+MAX_ALLOWED_INDENTATION
		foreach ind,I in EnumLineIndentation(s_context,s[:ofs-1])
			if ind_min>ind:
				ind_min=ind
		a[0]=i64(ind_min-MAX_ALLOWED_INDENTATION)
	}
	Add=function(i64[] a,i64[] b){
		a[0]=min(a[0],b[0])
	}
	hasValidResult=function(i64[] a,i64[] da, i64[] b){
		return da[0]+i64(MAX_ALLOWED_INDENTATION)<=b[0]
	}
	QueryPerCharValidity=function(i64[] a,i64[] pp,string s_context,string s, i64[] b){
		ret=new i8[s.n]
		goal=int(b[0])
		foreach ind,I in EnumLineIndentation(s_context,s)
			if ind<=goal:
				ret[I]=1
		return ret
	}

registerStateHandler("renderer_programmer",CLayouter_programmer)
registerStateHandler("colorer_programmer",CColorer_programmer)
registerStateHandler("seeker_indentation",CSeeker_indentation)

///////////////////////////////////////////
NEXT_READ_SIZE=4194304
INITIAL_READ_SIZE=16777216//2097152
WRITE_BATCH=4194304
//NEXT_READ_SIZE=233
//INITIAL_READ_SIZE=233
//WRITE_BATCH=4194304
class CLoadingContext
	i64 sz
	//////////
	//string fn
	System.IO.CFile hf
	string s_lingering
	//////////
	float progress
	JS_discard=function(JSContext JS){
		if hf:
			hf.Close()
			hf=System.IO.CFile.NULL
		return 0
	}
	__JS_prototype=function(JSObject proto){
		proto.ExportProperty(this,"progress")
		proto.ExportMethod(this,"discard",JS_discard)
	}

class CSavingContext
	CEditableText ed
	i64 ofs
	//////////
	string fn
	System.IO.CFile hf
	//////////
	float progress
	__JS_prototype=function(JSObject proto){
		proto.ExportProperty(this,"progress")
	}

///////////////////////////////////////////
//inline chrequi(ch0,chw0)
//	ch=int(ch0)
//	chw=int(chw0)
//	return ch0==chw0||(ch^chw)==0x20&&u32((ch|0x20)-int('a'))<26u

auto KmpBuildTable(string s,int ocase)
	if !s.n:return [-1]
	next=new int[s.n+1]
	next[0]=-1
	for i=1:s.n
		i0=next[i-1]
		ch=s[i-1]
		while i0>=0:
			if s[i0]==ch||!ocase&&chrequi(s[i0],ch):
				break
			i0=next[i0]
		next[i]=i0+1
	for i=1:s.n-1
		x=next[i]
		while x>0&&(s[x]==s[i]||!ocase&&chrequi(s[x],s[i])):
			x=next[x]
		next[i]=x
	//use next[s.n] for match denial
	return next

auto SearchPlainText(CEditableText ed,i64 ccnt_starting,const direction, string s,int ocase,function(i64,i64):int ReportMatch, int budget)
	//use KMP: two-part is not worth it here
	sfind=(direction>0?s:[ch for ch in s.ReverseOrder()])
	if ocase:
		sfind2=sfind
	else
		sfind2=sfind.ToLower()
		sfind=sfind.ToUpper()
	lg=sfind.n
	fnext=KmpBuildTable(sfind,ocase)
	pbudget=budget
	w=0
	for ch,ccnt in direction>0?ed.enumCharsForward(ccnt_starting):ed.enumCharsBackward(ccnt_starting)
		for(;;)
			if ch==sfind[w]:break
			if ch==sfind2[w]:break
			w=fnext[w]
			if w<0:break
		w++
		if w>=lg:
			//got match
			if direction<0:
				ccnt0=ccnt
				ccnt1=ccnt+lg
			else
				ccnt1=ccnt+1
				ccnt0=ccnt1-lg
			pbudget-=ReportMatch(ccnt0,ccnt1)
			w=0
		pbudget--
		if pbudget<=0:
			//we are out of budget, exit
			return ccnt+w*i64(-direction)
	return -1LL

SEARCH_FLAG_CASE_SENSITIVE=1
SEARCH_FLAG_WHOLE_WORD=2
SEARCH_FLAG_REGEXP=4
class CRegexpSearchContext
	int has6,has4
	i64 ccnt,ccnt_base
	RegexIncrementalMatcher matcher
	iptr[] match0
	__JS_prototype=function(JSObject proto){
		proto.ExportProperty(this,"ccnt")
	};

auto SearchRegexp(JSContext JS,CEditableText ed,const dir,string sregexp,int flags,function(i64,i64):int ReportMatch, int budget)
	//use the old regexp code - duk code too complicated
	ctx=JS.Param(1).as(CRegexpSearchContext)
	if !ctx:
		ccnt_starting=JS.Param(1).as(i64)
		//6:^, 4:$
		has6=0;has4=0
		se=sregexp
		if se.n&&se[0]=='^':
			se=se[1:]
			has6=1
		if se.n&&se.back()=='$':
			se=se[:se.n-2]
			has4=1
		if se=="":se="\"\""
		reo=ParseRegex(se)
		if !(flags&SEARCH_FLAG_CASE_SENSITIVE):reo=RegexMakeCaseInsensitive(reo)
		reo=RegexBracket(reo)
		if has6&&dir>0:
			reo=ParseRegex("\n")+reo
		if has4&&dir<0:
			reo=reo+ParseRegex("\r?\n")
		if dir<0:
			reo=reo+ParseRegex("[\\x00-\\xff]*?")
			regex=RegexReverse(reo)
		else
			reo=ParseRegex("[\\x00-\\xff]*?")+reo
			regex=new Regex(reo)
		matcher=regex.Matcher()
		ccnt_base=ccnt_starting
		if dir>0?has6:has4:
			matcher.Add('\n')
			ccnt_base-=dir
		match0=iptr[].NULL
		ctx=new CRegexpSearchContext(){matcher:matcher,has4:has4,has6:has6,ccnt:ccnt_starting,ccnt_base:ccnt_base,match0:match0}
	else
		matcher=ctx.matcher
		ccnt_starting=ctx.ccnt
		ccnt_base=ctx.ccnt_base
		has4=ctx.has4
		has6=ctx.has6
		match0=ctx.match0
	has_tail_enter=0
	if dir>0?has4:has6:
		has_tail_enter=1
	pbudget=budget
	testMatch=function(int ch,i64 ccnt,iptr[] match){
		assert(match.n>=2)
		auto ccnt0=ccnt_base+dir*match[match.n-2]
		auto ccnt1=ccnt_base+dir*match[match.n-1]
		if dir<0:
			tmp=ccnt0;ccnt0=ccnt1;ccnt1=tmp
		auto match_is_invalid=0
		if ccnt0==ccnt1&&!has6&&!has4:
			//ignore zero-sized matches except when we have $/^
			match_is_invalid=1
		if !match_is_invalid&&(flags&SEARCH_FLAG_WHOLE_WORD):
			(ch0,ch1)=ed.GetUtf8CharNeighborhood(ccnt0)
			(ch0x,ch1x)=ed.GetUtf8CharNeighborhood(ccnt1)
			if isWordChar(ch0)==isWordChar(ch1)||isWordChar(ch0x)==isWordChar(ch1x):
				match_is_invalid=1
		if !match_is_invalid:
			(ch0,ch1)=ed.GetCharNeighborhood(ccnt0)
			if has6&&ch0!='\n':
				match_is_invalid=1
			(ch0,ch1)=ed.GetCharNeighborhood(ccnt1)
			if has4&&ch1!='\n'&&ch1!='\r':
				match_is_invalid=1
		if !match_is_invalid:
			pbudget-=ReportMatch(ccnt0,ccnt1)*16
		matcher.Clear()
		matcher.Add(char(ch))
		ccnt_base=ccnt+(dir<0)
		match0=matcher.GetMatch()
	}
	for ch,ccnt in dir>0?ed.enumCharsForward(ccnt_starting):ed.enumCharsBackward(ccnt_starting)
		matcher.Add(char(ch))
		auto match=matcher.GetMatch()
		is_sliding=0
		if match0&&match&&(match0[match0.n-2]!=match[match.n-2]):
			is_sliding=1
			match=match0
		match0=match
		if (is_sliding||!matcher.is_matching())&&match:
			testMatch(int(u8(ch)),ccnt,match)
		////////////////////////
		pbudget-=16
		if pbudget<=0:
			//we are out of budget, exit
			ctx.match0=match0
			ctx.ccnt=ccnt+(dir>0)
			ctx.ccnt_base=ccnt_base
			return JS.Return(ctx)
	ch=(has_tail_enter?int('\n'):-1)
	if ch!=-1:matcher.Add(char(ch))
	match=matcher.GetMatch()
	is_sliding=0
	if match0&&match&&(match0[match.n-2]!=match[match.n-2]):
		is_sliding=1
		match=match0
	match0=match
	if (is_sliding||!matcher.is_matching()||ch==-1)&&match:
		testMatch(ch,dir>0?ed.GetTextSize():-1LL,match)
	return JS.Return(-1LL)
	
///////////////////////////////////////////
class CReplaceJob
	m_ops=new TEditop[]
	string m_s_replace
	m_match_cost=64
	m_direction=1
	JS_GetLastMatch=function(JSContext JS){
		if !m_ops.n:return 0
		delta=0LL
		if m_direction<0:
			op=m_ops[0]
		else
			op=m_ops[m_ops.n-1]
			for i=0:m_ops.n-2
				delta+=m_ops[i].s.n-m_ops[i].sz
		ret=JS.New()
		ret[0]=delta+op.ccnt
		ret[1]=delta+op.ccnt+op.s.n
		return JS.Return(ret)
	}
	__JS_prototype=function(JSObject proto){
		proto.ExportMethod(this,"GetLastMatch",JS_GetLastMatch)
	}

inline isSpaceOrNewline(int ch)
	return u32(ch-9)<=4u||ch==32||ch==160||ch==5760||u32(ch-8192)<=10u||ch==8239||ch==8287||ch==12288
	
//this just returns a list of ccnts indicating the ccnt range for each "line" (if they are similar enough)
//everything works within stext
AUTO_EDIT_SIMILARITY_THRESHOLD=0.3f
AUTO_EDIT_SIMILARITY_THRESHOLD_TWOLINER=0.5f
AUTO_EDIT_SIMILARITY_THRESHOLD_SYM=0.5f
AUTO_EDIT_SIMILARITY_THRESHOLD_SYM_TWOLINER=0.6f
AUTO_EDIT_MAX_LINE_LENGTH=400
AUTO_EDIT_MAX_TOTAL_LENGTH=20480
AUTO_EDIT_MAX_NLINES=256
AUTO_EDIT_MIN_LINE_LENGTH=5
auto AutoEdit_Detect(string stext,iptr ccnt_middle)
	cur_gapprg=int[].NULL
	cclines=iptr[].NULL
	best_covered_sym=0
	best_total_sym=0
	best_covered_alnum=0
	best_total_alnum=0
	best=0
	bnl=0
	best_gapprg=int[].NULL
	nl=0
	is_completely_equal=0
	test_sameline_fix=0
	fisalnum=TextBox.detail.isWordChar
	line_seps=[i for i=0:stext.n if !i||stext[i-1]=='\n']
	pl_middle=line_seps.Bisect(function(iptr ccnt_i){return ccnt_i<=ccnt_middle})-1
	if pl_middle<0:
		pl_middle=0
	else if pl_middle>=line_seps.n:
		pl_middle=line_seps.n-1
	auto ComputeOptimalGapProgram(string stext,int delta_line)
		nsstd=0
		//min_covered=0
		sum_total_sym=0
		sum_total_alnum=0
		//foreach sline,cc0,cc1 in stext.Tokenize("\n")
		cclines=new iptr[]
		for(line_i=0;;line_i+=delta_line)
			nl++
			if nl>AUTO_EDIT_MAX_NLINES:break
			if pl_middle+line_i+delta_line>=line_seps.n:
				nl--
				break
			cc0=line_seps[pl_middle+line_i]
			cc1=line_seps[pl_middle+line_i+delta_line]-1
			sline=stext[cc0:cc1-1]
			uline=Utf8ToUnicode32(sline)
			if !uline.n:
				nl--
				break
			if uline.n>AUTO_EDIT_MAX_LINE_LENGTH:
				nl--
				break
			//Writeln(side,' ',pl_middle,' ',line_i,'>> ',sline)
			if !cur_gapprg:
				cur_gapprg=uline
				(wt_sym,wt_alnum)=SF.ComputeWeightForString(uline,fisalnum)
				sum_total_sym=wt_sym
				sum_total_alnum=wt_alnum
				cclines.push(cc0)
				cclines.push(cc1)
				bnl=2//avoid resize failure
				//min_covered=wt
			else
				ns0=0
				for i=0:cur_gapprg.n-1
					if isSpaceOrNewline(cur_gapprg[i]):
						ns0++
					else
						break
				ns1=0
				for i=0:uline.n-1
					if isSpaceOrNewline(uline[i]):
						ns1++
					else
						break
				if ns0!=ns1||cur_gapprg[:ns1-1]!=uline[:ns1-1]:
					//Writeln('break: ',ns0,' ',ns1,' ',cur_gapprg[:ns1-1],' ',uline[:ns1-1])
					nl--
					break
				nsstd=ns0
				if nl==2&&uline==cur_gapprg:
					is_completely_equal=1
				(cur_gapprg,wgt,wt_covered_sym,wt_total_sym,wt_covered_alnum,wt_total_alnum)=SF.WeightedGapMerge(cur_gapprg,uline,fisalnum)
				wgt++//dodge the warning
				//Writeln(side,' ',line_i,'>> ',wt_covered_alnum,' ',wt_total_alnum,' ',cur_gapprg)
				//min_covered=min(min_covered,wt_covered)
				sum_total_sym+=wt_total_sym
				sum_total_alnum+=wt_total_alnum
				//dmp_prg0=new string[]
				//dmp_sprg=new string
				//foreach ch in cur_gapprg
				//	if ch<0:
				//		if !dmp_prg0.n||dmp_sprg.n:
				//			dmp_prg0.push(dmp_sprg)
				//			dmp_sprg=new string
				//	else
				//		dmp_sprg.push(Unicode32ToUtf8([ch]))
				//dmp_prg0.push(dmp_sprg)
				//Writeln(wgt*nl>best?"(BEST) ":"",nl,' ',wgt,' ',dmp_prg0)
				//percentage_sym=f32(wt_covered_sym*nl)/f32(sum_total_sym+1)
				//percentage_alnum=f32(wt_covered_alnum*nl)/f32(sum_total_alnum+1)
				//use valid percentage + area best
				//if wgt*nl>best:
				//if !best||wt_covered_alnum&&percentage_sym>=AUTO_EDIT_SIMILARITY_THRESHOLD_SYM&&percentage_alnum>=AUTO_EDIT_SIMILARITY_THRESHOLD:
				//	if !(cur_gapprg.n&&cur_gapprg[0]==-1&&cur_gapprg.back()==-1):
				if !best||_isGapProgramOK(cur_gapprg,wt_covered_sym*nl,sum_total_sym, wt_covered_alnum*nl,sum_total_alnum):
					if wgt*nl>best:
						best=wgt*nl
						//best=percentage
						bnl=cclines.n+2
						best_gapprg=cur_gapprg
						best_covered_sym=wt_covered_sym*nl
						best_covered_alnum=wt_covered_alnum*nl
						best_total_sym=sum_total_sym
						best_total_alnum=sum_total_alnum
				//if f32(wt_covered_sym*AUTO_EDIT_MAX_NLINES)/f32(sum_total_sym+1)<AUTO_EDIT_SIMILARITY_THRESHOLD_SYM:
				//	break
				cclines.push(cc0)
				cclines.push(cc1)
				if wgt*AUTO_EDIT_MAX_NLINES<=best:
					break
		//Writeln(side,' ',best,' ',bnl,' ',cclines.n)
		cclines.resize(bnl)
		return nsstd
	inline _isGapProgramOK(int[] best_gapprg,int best_covered_sym,int best_total_sym,int best_covered_alnum,int best_total_alnum)
		if best_gapprg.n&&best_gapprg[0]==-1&&best_gapprg.back()==-1:
			return 0
		//don't auto-edit empty lines
		if !best_covered_alnum:return 0
		//Writeln(best_covered_sym,' ',best_total_sym)
		//Writeln(best_covered_alnum,' ',best_total_alnum)
		if f32(best_covered_sym)<f32(best_total_sym)*(bnl<=2?AUTO_EDIT_SIMILARITY_THRESHOLD_SYM_TWOLINER:AUTO_EDIT_SIMILARITY_THRESHOLD_SYM):
			return 0
		if f32(best_covered_alnum)<f32(best_total_alnum)*(bnl<=2?AUTO_EDIT_SIMILARITY_THRESHOLD_TWOLINER:AUTO_EDIT_SIMILARITY_THRESHOLD):
			return 0
		return 1
	inline isGapProgramOK()
		return _isGapProgramOK(best_gapprg,best_covered_sym,best_total_sym,best_covered_alnum,best_total_alnum)
	//smartedit test
	//ccnt_tot=.doc.l00.TotalCcnt()
	//stext=.doc.GetText(ccnt_lh0,min(ccnt_tot-ccnt_lh0,AUTO_EDIT_MAX_TOTAL_LENGTH))
	//plastline=stext.LastIndexOf('\n')
	//stext.resize(plastline+1)
	//test 2/3 lines too
	for delta_line=1:3
		cur_gapprg=int[].NULL
		cclines=iptr[].NULL
		best_covered_sym=0
		best_total_sym=0
		best_covered_alnum=0
		best_total_alnum=0
		best=0
		bnl=0
		best_gapprg=int[].NULL
		nl=0
		is_completely_equal=0
		test_sameline_fix=0
		/////////////
		nsstd=ComputeOptimalGapProgram(stext,delta_line)
		//if is_completely_equal:test_sameline_fix=1
		if !best_gapprg||bnl<2:
			continue
		nsegs=1
		foreach ch in best_gapprg
			if ch==-1:
				nsegs++
		if !isGapProgramOK():
			continue
		//Writeln(Unicode32ToUtf8([ch<0?0x2026:ch foreach ch in best_gapprg]))
		//for i=0:2:cclines.n-2
		//	cc0=cclines[i]
		//	cc1=cclines[i+1]
		//	sline=stext[cc0:cc1-1]
		//	Writeln(i>>1,'>>> ',sline)
		return cclines
	return iptr[].NULL

auto TextToAutoEditText(int is_bof,int is_eof,string stext)
	nbra=0
	s_unicode=new int[]
	nbras=new int[]
	if is_bof:
		s_unicode.push(int('\n'))
		nbras.push(nbra)
	foreach ch,I in Utf8Chars(stext)
		s_unicode.push(ch)
		nbras.push(nbra)
		if ch=='('||ch=='['||ch=='{':
			nbra++
		else if ch==')'||ch==']'||ch=='}':
			nbra--
	if is_eof:
		s_unicode.push(int('\n'))
		nbras.push(nbra)
	return (s_unicode,nbras)

auto AutoEdit_Precompute(string stext0,iptr[] cclines)
	auto AutoEdit_GetText(iptr _ccnt0,iptr _ccnt1)
		ccnt0=_ccnt0
		ccnt1=_ccnt1
		is_bof=0
		is_eof=0
		if ccnt0>0:
			ccnt0--
		else
			is_bof=1
		if ccnt1<stext0.n:
			ccnt1++
		else
			is_eof=1
		stext=stext0[ccnt0:ccnt1-1]
		return TextToAutoEditText(is_bof,is_eof,stext)
	if !cclines.n:return CReplaceContext.NULL
	assert(cclines.n%2==0)
	inputs=new TReplaceInput[]
	for i=0:2:cclines.n-2
		ccnt0=cclines[i]
		ccnt1=cclines[i+1]
		(s_unicode,nbras)=AutoEdit_GetText(ccnt0,ccnt1)
		//Writeln('<<<',Unicode32ToUtf8(s_unicode),'>>>')
		inputs.push(TReplaceInput(){s_unicode:s_unicode,nbras:nbras})
	return SF.CreateReplaceInstance(inputs)

auto AutoEdit_SetExample(CReplaceContext ctx,int input_id,string s_new)
	return ctx.SetReplaceExample(
		input_id,Utf8ToUnicode32(s_new),
		function(int a){return isWordChar(a)})

auto ProcessEditDistance(TProgramMatch[] matches,int[] ssrc,int[] sret)
	ccntmap=new int[ssrc.n]
	c=0
	for i=1:ssrc.n-1
		ccntmap[i]=c
		c+=Utf8Length(ssrc[i])
	ret=new TEditop[]
	psrc=1L
	ptar=0L
	foreach pm in matches
		op=TEditop(){ccnt:ccntmap[psrc]}
		if pm.pm0>psrc:
			ret.push(TEditop(){ccnt:ccntmap[psrc],sz:ccntmap[pm.pm0]-ccntmap[psrc]})
		psrc=pm.pm0
		if pm.pret>ptar:
			ret.push(TEditop(){ccnt:ccntmap[psrc],s:Unicode32ToUtf8(sret[ptar:pm.pret-1])})
		ptar=pm.pret+pm.pm1-pm.pm0
		psrc=pm.pm1
	if ssrc.n-1>psrc:
		ret.push(TEditop(){ccnt:ccntmap[psrc],sz:ccntmap[ssrc.n-1]-ccntmap[psrc]})
		psrc=ssrc.n-1
	if sret.n>ptar:
		ret.push(TEditop(){ccnt:ccntmap[psrc],s:Unicode32ToUtf8(sret[ptar:])})
	return ret

auto AutoEdit_Evaluate(TEditop[] ops,i64 ccnt_base, CReplaceContext ctx, TProgramItem[] prg, int line_id,int[] s_unicode,int[] nbras_old)
	//just return the edit ops?
	(s_replaced,errs,edhint0)=ctx.ApplyReplaceProgram(prg,s_unicode,nbras_old,line_id, 1)
	if errs&&errs.n:
		return 0
	edhint=ProcessEditDistance(edhint0, s_unicode, s_replaced)
	foreach op in edhint
		op2=op
		op2.ccnt+=ccnt_base
		ops.push(op2)
	return 1

registerUIExtension(function(JSObject JS_UI,CUISandbox sbox,int is_real){
	JS_UI["EDLoader_Open"]=function(JSContext JS){
		//initial read, which is a raw edit
		ed=JS.Param(0).as(CEditableText)
		fn=JS.Param(1).or(new string)
		szread=JS.Param(2).or(INITIAL_READ_SIZE)
		hf=System.IO.OpenFile(fn)
		if !hf:return 0
		s=hf.Read(szread)
		if s.n:
			ed.RawEdit([TEditop(){s:s}])
		if s.n<szread:
			hf.Close()
			return JS.Return(0)
		ret=new CLoadingContext
		ret.sz=System.IO.GetFileSize(fn)
		//ret.fn=fn
		ret.hf=hf
		ret.progress=float(min(double(hf.Position())/double(max(ret.sz,1LL)),1.0))
		return JS.Return(ret)
	}
	JS_UI["EDLoader_Read"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		ret=JS.Param(1).as(CLoadingContext)
		szread=JS.Param(2).or(NEXT_READ_SIZE)
		hf=ret.hf
		//if ret.s_lingering:
		//	ed.RawEdit([TEditop(){ccnt:ed.GetTextSize(),s:ret.s_lingering}])
		//	ret.s_lingering=string.NULL
		//after encoding
		s=hf.Read(szread)
		n_read=s.n
		//todo: encoding
		if ret.s_lingering:
			s=ret.s_lingering+s
			ret.s_lingering=string.NULL
		if s.n:
			//UTF-8 boundary into ret.s_lingering
			pchop=s.n
			for i=s.n-1:-1:max(0,s.n-8)
				c0mask=(int(u8(s[i]))&0xc0)
				if c0mask==0x80:
					//do nothing
				else if c0mask==0xc0:
					p_chop=i
					break
				else
					p_chop=i+1
					break
			//Writeln(pchop,' ',s.n)
			if pchop<s.n:
				ret.s_lingering=new(s[pchop:])
				ed.RawEdit([TEditop(){ccnt:ed.GetTextSize(),s:s[:pchop-1]}])
			else
				//t0=System.Time.tick64()
				ed.RawEdit([TEditop(){ccnt:ed.GetTextSize(),s:s}])
				//Writeln('insertion: ',System.Time.TicksToSeconds(System.Time.tick64()-t0)*1000.0,' ',s.n)
		if n_read<szread:
			if ret.s_lingering:
				ed.RawEdit([TEditop(){ccnt:ed.GetTextSize(),s:ret.s_lingering}])
				ret.s_lingering=string.NULL
			hf.Close()
			return JS.Return(0)
		ret.progress=float(min(double(hf.Position())/double(max(ret.sz,1LL)),1.0))
		return JS.Return(ret)
	}
	JS_UI["EDSaver_Open"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		fn=JS.Param(1).or(new string)
		ret=new CSavingContext
		ret.fn=fn
		ret.hf=System.IO.CreateFile(fn+".$$$")
		ret.ed=ed
		if !ret.hf:return 0
		return JS.Return(ret)
	}
	JS_UI["EDSaver_Write"]=function(JSContext JS){
		ret=JS.Param(0).as(CSavingContext)
		ofs=ret.ofs
		ed=ret.ed
		szmax=ed.GetTextSize()
		szwrite=int(min(szmax-ofs,i64(WRITE_BATCH)))
		if szwrite>0:
			s=ed.GetText(ofs,i64(szwrite))
			if ret.hf.Write(s)<s.n:
				return JS.Return("failed")
		ret.ofs+=i64(szwrite)
		if ret.ofs>=szmax:
			ret.hf.Close()
			if !System.IO.DeleteFile(ret.fn)&&System.IO.FileExists(ret.fn):
				return JS.Return("failed")
			if !System.IO.MoveFile(ret.fn+".$$$",ret.fn):
				return JS.Return("failed")
			return JS.Return("done")
		ret.progress=f32(ret.ofs)/f32(szmax)
		return JS.Return("continue")
	}
	JS_UI["ED_Search"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		direction=JS.Param(2).or(1)
		s=JS.Param(3).as(string)
		flags=JS.Param(4).as(int)
		budget=JS.Param(5).as(int)
		js_callback=JS.Param(6).as(JSObject)
		js_this=JS.Param(7).as(JSObject)
		/////////////
		if !js_callback:
			//need a context for m_match_cost and stuff
			rjob=js_this["m_current_replace_job"].as(CReplaceJob)
			if !rjob:
				rjob=new CReplaceJob
				rjob.m_match_cost=js_this["m_match_cost"].or(rjob.m_match_cost)
				rjob.m_s_replace=js_this["m_s_replace"].as(string)
				rjob.m_direction=direction
				js_this["m_current_replace_job"]=rjob
			ops=rjob.m_ops
			//replace mode
			if flags&SEARCH_FLAG_REGEXP:
				ReportMatch=function(i64 ccnt0,i64 ccnt1){
					ops.push(TEditop(){ccnt:ccnt0,sz:ccnt1-ccnt0,s:rjob.m_s_replace})
					return rjob.m_match_cost
				}
			else
				ReportMatch=function(i64 ccnt0,i64 ccnt1){
					if flags&SEARCH_FLAG_WHOLE_WORD:
						(ch0,ch1)=ed.GetUtf8CharNeighborhood(ccnt0)
						if isWordChar(ch0)==isWordChar(ch1):return 0
						(ch0,ch1)=ed.GetUtf8CharNeighborhood(ccnt1)
						if isWordChar(ch0)==isWordChar(ch1):return 0
					ops.push(TEditop(){ccnt:ccnt0,sz:ccnt1-ccnt0,s:rjob.m_s_replace})
					return rjob.m_match_cost
				}
		else
			if flags&SEARCH_FLAG_REGEXP:
				ReportMatch=function(i64 ccnt0,i64 ccnt1){
					return js_callback.CallAsMethod(int,js_this,ccnt0,ccnt1)
				}
			else
				ReportMatch=function(i64 ccnt0,i64 ccnt1){
					if flags&SEARCH_FLAG_WHOLE_WORD:
						(ch0,ch1)=ed.GetUtf8CharNeighborhood(ccnt0)
						if isWordChar(ch0)==isWordChar(ch1):return 0
						(ch0,ch1)=ed.GetUtf8CharNeighborhood(ccnt1)
						if isWordChar(ch0)==isWordChar(ch1):return 0
					return js_callback.CallAsMethod(int,js_this,ccnt0,ccnt1)
				}
		if flags&SEARCH_FLAG_REGEXP:
			//the regexp version returns an object to JS
			if direction>0:
				return SearchRegexp(JS,ed,1, s,flags,ReportMatch, budget)
			else
				return SearchRegexp(JS,ed,-1, s,flags,ReportMatch, budget)
		else
			ocase=(flags&SEARCH_FLAG_CASE_SENSITIVE)
			ccnt0=JS.Param(1).as(i64)
			if direction>0:
				ret=SearchPlainText(ed,ccnt0,1, s,ocase,ReportMatch, budget)
			else
				ret=SearchPlainText(ed,ccnt0,-1, s,ocase,ReportMatch, budget)
		return JS.Return(ret)
	}
	//this is not hook-friendly
	JS_UI["ED_ApplyReplaceOps"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		rjob=JS.Param(1).as(CReplaceJob)
		if !ed||!rjob:return JS.ReturnError("invalid parameters")
		//for now, just do it the dumb way
		n=rjob.m_ops.n
		ed.Edit(rjob.m_ops)
		return JS.Return(n)
	}
	//smart paste - it's slow, do it natively
	JS_UI["ED_GetClipboardTextSmart"]=function(JSContext JS){
		MAX_INDENT=256
		s_pchar=__pointer(SDL.detail.SDL_GetClipboardText())
		if !s_pchar:return 0
		str=System.detail.pcharToString(s_pchar)
		s_target_indent=JS.Param(0).as(string)
		p_trailing_space=str.n
		while p_trailing_space>0&&(str[p_trailing_space-1]==' '||str[p_trailing_space-1]=='\t')&&p_trailing_space>str.n-MAX_INDENT:
			p_trailing_space--
		if p_trailing_space>0&&str[p_trailing_space-1]=='\n':
			//gotta rearrange it
			str2=str[p_trailing_space:]+str[:p_trailing_space-1]
		else
			str2=str
		if str2.n&&str2.back()=='\n':
			str2=str2[:str2.n-2]
		got_first_indent=0
		pindent_first=0
		sinsert=new string
		foreach sline,I0,I1 in str2.TokenizeEx("\n",str2.TOKENIZE_ALLOW_EMPTY)
			pindent=0
			while pindent<sline.n&&pindent<MAX_INDENT&&(sline[pindent]==' '||sline[pindent]=='\t'):
				pindent++
			if !got_first_indent:
				pindent_first=pindent
				got_first_indent=1
			if pindent<pindent_first:
				if !pindent:
					//empty line, keep it empty but add the full indent
					sinsert.push(s_target_indent)
				else
					//subtract something
					sinsert.push(s_target_indent[:max(s_target_indent.n+pindent-pindent_first,0)-1])
					sinsert.push(sline[pindent:])
			else
				sinsert.push(s_target_indent)
				sinsert.push(sline[pindent_first:])
			sinsert.push('\n')
		//sinsert.pop()
		return JS.Return(sinsert)
	}
	//avoid going throught JS
	JS_UI["ED_AutoEdit_Detect"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		if !ed:return JS.ReturnError("invalid editor")
		ccnt_lh=JS.Param(1).as(i64)
		ccnt_get=max(ccnt_lh-(AUTO_EDIT_MAX_TOTAL_LENGTH>>1),0LL)
		stext=ed.GetText(ccnt_get,i64(min(AUTO_EDIT_MAX_TOTAL_LENGTH,ed.GetTextSize()-ccnt_get)))
		cclines=AutoEdit_Detect(stext,iptr(ccnt_lh-ccnt_get))
		if !cclines:
			return 0
		else
			ctx=AutoEdit_Precompute(stext,cclines)
			if !ctx:
				return 0
			else
				ret=JS.New()
				ret["m_cclines"]=[ccnt+ccnt_get foreach ccnt in cclines]
				ret["m_ctx"]=ctx
				ret["m_owner"]=ed
				ret["m_example_lines"]=JS.New()
				return JS.Return(ret)
	}
	JS_UI["ED_AutoEdit_Start"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		if !ed:return JS.ReturnError("invalid editor")
		js_cclines=JS.Param(1).as(JSObject)
		n=js_cclines["length"].as(iptr)
		if n<=1L:return 0
		cclines=new i64[(n-1)*2]
		for i=0:n-2
			cclines[i*2+0]=js_cclines[i].as(i64)
			cclines[i*2+1]=js_cclines[i+1].as(i64)-1LL
		ccnt_get=cclines[0]
		lg_max=i64(min(AUTO_EDIT_MAX_TOTAL_LENGTH,ed.GetTextSize()-ccnt_get))
		if cclines[cclines.n-1]-ccnt_get>lg_max:return 0
		stext=ed.GetText(ccnt_get,lg_max)
		ctx=AutoEdit_Precompute(stext,[iptr(ccnt-ccnt_get) foreach ccnt in cclines])
		if !ctx:
			return 0
		else
			ret=JS.New()
			ret["m_cclines"]=cclines
			ret["m_ctx"]=ctx
			ret["m_owner"]=ed
			ret["m_example_lines"]=JS.New()
			return JS.Return(ret)
	}
	class CProgramWrapper
		TProgramItem[] prg
	JS_UI["ED_AutoEdit_SetExample"]=function(JSContext JS){
		obj=JS.Param(0).as(JSObject)
		if !obj:return JS.ReturnError("invalid object")
		line_id=JS.Param(1).as(int)
		s_new=JS.Param(2).as(string)
		ctx=obj["m_ctx"].as(CReplaceContext)
		example_lines=obj["m_example_lines"].as(JSObject)
		prg=AutoEdit_SetExample(ctx,line_id,s_new)
		if prg:
			obj["m_prg"]=new CProgramWrapper(){prg:prg}
			example_lines[line_id]=1
			return JS.Return(1)
		else
			return 0
	}
	JS_UI["ED_AutoEdit_Evaluate"]=function(JSContext JS){
		obj=JS.Param(0).as(JSObject)
		if !obj:return JS.ReturnError("invalid object")
		wprg=obj["m_prg"].as(CProgramWrapper)
		if !wprg:return JS.ReturnError("invalid program")
		locs=JS.Param(1).as(JSObject)
		if !locs:return JS.ReturnError("invalid locators")
		prg=wprg.prg
		ctx=obj["m_ctx"].as(CReplaceContext)
		ed=obj["m_owner"].as(CEditableText)
		example_lines=obj["m_example_lines"].as(JSObject)
		ops=new TEditop[]
		n=locs.length()
		for i=0:2:n-2
			if example_lines[i>>1].as(int):continue
			ccnt0=(locs[i].as(CLocator)).ccnt
			ccnt1=(locs[i+1].as(CLocator)).ccnt
			(s_unicode,nbras_old)=TextToAutoEditText(1,1,ed.GetText(i64(ccnt0),i64(ccnt1-ccnt0)))
			if !AutoEdit_Evaluate(ops,i64(ccnt0), ctx, prg, i>>1,s_unicode,nbras_old):
				break
		ret=JS.NewArray()
		foreach op,I in ops
			ret[I*3+0]=op.ccnt
			ret[I*3+1]=op.sz
			ret[I*3+2]=op.s
		return JS.Return(ret)
	}
})
