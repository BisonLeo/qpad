import "system.jc"
import "gui2d.jc"
import "javascript.jc"
import "text-box.jc"
import System.Math.*
import System.Algorithm.*
import System.Console.*
import Gui2D.detail.*
import Javascript.*
import TextBox.*
import TextBox.detail.*

/*
or-ing tokens
	<
	<script
failure case:
	a lot of \\ \"
	token ambiguity cross the boundary
	ignore
	---
	an escape char mode
		self-zeroing token eater
	it breaks the tokenization assumption
*/
REAL_TYPE_MOV=0;
REAL_TYPE_XOR=1;
REAL_TYPE_ADD=2;
DEFAULT_WRAP_WIDTH_IN_CHARS=2048LL
GRACEFUL_WORD_SIZE=256
MAX_ALLOWED_INDENTATION=20

struct TBracketType
	int type
	int[] tok0,tok1

//0+=0 for non-inc
struct TBDFATransition
	i32 m_and
	i32 m_xor
	i16 m_delta
	u16 m_next_state

struct TColorRule
	string color_name
	//int bid
	//int extend_0,extend_1
	int bmask
	int extend_before

struct TKeyword
	string s
	string color_name

class CLanguageDescription
	//int[] m_enabled_from_inside
	int[] m_all_key_states
	int[] m_id_from_key_state
	u8[] m_char_map
	u16[] m_bigchar_dfa
	int m_total_state_size
	int m_context_size
	int m_n_char_types
	int m_n_key_states
	u8[] m_token_lengths
	int m_n_tokens
	//the initial state is always 0
	/////////
	//TBracketType[] m_bracket_types
	TBDFATransition[] m_bracket_dfa
	TColorRule[] m_coloring_rules
	/////////
	string m_default_color_name
	string[] m_word_color_names
	int[] m_word_dfa
	u8[] m_word_char_map
	int m_n_word_char_types
	int[] m_word_dfa_initial_state
	int[] m_word_dfa_initial_state_triggered
	string m_trigger_chars

HL_DISPLAY_MODE_EMBOLDEN=1
HL_DISPLAY_MODE_TILDE=2
class CLayouter_programmer
	FLAG_HAS_TAB=1
	FLAG_HAS_ENTER=2
	/////////
	m_wrap_width_in_fp=0LL
	m_tab_width_in_fp=0LL
	m_tab_width=4
	m_wrap_width=0.f
	m_font=TFont()
	m_bgcolor_selection=0xff800000
	m_color_overlay=0xff000000
	//////////////
	JSObject m_style
	CLanguageDescription m_lang
	int[] m_cached_colors
	int m_cached_colors_p_word_part
	//////////////
	int[] m_char_width_cache_ascii
	int[int] m_char_width_cache
	//todo: easy color change...
	/////////////////
	charWidth=inline(ch){
		if u32(ch)<u32(0x80):
			ret=m_char_width_cache_ascii[ch]
			if !ret:
				ret=int(float2fixed(g_renderer.GetCharacterAdvance(m_font,int(ch))))+1
				m_char_width_cache_ascii[ch]=ret
		else
			ret=m_char_width_cache[ch]
			if !ret:
				ret=int(float2fixed(g_renderer.GetCharacterAdvance(m_font,int(ch))))+1
				m_char_width_cache[ch]=ret
		return ret-1
	}
	charHeight=inline(){
		return float2fixed(g_renderer.GetCharacterHeight(m_font))
	}
	/////////////////
	//this thing isn't line-only
	name=function(){return "renderer"}
	stateSize=function(){return 4}
	/////////////////
	//final format: pre-tab width, has-tabbed-ness, tab-enter width, has-enter-ness, post-enter width
	//do not use a render-central design
	AddString=function(i64[] a,i64[] unused,string s_context,string s,iptr ofs){
		w_pre_tab=a[0]
		w_tab_enter=a[1]
		w_post_enter=a[2]
		flags=int(a[3])
		foreach ch,I in Utf8Chars(s)
			if I>=ofs:break
			if ch=='\t':
				if !(flags&FLAG_HAS_ENTER):
					if !(flags&FLAG_HAS_TAB):
						flags|=FLAG_HAS_TAB
					else
						w_tab_enter=(w_tab_enter/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
				else
					w_post_enter=(w_post_enter/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
			else if ch=='\n':
				if !(flags&FLAG_HAS_ENTER):
					flags|=FLAG_HAS_ENTER
				else
					w_post_enter=(w_post_enter/m_wrap_width_in_fp+1LL)*m_wrap_width_in_fp
			else if ch!='\r':
				dx=charWidth(ch)
				if !(flags&FLAG_HAS_ENTER):
					if !(flags&FLAG_HAS_TAB):
						w_pre_tab+=dx
					else 
						w_tab_enter+=dx
				else
					w_post_enter+=dx
		a[0]=w_pre_tab
		a[1]=w_tab_enter
		a[2]=w_post_enter
		a[3]=i64(flags)
	}
	Add=function(i64[] a,i64[] b){
		a_w_pre_tab=a[0]
		a_w_tab_enter=a[1]
		a_w_post_enter=a[2]
		a_flags=int(a[3])
		b_w_pre_tab=b[0]
		b_w_tab_enter=b[1]
		b_w_post_enter=b[2]
		b_flags=int(b[3])
		if a_flags&FLAG_HAS_ENTER:
			//a_w_post_enter
			a_w_post_enter+=b_w_pre_tab
			if b_flags&FLAG_HAS_TAB:
				a_w_post_enter=(a_w_post_enter/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
			a_w_post_enter+=b_w_tab_enter
			if b_flags&FLAG_HAS_ENTER:
				a_w_post_enter=(a_w_post_enter/m_wrap_width_in_fp+1LL)*m_wrap_width_in_fp
			a_w_post_enter+=b_w_post_enter
		else if a_flags&FLAG_HAS_TAB:
			a_w_tab_enter+=b_w_pre_tab
			if b_flags&FLAG_HAS_TAB:
				a_w_tab_enter=(a_w_tab_enter/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
			a_w_post_enter+=b_w_tab_enter
			if b_flags&FLAG_HAS_ENTER:
				a_flags|=FLAG_HAS_ENTER
				a_w_post_enter=b_w_post_enter
		else
			a_w_pre_tab+=b_w_pre_tab
			a_flags=b_flags
			a_w_tab_enter=b_w_tab_enter
			a_w_post_enter=b_w_post_enter
		a[0]=a_w_pre_tab
		a[1]=a_w_tab_enter
		a[2]=a_w_post_enter
		a[3]=i64(a_flags)
	}
	GetFlatX=inline(i64[] a){
		w_pre_tab=a[0]
		w_tab_enter=a[1]
		w_post_enter=a[2]
		flags=int(a[3])
		x=w_pre_tab
		if flags&FLAG_HAS_TAB:
			x=(x/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
		x+=w_tab_enter
		if flags&FLAG_HAS_ENTER:
			x=(x/m_wrap_width_in_fp+1LL)*m_wrap_width_in_fp
		x+=w_post_enter
		return x
	}
	XYToX=inline(i64 x,i64 y){
		hc=charHeight()
		return max(min(x,m_wrap_width_in_fp-1LL),0LL)+(y/hc)*m_wrap_width_in_fp
	}
	/////////////////
	//compare known-positive doubles as ints
	Compare=function(i64[] a,i64[] b){
		return __C_compare(GetFlatX(a),XYToX(b[0],b[1]))
	}
	SeekInBlock=function(i64 ccnt_base,i64[] a,i64[] unused,string s,i64[] b){
		x_goal=XYToX(b[0],b[1])
		x=GetFlatX(a)
		if b.n>2:
			//hint
			x_last_known=XYToX(b[2],b[3])
			ccnt_last_known=b[4]
			if u64(ccnt_last_known-ccnt_base)<u64(s.n):
				p=iptr(ccnt_last_known-ccnt_base)
				x=x_last_known
				foreach ch,I in Utf8Chars(s[p:])
					if x>=x_goal:return I+p
					if ch=='\t':
						x=(x/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
					else if ch=='\n':
						x=(x/m_wrap_width_in_fp+1LL)*m_wrap_width_in_fp
					else if ch!='\r':
						dx=charWidth(ch)
						x+=dx
				return s.n
		foreach ch,I in Utf8Chars(s)
			if x>=x_goal:return I
			if ch=='\t':
				x=(x/m_tab_width_in_fp+1LL)*m_tab_width_in_fp
			else if ch=='\n':
				x=(x/m_wrap_width_in_fp+1LL)*m_wrap_width_in_fp
			else if ch!='\r':
				dx=charWidth(ch)
				x+=dx
		return s.n
	}
	/////////////////
	long3 m_caret_overlay
	JSObject m_overlay_obj
	i64 m_caret_offset
	SetTextStyle=function(JSObject obj){
		m_lang=obj["language"].as(CLanguageDescription)
		m_font=obj["font"].as(TFont)
		m_char_width_cache_ascii=new int[128]
		m_char_width_cache=new int[int]
		m_tab_width=obj["tab_width"].or(8)
		m_wrap_width=obj["wrap_width"].or(0.f)
		m_tab_width_in_fp=i64(m_tab_width)*charWidth(int(' '))
		if !(m_wrap_width>0.f):
			m_wrap_width_in_fp=DEFAULT_WRAP_WIDTH_IN_CHARS*charWidth(int(' '))
		else
			m_wrap_width_in_fp=(float2fixed(m_wrap_width)/m_tab_width_in_fp)*m_tab_width_in_fp
		////////////
		m_cached_colors_p_word_part=m_lang.m_coloring_rules.n+1
		m_cached_colors=new int[m_cached_colors_p_word_part+m_lang.m_word_color_names.n]
		m_cached_colors[0]=obj[m_lang.m_default_color_name].or(0xff000000)
		foreach crule,I in m_lang.m_coloring_rules
			m_cached_colors[I+1]=obj[crule.color_name].or(0xff000000)
		foreach color_name,I in m_lang.m_word_color_names
			m_cached_colors[m_cached_colors_p_word_part+I]=obj[color_name].or(0xff000000)
		m_bgcolor_selection=int(obj["bgcolor_selection"].or(u32(m_bgcolor_selection)))
		m_color_overlay=int(obj["color_overlay"].or(u32(m_color_overlay)))
	}
	BeginRender=function(JSObject obj){
		m_cached_colors_p_word_part=m_lang.m_coloring_rules.n+1
		m_cached_colors=new int[m_cached_colors_p_word_part+m_lang.m_word_color_names.n]
		m_cached_colors[0]=obj[m_lang.m_default_color_name].or(0xff000000)
		foreach crule,I in m_lang.m_coloring_rules
			m_cached_colors[I+1]=obj[crule.color_name].or(0xff000000)
		foreach color_name,I in m_lang.m_word_color_names
			m_cached_colors[m_cached_colors_p_word_part+I]=obj[color_name].or(0xff000000)
		m_bgcolor_selection=int(obj["bgcolor_selection"].or(u32(m_bgcolor_selection)))
		m_color_overlay=int(obj["color_overlay"].or(u32(m_color_overlay)))
	}
	SetCaretOverlay=function(CEditableText caller,i64 x,i64 y,JSObject obj){
		m_overlay_obj=obj
		w_overlayd=0.
		if obj:
			s=obj["text"].as(string)
			if s:
				w_overlayd=GetStringWidth(m_font,s)
		w_overlay=double2fixed(w_overlayd)
		m_caret_overlay=long3(XYToX(x,y),0LL,w_overlay)
		m_caret_overlay.y=(m_caret_overlay.x+m_wrap_width_in_fp-1LL)/m_wrap_width_in_fp*m_wrap_width_in_fp
		m_caret_offset=0LL
		return w_overlay
	}
	GetCaretOffset=function(){
		return m_caret_offset
	}
	RenderText=function(CEditableText ed,i64 ccnt_base,i64[] a,i64[] unused,string s, u8[] color_ids, i64 scroll_x,i64 scroll_y,i64 clip_w,i64 clip_h,float screen_x,float screen_y,float scale){
		//word coloring - update color_ids
		//get a GRACEFUL_WORD_SIZE context on each side - do it per-char
		word_dfa=m_lang.m_word_dfa
		word_char_map=m_lang.m_word_char_map
		n_word_char_types=m_lang.m_n_word_char_types
		//start from word_ccnt0, do per-char enum until we go out of block
		word_ccnt0=ccnt_base
		budget=GRACEFUL_WORD_SIZE
		foreach ch,I in ed.enumUtf8Backward(ccnt_base)
			if !isWordChar(ch):break
			word_ccnt0=I
			budget--
			if budget<0:break
		ccnt_block_end=ccnt_base+i64(s.n)
		ch_before_word=ed.GetUtf8CharNeighborhood(word_ccnt0)[0]
		trigger_chars=m_lang.m_trigger_chars
		for(;;)
			//Writeln(word_ccnt0)
			foreach ch,I,I2 in ed.enumUtf8Forward(word_ccnt0)
				word_ccnt0=I
				if isWordChar(ch):
					break
				ch_before_word=ch
				word_ccnt0=I2
				if word_ccnt0>=ccnt_block_end:
					break
			if word_ccnt0>=ccnt_block_end:break
			//now we know we have a word
			//non-word chars should immediately terminate the DFA
			color_id=0
			cid=color_ids[max(iptr(word_ccnt0-ccnt_base),0L)]
			st=m_lang.m_word_dfa_initial_state[cid]
			if trigger_chars&&ch_before_word<128&&trigger_chars.IndexOf(char(ch_before_word))>=0:
				//it's immediately after the trigger char, use the alternative initial state
				st=m_lang.m_word_dfa_initial_state_triggered[cid]
			if st>=0:
				budget=GRACEFUL_WORD_SIZE
				foreach ch,I in ed.enumCharsForward(word_ccnt0)//it's 8-bit here, not UTF8!
					//and ch is signed
					//non-word chars would inevitably terminate the DFA
					chi=int(u8(ch))
					st=word_dfa[st+int(word_char_map[chi])]
					if st<0:break
					budget--
					if budget<0:break
			if st>=0:st=word_dfa[st+1]
			color_id=~st
			foreach ch,I,I2 in ed.enumUtf8Forward(word_ccnt0)
				word_ccnt0=I
				if isWordChar(ch):
					ofs=iptr(word_ccnt0-ccnt_base)
					if uptr(ofs)<uptr(color_ids.n):
						if color_id>0:
							color_ids[ofs]=m_cached_colors_p_word_part+color_id
				else
					break
				ch_before_word=ch
				word_ccnt0=I2
				if word_ccnt0>=ccnt_block_end:
					break
		///////
		fnt_scaled=m_font
		fnt_scaled.h*=scale
		//smart emboldening for SRGB
		//coulddo: per-color emboldening
		if g_renderer.m_srgb_supported:
			color_default=m_cached_colors[0]
			fnt_scaled.SmartEmbolden(m_cached_colors[0])
		hc=charHeight()
		x=GetFlatX(a)
		if x>m_caret_overlay.x&&x<m_caret_overlay.y:
			x+=m_caret_overlay.z
		tab_width=m_tab_width_in_fp
		wrap_width=m_wrap_width_in_fp
		iy=x/wrap_width
		ix=x-iy*wrap_width
		inline projectXY(i64 x0)
			auto y=x0/wrap_width
			auto x=x0-y*wrap_width
			y*=hc
			return float2(fixed2float(x-scroll_x)*scale+screen_x,fixed2float(y-scroll_y)*scale+screen_y)
		auto testOverlay()
			if m_overlay_obj&&x==m_caret_overlay.x:
				s_overlay=m_overlay_obj["text"].as(string)
				auto prj_x=projectXY(x)
				if s_overlay:
					overlay_sel0=m_overlay_obj["start"].or(0L)
					overlay_sel1=overlay_sel0+m_overlay_obj["length"].or(0L)
					if m_overlay_obj["type"].as(string)=="IME":
						cmap=new iptr[]
						foreach chj,J in Utf8Chars(s_overlay)
							cmap.push(J)
						cmap.push(s_overlay.n)
						overlay_sel0=min(overlay_sel0,cmap.n-1)
						overlay_sel1=min(overlay_sel1,cmap.n-1)
						if uptr(overlay_sel0)<uptr(cmap.n)&&uptr(overlay_sel1)<uptr(cmap.n):
							x_sel0=GetStringWidth(m_font,s_overlay[:cmap[overlay_sel0]-1])
							x_sel1=GetStringWidth(m_font,s_overlay[:cmap[overlay_sel1]-1])
							m_caret_offset=double2fixed(x_sel1)
							if x_sel0>x_sel1:
								(x_sel0,x_sel1)=(x_sel1,x_sel0)
							//selection - pre-draw the highlight
							if x_sel0<x_sel1:
								g_renderer.DrawBitmap(0, prj_x.x+float(x_sel0),prj_x.y,float((x_sel1-x_sel0)*scale),fixed2float(hc), m_bgcolor_selection)
						else
							x_sel0=0.
							x_sel1=0.
					xo=x
					foreach chj,J in Utf8Chars(s_overlay)
						dx_j=charWidth(chj)
						prj_xo=projectXY(xo)
						g_renderer.DrawChar(fnt_scaled, prj_xo.x,prj_xo.y,m_color_overlay, chj)
						xo+=dx_j
				else if m_overlay_obj["type"].as(string)=="AC":
					//auto-complete
					xo=x
					foreach chj,J in Utf8Chars(s_overlay)
						dx_j=charWidth(chj)
						prj_xo=projectXY(xo)
						g_renderer.DrawChar(fnt_scaled, prj_xo.x,prj_xo.y,m_color_overlay, chj)
						xo+=dx_j
				else
					assert(0)
				if m_overlay_obj["type"].as(string)=="IME":
					//draw the underline
					y_underline=prj_x.y+fnt_scaled.h*(fnt_scaled.pfnt.y_baseline_per_height+0.02f)
					g_renderer.DrawBitmap(0, prj_x.x,y_underline,fixed2float(m_caret_overlay.z)*scale,max(fnt_scaled.h*0.05f,1.f), m_color_overlay)
				x+=m_caret_overlay.z
				iy=x/wrap_width
				ix=x-iy*wrap_width
		x_right_clip=scroll_x+clip_w
		for ch,I in Utf8Chars(s)
			testOverlay()
			if ch=='\n':
				x=(x/wrap_width+1LL)*wrap_width
				iy=x/wrap_width
				ix=x-iy*wrap_width
				if iy*hc-scroll_y>=clip_h:break
			else if ch=='\r':
				//nothing
				continue
			else if ch==' ':
				dx_i=charWidth(ch)
				x+=dx_i
				ix+=dx_i
				if ix>=wrap_width:
					ix-=wrap_width
					iy++
			else if ch=='\t':
				x=(x/tab_width+1LL)*tab_width
				iy=x/wrap_width
				ix=x-iy*wrap_width
			else
				dx_i=charWidth(ch)
				if ix<x_right_clip:
					prj_x=float2(fixed2float(ix-scroll_x)*scale+screen_x,fixed2float(iy*hc-scroll_y)*scale+screen_y)
					g_renderer.DrawChar(fnt_scaled, prj_x.x,prj_x.y,m_cached_colors[color_ids[I]], ch)
				x+=dx_i
				ix+=dx_i
				if ix>=wrap_width:
					ix-=wrap_width
					iy++
					if iy*hc-scroll_y>=clip_h:break
		testOverlay()
	}
	DrawEnhancedHighlight=function(JSObject obj,CEditableText ed,CHLRange hl, i64 scroll_x,i64 scroll_y,i64 clip_w,i64 clip_h,float screen_x,float screen_y,float scale){
		hid=ed.m_handler_registration["renderer"].as(int)
		fnt_bold_scaled=obj["font_emboldened"].as(TFont)
		fnt_bold_scaled.h*=scale
		hc=charHeight()
		////////
		ccnt0=hl.p0.ccnt
		ccnt1=hl.p1.ccnt
		mode=int(hl.display_mode)
		if mode==HL_DISPLAY_MODE_EMBOLDEN:
			//only embolden a single char
			s_embolden=ed.GetText(ccnt0,ccnt1-ccnt0)
			wrap_width=m_wrap_width_in_fp
			x=GetFlatX(ed.GetStateAt(hid,ccnt0))
			foreach ch in Utf8Chars(s_embolden)
				iy=x/wrap_width
				ix=x-iy*wrap_width
				prj_x=float2(fixed2float(ix-scroll_x)*scale+screen_x,fixed2float(iy*hc-scroll_y)*scale+screen_y)
				g_renderer.DrawChar(fnt_bold_scaled, prj_x.x,prj_x.y,hl.color, ch)
				dx_i=charWidth(ch)
				x+=dx_i
		else
			//todo: tilde for spell checks
			//if xy0.y==xy1.y:
			//	hc=fixed2float(GetCharacterHeightAt(ccnt1))*scale
			//	g_renderer.DrawBitmap(0, xy0.x,xy0.y,xy1.x-xy0.x,hc, hl.color)
			//else
			//	//draw 3 rects, we have a cliprect, don't worry
			//	hc=fixed2float(GetCharacterHeightAt(ccnt0))*scale
			//	g_renderer.DrawBitmap(0, xy0.x,xy0.y,max(scr_x+wf*scale-xy0.x,0.f),hc, hl.color)
			//	g_renderer.DrawBitmap(0, scr_x,xy0.y+hc,wf*scale,max(xy1.y-(xy0.y+hc),0.f), hl.color)
			//	hc=fixed2float(GetCharacterHeightAt(ccnt1))*scale
			//	g_renderer.DrawBitmap(0, scr_x,xy1.y,max(xy1.x-scr_x,0.f),hc, hl.color)
	}
	GetCharacterHeightAt=function(i64 ccnt_base,i64[] a,i64[] pp,string s,iptr ofs){
		return charHeight()
	}
	GetDefaultFont=function(){
		return m_font
	}
	GetXYFromState=function(i64[] a){
		x0=GetFlatX(a)
		y=x0/m_wrap_width_in_fp
		x=x0-y*m_wrap_width_in_fp
		y*=charHeight()
		return long2(x,y)
	}
	//todo: IsAtLineWrap
	//////////////////////////////
	__JS_prototype=function(JSObject proto){}

class CColorer_programmer
	CLanguageDescription m_lang
	name=function(){return "colorer"}
	stateSize=function(){return int(m_lang.m_total_state_size)}
	contextSize=function(){return int(m_lang.m_context_size)}
	SetTextStyle=function(JSObject obj){
		m_lang=obj["language"].as(CLanguageDescription)
	}
	//state format: ~and_mask|xor_mask, global bracket delta, min brackets
	inline EnumTokens(string s_context,string s)
		//do the dfa and get all tokens
		return {'forEach':inline(fbody_outer){
			auto ld=m_lang
			auto sz_context=ld.m_context_size
			auto n_char_types=ld.m_n_char_types
			auto char_map=ld.m_char_map
			auto dfa=ld.m_bigchar_dfa
			auto token_lengths=ld.m_token_lengths
			container={'forEach':inline(fbody){
				for i=0:sz_context-1
					fbody(s_context[s_context.n-sz_context+i],~i)
				foreach ch,I in s
					fbody(ch,int(I))
			}}
			st=0
			foreach ch,I in container
				if st<0:
					if I>=0:
						//Writeln('token: ',~st,' at ',I)
						fbody_outer(~st,I,token_lengths[~st])
					st=0
				chi=int(char_map[int(u8(ch))])
				st=int(i16(dfa[st*n_char_types+chi]))
		}}
	AddString=function(i64[] a,i64[] pp,string s_context,string s,iptr ofs){
		//here it's just the states
		ld=m_lang
		key_mask=(1<<ld.m_n_key_states)-1
		//do the dfa and get all tokens
		tokens=new u8[]
		foreach tok,I in EnumTokens(s_context,s)
			//I is the finishing position
			if I>ofs:break
			tokens.push(u8(tok))
		bdfa=ld.m_bracket_dfa
		for sti=0:ld.m_n_key_states-1
			pa=3*sti
			and_mask=~int(a[pa+0]>>32)
			xor_mask=int(a[pa+0])
			inc_value=0
			min_value=0
			st=ld.m_id_from_key_state[((ld.m_all_key_states[sti]&and_mask)^xor_mask)&key_mask]*ld.m_n_tokens
			foreach tok,I in tokens
				tran=bdfa[st+int(tok)]
				and_mask&=tran.m_and
				xor_mask&=tran.m_and
				xor_mask^=tran.m_xor
				st=int(tran.m_next_state)
				inc_value+=int(tran.m_delta)
				//if !sti:Write(inc_value)
				if min_value>inc_value:
					min_value=inc_value
			//if !sti:Writeln(' ',inc_value,' ',ofs)
			a[pa+2]=min(a[pa+2],a[pa+1]+i64(min_value))
			a[pa+0]=((i64(~and_mask)<<32)|i64(u32(xor_mask)))
			a[pa+1]+=i64(inc_value)
	}
	Add=function(i64[] a,i64[] b){
		ld=m_lang
		m_all_key_states=ld.m_all_key_states
		m_id_from_key_state=ld.m_id_from_key_state
		key_mask=(1<<ld.m_n_key_states)-1
		for sti=0:ld.m_n_key_states-1
			pa=3*sti
			and_maska=~int(a[pa+0]>>32)
			xor_maska=int(a[pa+0])
			//we need a state lookup to cover the happened key transitions
			pb=3*m_id_from_key_state[((m_all_key_states[sti]&and_maska)^xor_maska)&key_mask]
			and_maskb=~int(b[pb+0]>>32)
			xor_maskb=int(b[pb+0])
			and_mask=(and_maska&and_maskb)
			xor_mask=((xor_maska&and_maskb)^xor_maskb)
			a[pa+0]=((i64(~and_mask)<<32)|i64(u32(xor_mask)))
			a[pa+2]=min(a[pa+2],a[pa+1]+b[pb+2])
			a[pa+1]+=b[pb+1]
	}
	//For coloring states, we need a colorer
	//latex \: use word-based highlighting
	ComputeCharColorID=function(i64[] a,string s_context,string s){
		ld=m_lang
		crules=ld.m_coloring_rules
		bdfa=ld.m_bracket_dfa
		//////////////
		key_mask=(1<<ld.m_n_key_states)-1
		and_maska=~int(a[0]>>32)
		xor_maska=int(a[0])
		bst=ld.m_id_from_key_state[xor_maska&key_mask]*ld.m_n_tokens
		mask=xor_maska
		mask0=0
		struct TColoringEvent
			int ofs
			i8 rule_id
			i8 direction
		coloring_events=new TColoringEvent[]
		inline testEvent(I,lg_token)
			if mask!=mask0:
				//test color rules sequentially - they are only tested at color *changes*
				for i=crules.n-1:-1:0
					mask_i=crules[i].bmask
					if (mask^mask0)&mask_i:
						evt=TColoringEvent(){rule_id:i8(i)}
						if mask&mask_i:
							//we're entering, backtrack
							evt.ofs=int(I-iptr(lg_token))
							evt.direction=i8(1)
						else
							evt.ofs=int(I)
							evt.direction=i8(0)
						coloring_events.push(evt)
				mask0=mask
		testEvent(0,0)
		foreach tok,I,lg_token in EnumTokens(s_context,s)
			//ignore nest-only brackets
			tran=bdfa[bst+tok]
			//Writeln(I,' ',bst/ld.m_n_tokens,' ',tok,' ',tran,' ',mask)
			bst=int(tran.m_next_state)
			mask&=tran.m_and
			mask^=tran.m_xor
			testEvent(I,lg_token)
		coloring_events.Sortby(inline(evt){return evt.ofs})
		crule_activation=new i8[crules.n]
		ret=new u8[s.n]
		ofs_last=0L
		active_color=0
		foreach evt in coloring_events
			crule_activation[evt.rule_id]=int(evt.direction)
			if ofs_last<evt.ofs:
				for j=ofs_last:evt.ofs-1
					ret[j]=active_color
				ofs_last=evt.ofs
			active_color=0
			for ci=crule_activation.n-1:-1:0
				if crule_activation[ci]:
					active_color=ci+1
					break
		for j=ofs_last:ret.n-1
			ret[j]=active_color
		//Writeln(coloring_events)
		//Writeln(ret)
		return ret
	}
	/////////////////////////////
	//bracket seeking
	SEEK_MODE_BRACKET=0LL
	SEEK_MODE_STATE=1LL
	hasValidResult=function(i64[] a,i64[] da, i64[] b){
		if b[0]==SEEK_MODE_BRACKET:
			return a[1]+da[2]<=b[1]
		else
			assert(0)
			return 0
	}
	QueryPerCharValidity=function(i64[] a,i64[] pp,string s_context,string s, i64[] b){
		if b[0]==SEEK_MODE_BRACKET:
			ld=m_lang
			key_mask=(1<<ld.m_n_key_states)-1
			bdfa=ld.m_bracket_dfa
			cur_delta=(a[1]-b[1])
			and_mask=~int(a[0]>>32)
			xor_mask=int(a[0])
			st=ld.m_id_from_key_state[((ld.m_all_key_states[0]&and_mask)^xor_mask)&key_mask]*ld.m_n_tokens
			ret=new i8[s.n+1]
			ofs_last=0L
			is_valid=i8(cur_delta<=0LL)
			foreach tok,I in EnumTokens(s_context,s)
				for i=ofs_last:I-1
					ret[i]=is_valid
				ofs_last=I
				tran=bdfa[st+int(tok)]
				and_mask&=tran.m_and
				xor_mask&=tran.m_and
				xor_mask^=tran.m_xor
				st=int(tran.m_next_state)
				cur_delta+=i64(tran.m_delta)
				is_valid=i8(cur_delta<=0LL)
			for i=ofs_last:ret.n-1
				ret[i]=is_valid
			return ret
		else
			assert(0)
			return i8[].NULL
	}
	////////////////////
	//for JS operations
	__JS_prototype=function(JSObject proto){}

registerUIExtension(function(JSObject JS_UI,CUISandbox sbox,int is_real){
	JS_UI["CreateLanguageDefinition"]=function(JSContext JS){
		//create from a LanguageDefinition object
		obj=JS.Param(0).as(JSObject)
		if !obj:return JS.ReturnError("undefined language definition object")
		ret=new CLanguageDescription
		//bigchar part
		m_big_chars=obj["m_big_chars"].as(JSObject)
		if !m_big_chars:return JS.ReturnError("undefined token list")
		native_bigchars=new string[]
		token_lengths=new u8[]
		char_map=new u8[256]
		context_size=0L
		for i=0:m_big_chars.length()-1
			s_bigchar_i=m_big_chars[i].or("")
			if !s_bigchar_i.n:return JS.ReturnError("tokens cannot be empty")
			native_bigchars.push(s_bigchar_i)
			token_lengths.push(int(s_bigchar_i.n))
			foreach ch in s_bigchar_i
				char_map[int(u8(ch))]=1
			context_size=max(context_size,s_bigchar_i.n)
		ret.m_context_size=int(context_size)
		////////////////////////////
		//we need bigchars to be a prefix code, but no checking yet
		//it's just AhoCorasick... but the builtin implementation is not for this
		//here we can affored precomputation, but runtime cost should be minimized: no funny business with next
		//and we can do it 8-bit - don't need awareness to handle UTF8
		assert(native_bigchars.n<128)
		n_char_types=1
		for i=0:255
			if char_map[i]:
				char_map[i]=n_char_types
				n_char_types++
		assert(n_char_types<=256)
		fc_lists=new int[][n_char_types]
		for i=0:fc_lists.n-1
			fc_lists[i]=new int[]
		foreach spattern,I in native_bigchars
			ch0=int(u8(spattern[0]))
			if spattern.n==1:
				state=~int(I)
			else
				state=int(I)|(1<<16)
			fc_lists[int(char_map[ch0])].push(state)
		//multi-state DFA -> single-state DFA
		state_map=new int[int[]]
		ops_map=new int[u16[]]
		state_addrs=[0]
		Q=[new int[]]
		dfa=new u16[n_char_types]
		dfa_ops=new u16[]
		reached=new i8[native_bigchars.n]
		for(i=0L;i<Q.n;i++)
			cur_states=Q[i]
			my_addr=i*n_char_types
			tran=new int[][n_char_types]
			for j=0:tran.n-1
				tran[j]=new(fc_lists[j])
			//fc_lists
			foreach stpacked in cur_states
				pid=(stpacked&0xffff)
				pos=(stpacked>>16)
				s_pid=native_bigchars[pid]
				ch_std=int(char_map[int(u8(s_pid[pos]))])
				pos++
				if pos>=s_pid.n:
					//add action
					tran[ch_std].push(~pid)
				else
					tran[ch_std].push(pid+(pos<<16))
			//Write(cur_states,' ')
			for j=0:tran.n-1
				new_states=tran[j]
				new_states.Sort()
				new_states.Unique()
				actions=u16[].NULL
				if new_states.n&&new_states[0]<0:
					//actions - higher pid should take higher priority and get sorted first
					//coulddo: substring case... defer the action
					new_stid=new_states[0]
					reached[~new_states[0]]=1
				else
					new_stid=state_map[new_states]
					if !new_stid:
						if new_states.n:
							new_stid=int(Q.n)
							Q.push(new_states)
							dfa.resize(dfa.n+n_char_types)
							assert(dfa.n==n_char_types*Q.n)
							state_map[new_states]=new_stid
				dfa[my_addr+j]=u16(new_stid)
		ret.m_char_map=char_map
		ret.m_n_char_types=n_char_types
		ret.m_bigchar_dfa=dfa
		for i=0:reached.n-1
			if !reached[i]:
				Writeln("warning: big char '@1' can never get triggered".Replace(["@1",native_bigchars[i]]))
		/////////////
		//the list of brackets
		m_bracket_types=obj["m_bracket_types"].as(JSObject)
		if !m_bracket_types:return JS.ReturnError("undefined bracket types")
		n_key_brackets=0
		brackets=new TBracketType[]
		auto parseTokenSet(JSObject obj,string s_name)
			auto obj_set=obj[s_name].as(JSObject)
			auto n=obj_set.length()
			auto ret_set=new int[n]
			for j=0:n-1
				ret_set[j]=obj_set[j].or(0)
			return ret_set
		for i=0:m_bracket_types.length()-1
			obj_i=m_bracket_types[i].as(JSObject)
			if !obj_i:return JS.ReturnError("undefined bracket type")
			type=obj_i["type"].or(REAL_TYPE_MOV)
			is_key=obj_i["is_key"].or(0)
			if is_key:
				assert(n_key_brackets==i)
				n_key_brackets=i+1
			tok0=parseTokenSet(obj_i,"tok0")
			tok1=parseTokenSet(obj_i,"tok1")
			brackets.push(TBracketType(){type:type,tok0:tok0,tok1:tok1})
		assert(n_key_brackets<=12)
		/////////////
		//the state masking rules
		m_enabled_from_inside=new int[1<<n_key_brackets]
		m_id_from_key_state=new int[1<<n_key_brackets]
		m_all_key_states=new int[]
		m_entry_states=obj["m_entry_states"].as(JSObject)
		if !m_entry_states:return JS.ReturnError("undefined entry states")
		for i=0:m_entry_states.length()-1
			obj_i=m_entry_states[i].as(JSObject)
			if !obj_i:return JS.ReturnError("undefined entry state")
			inside_mask=obj_i["inside"].or(0)
			m_enabled_from_inside[inside_mask]=obj_i["enabled"].or(0)
			m_id_from_key_state[inside_mask]=i+1
			m_all_key_states.push(inside_mask)
		for i=0:m_id_from_key_state.n-1
			m_id_from_key_state[i]--
		ret.m_all_key_states=m_all_key_states
		/////////////
		//the bracket DFA
		m_contradiction_fixes=obj["m_contradiction_fixes"].as(JSObject)
		n_key_states=m_all_key_states.n
		n_tokens=native_bigchars.n
		bdfa=new TBDFATransition[n_key_states*n_tokens]
		assert(bdfa.n<32768)
		for sti=0:n_key_states-1
			st=sti*n_tokens
			key_state=m_all_key_states[sti]
			enabled_mask=m_enabled_from_inside[key_state]
			for i=0:brackets.n-1
				if !(enabled_mask&(1<<i)):continue
				type=brackets[i].type
				tok0=brackets[i].tok0
				tok1=brackets[i].tok1
				mask_i=1<<i
				if type==REAL_TYPE_MOV:
					//m_and will be not-ed later
					foreach tok in tok0
						bdfa[st+tok].m_and|=mask_i
						bdfa[st+tok].m_xor|=mask_i
					foreach tok in tok1
						bdfa[st+tok].m_and|=mask_i
				else if type==REAL_TYPE_XOR:
					foreach tok in tok0
						bdfa[st+tok].m_xor|=mask_i
					foreach tok in tok1
						bdfa[st+tok].m_xor|=mask_i
				else if type==REAL_TYPE_ADD:
					foreach tok in tok0
						assert(!bdfa[st+tok].m_delta)
						bdfa[st+tok].m_delta+=i16(1)
					foreach tok in tok1
						assert(!bdfa[st+tok].m_delta)
						bdfa[st+tok].m_delta+=i16(-1)
				else
					assert(0)
			for i=0:n_tokens-1
				bdfa[st+i].m_and=~bdfa[st+i].m_and
				key_state_i=((key_state&bdfa[st+i].m_and)^bdfa[st+i].m_xor)
				if m_id_from_key_state[key_state_i]<0:
					//self-contradicting transition, correct it by anding the enabling mask
					key_state_i=m_contradiction_fixes[key_state_i].as(int)
				assert(m_id_from_key_state[key_state_i]>=0)
				bdfa[st+i].m_next_state=u16((m_id_from_key_state[key_state_i])*n_tokens)
		ret.m_id_from_key_state=m_id_from_key_state
		ret.m_n_key_states=n_key_states
		ret.m_token_lengths=token_lengths
		ret.m_n_tokens=n_tokens
		ret.m_bracket_dfa=bdfa
		/////////////
		//the coloring rules
		m_coloring_rules=obj["m_coloring_rules"].as(JSObject)
		ret.m_coloring_rules=new TColorRule[]
		for i=0:m_coloring_rules.length()-1
			obj_i=m_coloring_rules[i].as(JSObject)
			if !obj_i:return JS.ReturnError("undefined coloring rules")
			bid=obj_i["bid"].or(0)
			ret.m_coloring_rules.push(TColorRule(){
				color_name:obj_i["color_name"].or(""),
				bmask:1<<bid})
		/////////
		//1 bitmask + 1 counter for each nested + 1 min
		ret.m_total_state_size=3*m_all_key_states.n
		/////////
		//the word colorer, which is stand-alone
		//we have keywords and starting chars
		ret.m_default_color_name=obj["m_color_default"].as(string)
		///////
		clunky_dfa=new int[]
		word_char_map=new u8[256]
		for ch=0:255
			if !(ch<128&&isWordChar(ch)):
				word_char_map[ch]=1
		n_word_char_types=2
		word_color_id_map=new int[string]
		/////////////
		ret.m_word_color_names=new string[]
		ret.m_word_color_names.push("<none>")
		auto getWordColorID(string s_color)
			auto color_id=word_color_id_map[s_color]-1
			if color_id<0:
				color_id=int(ret.m_word_color_names.n)
				ret.m_word_color_names.push(s_color)
				word_color_id_map[s_color]=color_id+1
			return color_id
		m_keyword_sets=obj["m_keyword_sets"].as(JSObject)
		init_state_by_kwset=new int[]
		for ksi=0:m_keyword_sets.length()-1
			keyword_set_i=m_keyword_sets[ksi].as(JSObject)
			id_default=getWordColorID(keyword_set_i["m_word_color_default"].as(string))
			st0=int(clunky_dfa.n>>8)
			init_state_by_kwset.push(st0)
			clunky_dfa.resize(st0*256+256)
			for i=0:255
				clunky_dfa[st0*256+i]=~id_default
			//[word,color, ...]
			keywords=keyword_set_i["m_keywords"].as(JSObject)
			//[MakeCharSet,color, ...]
			word_openers=keyword_set_i["m_word_openers"].as(JSObject)
			for i=0:2:keywords.length()-2
				s_word=keywords[i+0].as(string)
				s_color=keywords[i+1].as(string)
				color_id=word_color_id_map[s_color]
				if !color_id:
					color_id=int(ret.m_word_color_names.n)
					ret.m_word_color_names.push(s_color)
					word_color_id_map[s_color]=color_id
				//DFA insertion
				st=st0
				foreach ch,I in s_word
					//all keyword chars are unique
					chi=int(u8(ch))
					if !word_char_map[chi]:
						word_char_map[chi]=n_word_char_types
						n_word_char_types++
					if clunky_dfa[st*256+chi]<0:
						n0=int(clunky_dfa.n)
						clunky_dfa[st*256+chi]=(n0>>8)
						clunky_dfa.resize(n0+256)
						for j=0:255
							clunky_dfa[n0+j]=~id_default
					st=clunky_dfa[st*256+chi]
				clunky_dfa[st*256+0]=(~color_id)
			for i=0:2:word_openers.length()-2
				cset=MakeCharSet(word_openers[i+0].as(string))
				s_color=word_openers[i+1].as(string)
				color_id=word_color_id_map[s_color]
				if !color_id:
					color_id=int(ret.m_word_color_names.n)
					ret.m_word_color_names.push(s_color)
					word_color_id_map[s_color]=color_id
				for ch=0:255
					if isInCharSet(cset,ch):
						if !word_char_map[ch]:
							word_char_map[ch]=n_word_char_types
						clunky_dfa[st0*256+ch]=~color_id
				n_word_char_types++
		ret.m_word_char_map=word_char_map
		ret.m_n_word_char_types=n_word_char_types
		//compact the clunky_dfa
		word_char_representatives=new int[n_word_char_types]
		for ch=255:-1:0
			word_char_representatives[word_char_map[ch]]=ch
		word_dfa=new int[(clunky_dfa.n>>8)*n_word_char_types]
		for sti=0:256:clunky_dfa.n-256
			st_final=(sti>>8)*n_word_char_types
			for i=0:n_word_char_types-1
				tran_i=clunky_dfa[sti+word_char_representatives[i]]
				if tran_i>=0:tran_i*=n_word_char_types
				word_dfa[st_final+i]=tran_i
		ret.m_word_dfa=word_dfa
		//set the per-rule initial states
		ret.m_trigger_chars=obj["m_trigger_char"].as(string)
		m_word_dfa_initial_state=obj["m_word_dfa_initial_state"].as(JSObject)
		m_word_dfa_initial_state_triggered=obj["m_word_dfa_initial_state_triggered"].as(JSObject)
		n=m_word_dfa_initial_state.length()
		assert(n==ret.m_coloring_rules.n+1)
		ret.m_word_dfa_initial_state=new int[n]
		ret.m_word_dfa_initial_state_triggered=new int[n]
		//////////////
		for i=0:m_word_dfa_initial_state.length()-1
			st=m_word_dfa_initial_state[i].as(int)
			if st>=0:
				st=init_state_by_kwset[st]*n_word_char_types
			stt=m_word_dfa_initial_state_triggered[i].as(int)
			if stt>=0:
				stt=init_state_by_kwset[stt]*n_word_char_types
			else
				stt=st
			ret.m_word_dfa_initial_state[i]=st
			ret.m_word_dfa_initial_state_triggered[i]=stt
		return JS.Return(ret)
	}
})

class CSeeker_indentation
	name=function(){return "seeker_indentation"}
	stateSize=function(){return 1}
	contextSize=function(){return MAX_ALLOWED_INDENTATION}
	/////////
	inline EnumLineIndentation(string s_context,string s)
		return {'forEach':inline(fbody_outer){
			sz_context=s_context.n
			container={'forEach':inline(fbody){
				for i=0:sz_context-1
					fbody(s_context[s_context.n-sz_context+i],~i)
				foreach ch,I in s
					fbody(ch,int(I))
			}}
			//place the values at the enhanced homes
			//blank lines do not count
			n_ind=0
			foreach ch,I in container
				if ch==' '||ch=='\t':
					if n_ind>=0:n_ind++
				else
					if ch=='\r':
						//ignore, make it invalid
						n_ind=-1
						continue
					else if ch=='\n':
						//new line, reset n_ind without triggering outer loop
						n_ind=0
						continue
					if n_ind>=0:
						if I>=0:
							fbody_outer(min(n_ind,MAX_ALLOWED_INDENTATION),I)
						n_ind=-1
		}}
	/////////
	AddString=function(i64[] a,i64[] pp,string s_context,string s,iptr ofs){
		ind_min=int(a[0])+MAX_ALLOWED_INDENTATION
		foreach ind,I in EnumLineIndentation(s_context,s[:ofs-1])
			if ind_min>ind:
				ind_min=ind
		a[0]=i64(ind_min-MAX_ALLOWED_INDENTATION)
	}
	Add=function(i64[] a,i64[] b){
		a[0]=min(a[0],b[0])
	}
	hasValidResult=function(i64[] a,i64[] da, i64[] b){
		return da[0]+i64(MAX_ALLOWED_INDENTATION)<=b[0]
	}
	QueryPerCharValidity=function(i64[] a,i64[] pp,string s_context,string s, i64[] b){
		ret=new i8[s.n]
		goal=int(b[0])
		foreach ind,I in EnumLineIndentation(s_context,s)
			if ind<=goal:
				ret[I]=1
		return ret
	}

registerStateHandler("renderer_programmer",CLayouter_programmer)
registerStateHandler("colorer_programmer",CColorer_programmer)
registerStateHandler("seeker_indentation",CSeeker_indentation)

///////////////////////////////////////////
NEXT_READ_SIZE=4194304
INITIAL_READ_SIZE=16777216//2097152
WRITE_BATCH=4194304
class CLoadingContext
	i64 sz
	//////////
	//string fn
	System.IO.CFile hf
	//////////
	float progress
	__JS_prototype=function(JSObject proto){
		proto.ExportProperty(this,"progress")
	}

class CSavingContext
	CEditableText ed
	i64 ofs
	//////////
	string fn
	System.IO.CFile hf
	//////////
	float progress
	__JS_prototype=function(JSObject proto){
		proto.ExportProperty(this,"progress")
	}

///////////////////////////////////////////
inline chrequi(ch0,chw0)
	ch=int(ch0)
	chw=int(chw0)
	return ch0==chw0||(ch^chw)==0x20&&u32((ch|0x20)-int('a'))<26u

auto KmpBuildTable(string s,int ocase)
	if !s.n:return [-1]
	next=new int[s.n+1]
	next[0]=-1
	for i=1:s.n
		i0=next[i-1]
		ch=s[i-1]
		while i0>=0:
			if s[i0]==ch||!ocase&&chrequi(s[i0],ch):
				break
			i0=next[i0]
		next[i]=i0+1
	for i=1:s.n-1
		x=next[i]
		while x>0&&(s[x]==s[i]||!ocase&&chrequi(s[x],s[i])):
			x=next[x]
		next[i]=x
	//use next[s.n] for match denial
	return next

auto SearchPlainText(CEditableText ed,i64 ccnt_starting,const direction, string s,int ocase,function(i64,i64):int ReportMatch, int budget)
	//use KMP: two-part is not worth it here
	sfind=(direction>0?s:[ch for ch in s.ReverseOrder()])
	if ocase:
		sfind2=sfind
	else
		sfind2=sfind.ToLower()
		sfind=sfind.ToUpper()
	lg=sfind.n
	fnext=KmpBuildTable(sfind,ocase)
	pbudget=budget
	w=0
	for ch,ccnt in direction>0?ed.enumCharsForward(ccnt_starting):ed.enumCharsBackward(ccnt_starting)
		for(;;)
			if ch==sfind[w]:break
			if ch==sfind2[w]:break
			w=fnext[w]
			if w<0:break
		w++
		if w>=lg:
			//got match
			if direction<0:
				ccnt0=ccnt
				ccnt1=ccnt+lg
			else
				ccnt1=ccnt+1
				ccnt0=ccnt1-lg
			pbudget-=ReportMatch(ccnt0,ccnt1)
			w=0
		pbudget--
		if pbudget<=0:
			//we are out of budget, exit
			return ccnt+w*i64(-direction)
	return -1LL

SEARCH_FLAG_CASE_SENSITIVE=1
SEARCH_FLAG_WHOLE_WORD=2
SEARCH_FLAG_REGEXP=4
class CRegexpSearchContext
	int has6,has4
	i64 ccnt,ccnt_base
	RegexIncrementalMatcher matcher
	iptr[] match0
	__JS_prototype=function(JSObject proto){
		proto.ExportProperty(this,"ccnt")
	};

auto SearchRegexp(JSContext JS,CEditableText ed,const dir,string sregexp,int flags,function(i64,i64):int ReportMatch, int budget)
	//use the old regexp code - duk code too complicated
	ctx=JS.Param(1).as(CRegexpSearchContext)
	if !ctx:
		ccnt_starting=JS.Param(1).as(i64)
		//6:^, 4:$
		has6=0;has4=0
		se=sregexp
		if se.n&&se[0]=='^':
			se=se[1:]
			has6=1
		if se.n&&se.back()=='$':
			se=se[:se.n-2]
			has4=1
		if se=="":se="\"\""
		reo=ParseRegex(se)
		if !(flags&SEARCH_FLAG_CASE_SENSITIVE):reo=RegexMakeCaseInsensitive(reo)
		reo=RegexBracket(reo)
		if has6&&dir>0:
			reo=ParseRegex("\n")+reo
		if has4&&dir<0:
			reo=reo+ParseRegex("\r?\n")
		if dir<0:
			reo=reo+ParseRegex("[\\x00-\\xff]*?")
			regex=RegexReverse(reo)
		else
			reo=ParseRegex("[\\x00-\\xff]*?")+reo
			regex=new Regex(reo)
		matcher=regex.Matcher()
		ccnt_base=ccnt_starting
		if dir>0?has6:has4:
			matcher.Add('\n')
			ccnt_base-=dir
		match0=iptr[].NULL
		ctx=new CRegexpSearchContext(){matcher:matcher,has4:has4,has6:has6,ccnt:ccnt_starting,ccnt_base:ccnt_base,match0:match0}
	else
		matcher=ctx.matcher
		ccnt_starting=ctx.ccnt
		ccnt_base=ctx.ccnt_base
		has4=ctx.has4
		has6=ctx.has6
		match0=ctx.match0
	has_tail_enter=0
	if dir>0?has4:has6:
		has_tail_enter=1
	pbudget=budget
	testMatch=function(int ch,i64 ccnt,iptr[] match){
		assert(match.n>=2)
		auto ccnt0=ccnt_base+dir*match[match.n-2]
		auto ccnt1=ccnt_base+dir*match[match.n-1]
		if dir<0:
			tmp=ccnt0;ccnt0=ccnt1;ccnt1=tmp
		auto match_is_invalid=0
		if ccnt0==ccnt1&&!has6&&!has4:
			//ignore zero-sized matches except when we have $/^
			match_is_invalid=1
		if !match_is_invalid&&(flags&SEARCH_FLAG_WHOLE_WORD):
			(ch0,ch1)=ed.GetUtf8CharNeighborhood(ccnt0)
			(ch0x,ch1x)=ed.GetUtf8CharNeighborhood(ccnt1)
			if isWordChar(ch0)==isWordChar(ch1)||isWordChar(ch0x)==isWordChar(ch1x):
				match_is_invalid=1
		if !match_is_invalid:
			(ch0,ch1)=ed.GetCharNeighborhood(ccnt0)
			if has6&&ch0!='\n':
				match_is_invalid=1
			(ch0,ch1)=ed.GetCharNeighborhood(ccnt1)
			if has4&&ch1!='\n'&&ch1!='\r':
				match_is_invalid=1
		if !match_is_invalid:
			pbudget-=ReportMatch(ccnt0,ccnt1)*16
		matcher.Clear()
		matcher.Add(char(ch))
		ccnt_base=ccnt+(dir<0)
		match0=matcher.GetMatch()
	}
	for ch,ccnt in dir>0?ed.enumCharsForward(ccnt_starting):ed.enumCharsBackward(ccnt_starting)
		matcher.Add(char(ch))
		auto match=matcher.GetMatch()
		is_sliding=0
		if match0&&match&&(match0[match0.n-2]!=match[match.n-2]):
			is_sliding=1
			match=match0
		match0=match
		if (is_sliding||!matcher.is_matching())&&match:
			testMatch(int(u8(ch)),ccnt,match)
		////////////////////////
		pbudget-=16
		if pbudget<=0:
			//we are out of budget, exit
			ctx.match0=match0
			ctx.ccnt=ccnt+(dir>0)
			ctx.ccnt_base=ccnt_base
			return JS.Return(ctx)
	ch=(has_tail_enter?int('\n'):-1)
	if ch!=-1:matcher.Add(char(ch))
	match=matcher.GetMatch()
	is_sliding=0
	if match0&&match&&(match0[match.n-2]!=match[match.n-2]):
		is_sliding=1
		match=match0
	match0=match
	if (is_sliding||!matcher.is_matching()||ch==-1)&&match:
		testMatch(ch,dir>0?ed.GetTextSize():-1LL,match)
	return JS.Return(-1LL)
	
///////////////////////////////////////////
class CReplaceJob
	m_ops=new TEditop[]
	string m_s_replace
	m_match_cost=64
	
registerUIExtension(function(JSObject JS_UI,CUISandbox sbox,int is_real){
	JS_UI["EDLoader_Open"]=function(JSContext JS){
		//initial read, which is a raw edit
		ed=JS.Param(0).as(CEditableText)
		fn=JS.Param(1).or(new string)
		hf=System.IO.OpenFile(fn)
		if !hf:return 0
		s=hf.Read(INITIAL_READ_SIZE)
		if s.n:
			ed.RawEdit([TEditop(){s:s}])
		if s.n<INITIAL_READ_SIZE:
			hf.Close()
			return JS.Return(0)
		ret=new CLoadingContext
		ret.sz=System.IO.GetFileSize(fn)
		//ret.fn=fn
		ret.hf=hf
		ret.progress=float(min(double(hf.Position())/double(max(ret.sz,1LL)),1.0))
		return JS.Return(ret)
	}
	JS_UI["EDLoader_Read"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		ret=JS.Param(1).as(CLoadingContext)
		hf=ret.hf
		//todo: UTF-8 boundary, encoding, ...
		s=hf.Read(NEXT_READ_SIZE)
		if s.n:
			//t0=System.Time.tick64()
			ed.RawEdit([TEditop(){ccnt:ed.GetTextSize(),s:s}])
			//Writeln('insertion: ',System.Time.TicksToSeconds(System.Time.tick64()-t0)*1000.0,' ',s.n)
		if s.n<NEXT_READ_SIZE:
			hf.Close()
			return JS.Return(0)
		ret.progress=float(min(double(hf.Position())/double(max(ret.sz,1LL)),1.0))
		return JS.Return(ret)
	}
	JS_UI["EDSaver_Open"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		fn=JS.Param(1).or(new string)
		ret=new CSavingContext
		ret.fn=fn
		ret.hf=System.IO.CreateFile(fn+".$$$")
		ret.ed=ed
		if !ret.hf:return 0
		return JS.Return(ret)
	}
	JS_UI["EDSaver_Write"]=function(JSContext JS){
		ret=JS.Param(0).as(CSavingContext)
		ofs=ret.ofs
		ed=ret.ed
		szmax=ed.GetTextSize()
		szwrite=int(min(szmax-ofs,i64(WRITE_BATCH)))
		if szwrite>0:
			s=ed.GetText(ofs,i64(szwrite))
			if ret.hf.Write(s)<s.n:
				return JS.Return("failed")
		ret.ofs+=i64(szwrite)
		if ret.ofs>=szmax:
			ret.hf.Close()
			if !System.IO.DeleteFile(ret.fn)&&System.IO.FileExists(ret.fn):
				return JS.Return("failed")
			if !System.IO.MoveFile(ret.fn+".$$$",ret.fn):
				return JS.Return("failed")
			return JS.Return("done")
		ret.progress=f32(ret.ofs)/f32(szmax)
		return JS.Return("continue")
	}
	JS_UI["ED_Search"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		direction=JS.Param(2).or(1)
		s=JS.Param(3).as(string)
		flags=JS.Param(4).as(int)
		budget=JS.Param(5).as(int)
		js_callback=JS.Param(6).as(JSObject)
		js_this=JS.Param(7).as(JSObject)
		/////////////
		if !js_callback:
			//need a context for m_match_cost and stuff
			rjob=js_this["m_current_replace_job"].as(CReplaceJob)
			if !rjob:
				rjob=new CReplaceJob
				rjob.m_match_cost=js_this["m_match_cost"].or(rjob.m_match_cost)
				rjob.m_s_replace=js_this["m_s_replace"].as(string)
				js_this["m_current_replace_job"]=rjob
			ops=rjob.m_ops
			//replace mode
			if flags&SEARCH_FLAG_REGEXP:
				ReportMatch=function(i64 ccnt0,i64 ccnt1){
					ops.push(TEditop(){ccnt:ccnt0,sz:ccnt1-ccnt0,s:rjob.m_s_replace})
					return rjob.m_match_cost
				}
			else
				ReportMatch=function(i64 ccnt0,i64 ccnt1){
					if flags&SEARCH_FLAG_WHOLE_WORD:
						(ch0,ch1)=ed.GetUtf8CharNeighborhood(ccnt0)
						if isWordChar(ch0)==isWordChar(ch1):return 0
						(ch0,ch1)=ed.GetUtf8CharNeighborhood(ccnt1)
						if isWordChar(ch0)==isWordChar(ch1):return 0
					ops.push(TEditop(){ccnt:ccnt0,sz:ccnt1-ccnt0,s:rjob.m_s_replace})
					return rjob.m_match_cost
				}
		else
			if flags&SEARCH_FLAG_REGEXP:
				ReportMatch=function(i64 ccnt0,i64 ccnt1){
					return js_callback.CallAsMethod(int,js_this,ccnt0,ccnt1)
				}
			else
				ReportMatch=function(i64 ccnt0,i64 ccnt1){
					if flags&SEARCH_FLAG_WHOLE_WORD:
						(ch0,ch1)=ed.GetUtf8CharNeighborhood(ccnt0)
						if isWordChar(ch0)==isWordChar(ch1):return 0
						(ch0,ch1)=ed.GetUtf8CharNeighborhood(ccnt1)
						if isWordChar(ch0)==isWordChar(ch1):return 0
					return js_callback.CallAsMethod(int,js_this,ccnt0,ccnt1)
				}
		if flags&SEARCH_FLAG_REGEXP:
			//the regexp version returns an object to JS
			if direction>0:
				return SearchRegexp(JS,ed,1, s,flags,ReportMatch, budget)
			else
				return SearchRegexp(JS,ed,-1, s,flags,ReportMatch, budget)
		else
			ocase=(flags&SEARCH_FLAG_CASE_SENSITIVE)
			ccnt0=JS.Param(1).as(i64)
			if direction>0:
				ret=SearchPlainText(ed,ccnt0,1, s,ocase,ReportMatch, budget)
			else
				ret=SearchPlainText(ed,ccnt0,-1, s,ocase,ReportMatch, budget)
		return JS.Return(ret)
	}
	//this is not hook-friendly
	JS_UI["ED_ApplyReplaceOps"]=function(JSContext JS){
		ed=JS.Param(0).as(CEditableText)
		rjob=JS.Param(1).as(CReplaceJob)
		if !ed||!rjob:return JS.ReturnError("invalid parameters")
		//for now, just do it the dumb way
		n=rjob.m_ops.n
		ed.Edit(rjob.m_ops)
		return JS.Return(n)
	}
})
