import "gui2d.jc"
import "text-box.jc"
import System.Math.*
import System.Algorithm.*
import System.Console.*
import Gui2D.detail.*
import TextBox.detail.*
import Javascript.*
import TextBox.*

///////////
//pad the meta stuff to avoid accidental search hits
//META_CHAR=1
//META_CHAR_END=2
/////////////
//COMMAND_INSERT_OBJECT=3
//COMMAND_SET_STYLE=4
//COMMAND_RUBBER_SPACE=5
/////////////
//CHAR_NUMBERING_BASE=0xf0000
COMMAND_INSERT_OBJECT=0x100000
COMMAND_RUBBER_SPACE=0x107fff
COMMAND_SET_STYLE=0x108000
COMMAND_END=0x110000

///////////////////////////////
class CHyphenator
	int[][string] exceptions
	u16[] dfa
	u16[] ops
	int n_char_types
	int[int] char_map
	left_min=3
	right_min=3
	auto HyphenateWord(string sword)
		exception=exceptions[sword.ToLower()]
		if exception:return exception
		//if sword.n<min_hyphen:return new int[]
		//returns int separation points
		hyp_levels=new u8[]
		hyp_points=new int[]
		n=n_char_types
		local_dfa=dfa
		local_char_map=char_map
		local_ops=ops
		st=0
		inline goDown(int ch)
			st=int(local_dfa[st*n+ch])
			if st>=32768:
				st-=32768
				for(;;)
					op=int(local_ops[st])
					if op>=32768:
						st=op-32768
						break
					//4as. - it *could* try to place a value on pos 0
					addr=int(hyp_levels.n)-(op&0xff)
					if u32(addr)<u32(hyp_levels.n):
						lv0=int(hyp_levels[addr])
						lv1=(op>>8)
						if lv0<lv1:
							hyp_levels[addr]=lv1
					//else
					//	Writeln(int(hyp_levels.n),' ',(op&0xff))
					assert(u32(addr+1)<=u32(hyp_levels.n))
					st++
		goDown(0)
		foreach ch,I in Utf8Chars(sword)
			hyp_points.push(int(I))
			hyp_levels.push(u8(0))
			goDown(local_char_map[ch])
		hyp_points.push(int(sword.n))
		hyp_levels.push(u8(0))
		goDown(0)
		//use -3 to make sure we ignore the word tail
		//Writeln(hyp_levels)
		//Writeln(hyp_points)
		n2=0
		for i=0:hyp_points.n-3
			if (int(hyp_levels[i])&1)&&i>=left_min&&i<sword.n-right_min:
				hyp_points[n2++]=hyp_points[i+1]
		hyp_points.resize(n2)
		return hyp_points
	auto debugDumpHyphenation(string sword)
		hyp_points=[0]
		hyp_points.push(HyphenateWord(sword))
		hyp_points.push(int(sword.n))
		s=new string
		for i=0:hyp_points.n-2
			if i:SWrite(s,'-')
			SWrite(s,sword[hyp_points[i]:hyp_points[i+1]-1])
		return s
	JS_toString=function(JSContext JS){
		obj_big=JS.New()
		obj_temp=JS.NewArray();p=0
		foreach d,k in exceptions
			obj_temp[p]=k;p++
			obj_temp[p]=d;p++
		obj_big["exceptions"]=obj_temp
		obj_temp=JS.NewArray();p=0
		foreach d,k in char_map
			obj_temp[p]=k;p++
			obj_temp[p]=d;p++
		obj_big["char_map"]=obj_temp
		obj_big["left_min"]=left_min
		obj_big["right_min"]=right_min
		obj_big["n_char_types"]=n_char_types
		obj_big["size_dfa"]=dfa.n
		obj_big["size_ops"]=ops.n
		s0=new string
		s0.push(JS.GetGlobal()["JSON"].CallMethod(string,"stringify",obj_big))
		s0.push('\n')
		if s0.n&1:
			s0.push('\n')
		s0.push(dfa[0:].ConvertToAsBinary(char))
		s0.push(ops[0:].ConvertToAsBinary(char))
		return JS.Return(s0)
	}
	__JS_prototype=function(JSObject proto){
		proto.ExportMethod(this,"toString",JS_toString)
	}

auto createNullHyphenator()
	ret=new CHyphenator
	ret.exceptions=new int[][string]
	ret.dfa=[u16(0)]
	ret.ops=new u16[]
	ret.n_char_types=1
	ret.char_map=new int[int]
	return ret

g_null_hyphenator=createNullHyphenator()

auto parseCachedHyphenator(JSContext JS,string sdata)
	pline=sdata.IndexOf('\n')
	if pline<0:return CHyphenator.NULL
	obj_big=JS.GetGlobal()["JSON"].CallMethod(JSObject,"parse",sdata[:pline-1])
	if (pline+1)&1:pline++
	pu16=sdata[pline+1:].ConvertToAsBinary(u16)
	ret=new CHyphenator
	ret.left_min=obj_big["left_min"].as(int)
	ret.right_min=obj_big["right_min"].as(int)
	ret.n_char_types=obj_big["n_char_types"].as(int)
	size_dfa=obj_big["size_dfa"].as(int)
	size_ops=obj_big["size_ops"].as(int)
	ret.dfa=pu16[:size_dfa-1]
	ret.ops=pu16[size_dfa:]
	///////////
	obj_temp=obj_big["char_map"].as(JSObject)
	n=obj_temp.length()
	assert(!(n&1))
	ret.char_map=new int[int]
	for i=0:2:n-2
		k=obj_temp[i+0].as(int)
		d=obj_temp[i+1].as(int)
		ret.char_map[k]=d
	obj_temp=obj_big["exceptions"].as(JSObject)
	n=obj_temp.length()
	assert(!(n&1))
	ret.exceptions=new int[][string]
	for i=0:2:n-2
		k=obj_temp[i+0].as(string)
		obj_value=obj_temp[i+1].as(JSObject)
		m_i=obj_value.length()
		d=new int[m_i]
		for j=0:m_i-1
			d[j]=obj_value[j].as(int)
		ret.exceptions[k]=d
	return ret

auto parseTexHyphenFile(JSContext JS,string sdata)
	//pack ops at the tail as i8
	ret=new CHyphenator
	is_pattern=1
	all_patterns=new string[]
	all_exceptions=new int[][string]
	foreach sline in sdata.Tokenize("\r\n")
		if sline[0]=='%':continue
		if sline[0]=='\\':
			is_pattern=(sline.StartsWith("\\pattern"))
			continue
		if sline.n>=128:
			if Platform.BUILD=="debug":
				Writeln('pattern too long: ',sline)
			return CHyphenator.NULL
		if sline[0]=='{'||sline[0]=='}':continue
		spattern=new string
		if is_pattern:
			//insert into 
			ops=new string
			foreach chc,I in sline
				ch=int(u8(chc))
				if u32(ch-int('0'))<10u:
					ops.push(i8(spattern.n))
					ops.push(i8(ch-int('0')))
				else
					spattern.push(chc)
			spattern.push(i8(0))
			all_patterns.push(spattern+ops)
		else
			opsi=new int[]
			foreach chc,I in sline
				if chc=='-':
					opsi.push(int(spattern.n))
				else
					spattern.push(chc)
			all_exceptions[spattern]=opsi
			//Writeln(spattern,' ',opsi)
	ret.exceptions=all_exceptions
	///////////
	//todo: make this a function
	chappeared=new int[int]
	foreach spattern in all_patterns
		foreach ch,I in Utf8Chars(spattern)
			if !ch:break
			if ch!=char('.'):
				chappeared[ch]=1
	chlist=new int[]
	foreach d,k,I in chappeared
		chlist.push(k)
		chappeared.D(I)=int(chlist.n)
	//do the upper case
	chlist_upper=Utf8ToUnicode32(JS["String"]["prototype"]["toUpperCase"].CallAsMethod(string,Unicode32ToUtf8(chlist)))
	if chlist_upper.n!=chlist.n:
		if Platform.BUILD=="debug":
			Writeln('bad upper case conversion');
			Writeln('  ',Unicode32ToUtf8(chlist))
			Writeln('  ',Unicode32ToUtf8(chlist_upper))
		return CHyphenator.NULL
	for i=0:chlist.n-1
		chappeared[chlist_upper[i]]=chappeared[chlist[i]]
	ret.char_map=chappeared
	n_char_types=int(chlist.n+1)
	ret.n_char_types=n_char_types
	//first-char lists
	//all_patterns.Sort()
	fc_lists=new int[][n_char_types]
	for i=0:fc_lists.n-1
		fc_lists[i]=new int[]
	foreach spattern,I in all_patterns
		ch0=Utf8CodeAt(spattern,0L)
		fc_lists[chappeared[ch0]].push(int(I)|(1<<16))
	//multi-state DFA -> single-state DFA
	if all_patterns.n>=32768:
		if Platform.BUILD=="debug":
			Writeln('too many patterns: ',all_patterns.n)
		return CHyphenator.NULL
	state_map=new int[int[]]
	ops_map=new int[u16[]]
	state_addrs=[0]
	Q=[new int[]]
	dfa=new u16[n_char_types]
	dfa_ops=new u16[]
	for(i=0L;i<Q.n;i++)
		cur_states=Q[i]
		my_addr=i*n_char_types
		tran=new int[][n_char_types]
		for j=0:tran.n-1
			tran[j]=new(fc_lists[j])
		//fc_lists
		foreach stpacked in cur_states
			pid=(stpacked&0xffff)
			pos=(stpacked>>16)
			s_pid=all_patterns[pid]
			ch_utf8=Utf8CodeAt(s_pid,pos)
			ch_std=chappeared[ch_utf8]
			pos+=Utf8Length(ch_utf8)
			if !s_pid[pos]:
				//add action
				tran[ch_std].push(~pid)
			else
				tran[ch_std].push(pid+(pos<<16))
		//Write(cur_states,' ')
		for j=0:tran.n-1
			new_states=tran[j]
			new_states.Sort()
			new_states.Unique()
			actions=u16[].NULL
			if new_states.n&&new_states[0]<0:
				//actions
				actions=new u16[]
				p_states=new_states.n
				for k=0:new_states.n-1
					if new_states[k]>=0:
						p_states=k
						break
					else
						pid=~new_states[k]
						s_pid=all_patterns[pid]
						pzero=s_pid.IndexOf(char(0))
						for paction=pzero+1:2:s_pid.n-2
							action_pos=pzero-int(u8(s_pid[paction]))
							action_value=int(u8(s_pid[paction+1]))
							actions.push(u16(action_value*256+action_pos+1))
				actions.Sort()
				actions.Unique()
				new_states=new_states[p_states:]
			new_stid=state_map[new_states]
			if !new_stid:
				if new_states.n:
					new_stid=int(Q.n)
					Q.push(new_states)
					dfa.resize(dfa.n+n_char_types)
					assert(dfa.n==n_char_types*Q.n)
					state_map[new_states]=new_stid
			if actions:
				//fill dfa
				actions.push(u16(32768+new_stid))
				opid=ops_map[actions]
				if !opid:
					opid=32768+int(dfa_ops.n)
					dfa_ops.push(actions)
					ops_map[actions]=opid
				addr_j=opid
			else
				addr_j=new_stid
			dfa[my_addr+j]=u16(addr_j)
			//Write(' ',new_stid)
		//Writeln()
	ret.dfa=dfa
	if Q.n>=32768:
		if Platform.BUILD=="debug":
			Writeln('dfa too complicated: ',Q.n)
		return CHyphenator.NULL
	if dfa_ops.n>=32767:
		if Platform.BUILD=="debug":
			Writeln('ops too complicated: ',dfa_ops.n)
		return CHyphenator.NULL
	//Writeln('patterns = ',all_patterns.n)
	//Writeln('dfa size = ',dfa.n)
	//Writeln('ops size = ',dfa_ops.n)
	//Writeln('states = ',Q.n)
	//Writeln(dfa)
	//Writeln(dfa_ops)
	ret.ops=dfa_ops
	return ret

FLAG_IS_SPACE=0x80000000
FLAG_HYPHENATE_AFTER=0x40000000//can also appear in the intermediate "words"
FLAG_BAD_BOL=0x20000000
FLAG_BAD_EOL=0x02000000
FLAG_CAN_PAD_AFTER=0x10000000
FLAG_CAN_PAD_AFTER_WEAK=0x08000000
FLAG_RUBBER=0x04000000
ATOM_FLAG_LINE_BREAK=(1<<21)
ATOM_FLAG_NEWLINE=(1<<20)
ATOM_FLAG_HYPHEN=(1<<19)
ATOM_MASK_CCNT=((1<<19)-1)
MAX_HYPHENATABLE_WORD=256
struct TLayoutAtom
	int flags
	int style_id
	int pword0,pword1
	/////////////
	i64 w,h
	i64 tail_kerning
	i64 y_baseline
g_char_to_flags=(function(){
	ret=new int[int]
	//opening parenthesis / quotation
	foreach ch in [40,91,123,171,3898,3900,5787,8216,8218,8219,8220,8222,8223,8249,8261,8317,8333,8968,8970,9001,10088,10090,10092,10094,10096,10098,10100,10181,10214,10216,10218,10220,10222,10627,10629,10631,10633,10635,10637,10639,10641,10643,10645,10647,10712,10714,10748,11778,11780,11785,11788,11804,11808,11810,11812,11814,11816,11842,12296,12298,12300,12302,12304,12308,12310,12312,12314,12317,64831,65047,65077,65079,65081,65083,65085,65087,65089,65091,65095,65113,65115,65117,65288,65339,65371,65375,65378]
		ret[ch]=FLAG_BAD_EOL
	//closing parenthesis / quotation
	foreach ch in [41,93,125,187,3899,3901,5788,8217,8221,8250,8262,8318,8334,8969,8971,9002,10089,10091,10093,10095,10097,10099,10101,10182,10215,10217,10219,10221,10223,10628,10630,10632,10634,10636,10638,10640,10642,10644,10646,10648,10713,10715,10749,11779,11781,11786,11789,11805,11809,11811,11813,11815,11817,12297,12299,12301,12303,12305,12309,12311,12313,12315,12318,12319,64830,65048,65078,65080,65082,65084,65086,65088,65090,65092,65096,65114,65116,65118,65289,65341,65373,65376,65379]
		ret[ch]=FLAG_BAD_BOL
	//non-breaking stuff and non-paired quotation masks
	foreach ch in [34,39,160,3852,8199,8209,8239]
		//just bad as both BOL and EOL
		ret[ch]=(FLAG_BAD_BOL|FLAG_BAD_EOL)
	//spaces
	foreach ch in [9,10,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288]
		ret[ch]=FLAG_IS_SPACE|FLAG_CAN_PAD_AFTER
	return ret
})()
g_utf8_ligatures=[
	"IJ","Ĳ", "ij","ĳ", "եւ","և", "ff","ﬀ", "fi","ﬁ", "fl","ﬂ", "ffi","ﬃ", "ffl","ﬄ", "ſt","ﬅ", "st","ﬆ", "մն","ﬓ", "մե","ﬔ", "մի","ﬕ", "վն","ﬖ", "մխ","ﬗ", "אל","ﭏ",
	//"``","“", "''","”"
	]
g_arabic_table=[1536,1536,1536,1536,1537,1537,1537,1537,1538,1538,1538,1538,1539,1539,1539,1539,1540,1540,1540,1540,1541,1541,1541,1541,1542,1542,1542,1542,1543,1543,1543,1543,1544,1544,1544,1544,1545,1545,1545,1545,1546,1546,1546,1546,1547,1547,1547,1547,1548,1548,1548,1548,1549,1549,1549,1549,1550,1550,1550,1550,1551,1551,1551,1551,1552,1552,1552,1552,1553,1553,1553,1553,1554,1554,1554,1554,1555,1555,1555,1555,1556,1556,1556,1556,1557,1557,1557,1557,1558,1558,1558,1558,1559,1559,1559,1559,1560,1560,1560,1560,1561,1561,1561,1561,1562,1562,1562,1562,1563,1563,1563,1563,1564,1564,1564,1564,1565,1565,1565,1565,1566,1566,1566,1566,1567,1567,1567,1567,1568,1568,1568,1568,65152,1569,1569,1569,65153,1570,65154,1570,65155,1571,65156,1571,65157,1572,65158,1572,65159,1573,65160,1573,65161,65163,65162,65164,65165,1575,65166,1575,65167,65169,65168,65170,65171,1577,65172,1577,65173,65175,65174,65176,65177,65179,65178,65180,65181,65183,65182,65184,65185,65187,65186,65188,65189,65191,65190,65192,65193,1583,65194,1583,65195,1584,65196,1584,65197,1585,65198,1585,65199,1586,65200,1586,65201,65203,65202,65204,65205,65207,65206,65208,65209,65211,65210,65212,65213,65215,65214,65216,65217,65219,65218,65220,65221,65223,65222,65224,65225,65227,65226,65228,65229,65231,65230,65232,1595,1595,1595,1595,1596,1596,1596,1596,1597,1597,1597,1597,1598,1598,1598,1598,1599,1599,1599,1599,1600,1600,1600,1600,65233,65235,65234,65236,65237,65239,65238,65240,65241,65243,65242,65244,65245,65247,65246,65248,65249,65251,65250,65252,65253,65255,65254,65256,65257,65259,65258,65260,65261,1608,65262,1608,65263,64488,65264,64489,65265,65267,65266,65268,1611,1611,1611,1611,1612,1612,1612,1612,1613,1613,1613,1613,1614,1614,1614,1614,1615,1615,1615,1615,1616,1616,1616,1616,1617,1617,1617,1617,1618,1618,1618,1618,1619,1619,1619,1619,1620,1620,1620,1620,1621,1621,1621,1621,1622,1622,1622,1622,1623,1623,1623,1623,1624,1624,1624,1624,1625,1625,1625,1625,1626,1626,1626,1626,1627,1627,1627,1627,1628,1628,1628,1628,1629,1629,1629,1629,1630,1630,1630,1630,1631,1631,1631,1631,1632,1632,1632,1632,1633,1633,1633,1633,1634,1634,1634,1634,1635,1635,1635,1635,1636,1636,1636,1636,1637,1637,1637,1637,1638,1638,1638,1638,1639,1639,1639,1639,1640,1640,1640,1640,1641,1641,1641,1641,1642,1642,1642,1642,1643,1643,1643,1643,1644,1644,1644,1644,1645,1645,1645,1645,1646,1646,1646,1646,1647,1647,1647,1647,1648,1648,1648,1648,64336,1649,64337,1649,1650,1650,1650,1650,1651,1651,1651,1651,1652,1652,1652,1652,1653,1653,1653,1653,1654,1654,1654,1654,64477,1655,1655,1655,1656,1656,1656,1656,64358,64360,64359,64361,64350,64352,64351,64353,64338,64340,64339,64341,1660,1660,1660,1660,1661,1661,1661,1661,64342,64344,64343,64345,64354,64356,64355,64357,64346,64348,64347,64349,1665,1665,1665,1665,1666,1666,1666,1666,64374,64376,64375,64377,64370,64372,64371,64373,1669,1669,1669,1669,64378,64380,64379,64381,64382,64384,64383,64385,64392,1672,64393,1672,1673,1673,1673,1673,1674,1674,1674,1674,1675,1675,1675,1675,64388,1676,64389,1676,64386,1677,64387,1677,64390,1678,64391,1678,1679,1679,1679,1679,1680,1680,1680,1680,64396,1681,64397,1681,1682,1682,1682,1682,1683,1683,1683,1683,1684,1684,1684,1684,1685,1685,1685,1685,1686,1686,1686,1686,1687,1687,1687,1687,64394,1688,64395,1688,1689,1689,1689,1689,1690,1690,1690,1690,1691,1691,1691,1691,1692,1692,1692,1692,1693,1693,1693,1693,1694,1694,1694,1694,1695,1695,1695,1695,1696,1696,1696,1696,1697,1697,1697,1697,1698,1698,1698,1698,1699,1699,1699,1699,64362,64364,64363,64365,1701,1701,1701,1701,64366,64368,64367,64369,1703,1703,1703,1703,1704,1704,1704,1704,64398,64400,64399,64401,1706,1706,1706,1706,1707,1707,1707,1707,1708,1708,1708,1708,64467,64469,64468,64470,1710,1710,1710,1710,64402,64404,64403,64405,1712,1712,1712,1712,64410,64412,64411,64413,1714,1714,1714,1714,64406,64408,64407,64409,1716,1716,1716,1716,1717,1717,1717,1717,1718,1718,1718,1718,1719,1719,1719,1719,1720,1720,1720,1720,1721,1721,1721,1721,64414,1722,64415,1722,64416,64418,64417,64419,1724,1724,1724,1724,1725,1725,1725,1725,64426,64428,64427,64429,1727,1727,1727,1727,64420,1728,64421,1728,64422,64424,64423,64425,1730,1730,1730,1730,1731,1731,1731,1731,1732,1732,1732,1732,64480,1733,64481,1733,64473,1734,64474,1734,64471,1735,64472,1735,64475,1736,64476,1736,64482,1737,64483,1737,1738,1738,1738,1738,64478,1739,64479,1739,64508,64510,64509,64511,1741,1741,1741,1741,1742,1742,1742,1742,1743,1743,1743,1743,64484,64486,64485,64487,1745,1745,1745,1745,64430,1746,64431,1746,64432,1747,64433,1747,1748,1748,1748,1748,1749,1749,1749,1749,1750,1750,1750,1750,1751,1751,1751,1751,1752,1752,1752,1752,1753,1753,1753,1753,1754,1754,1754,1754,1755,1755,1755,1755,1756,1756,1756,1756,1757,1757,1757,1757,1758,1758,1758,1758,1759,1759,1759,1759,1760,1760,1760,1760,1761,1761,1761,1761,1762,1762,1762,1762,1763,1763,1763,1763,1764,1764,1764,1764,1765,1765,1765,1765,1766,1766,1766,1766,1767,1767,1767,1767,1768,1768,1768,1768,1769,1769,1769,1769,1770,1770,1770,1770,1771,1771,1771,1771,1772,1772,1772,1772,1773,1773,1773,1773,1774,1774,1774,1774,1775,1775,1775,1775,1776,1776,1776,1776,1777,1777,1777,1777,1778,1778,1778,1778,1779,1779,1779,1779,1780,1780,1780,1780,1781,1781,1781,1781,1782,1782,1782,1782,1783,1783,1783,1783,1784,1784,1784,1784,1785,1785,1785,1785,1786,1786,1786,1786,1787,1787,1787,1787,1788,1788,1788,1788,1789,1789,1789,1789,1790,1790,1790,1790,1791,1791,1791,1791]
inline isArabic(ch){return u32(ch-0x600)<0x100u}
//they're relative to font height
SUPERSCRIPT_BASELINE=-32//.0/64.0
SUBSCRIPT_BASELINE=12//.0/64.0
class CStyle
	UNDERLINED=1
	STRIKED_OUT=2
	SUPERSCRIPT=4
	SUBSCRIPT=8
	///////
	TFont font
	int color
	int flags
	//////////////
	//these could be negative
	int line_space
	int paragraph_space
	///////
	string[] ligatures
	auto FindLigatures()
		pfnt=font.pfnt
		while pfnt.fallbacks:
			pfnt=pfnt.fallbacks[0]
		ligatures=new string[]
		for i=0:2:g_utf8_ligatures.n-2
			chlig=Utf8CodeAt(g_utf8_ligatures[i+1],0)
			(pfnt_glyph,gid)=g_renderer.SearchGlyph(pfnt,chlig)
			if pfnt_glyph:
				ligatures.push(g_utf8_ligatures[i])
				ligatures.push(g_utf8_ligatures[i+1])
class CEmbededObject
	JSObject obj
	i64 w,h,y_baseline
	///////////
	JS_get_w=function(JSContext JS){return JS.Return(fixed2double(w))}
	JS_get_h=function(JSContext JS){return JS.Return(fixed2double(h))}
	JS_get_y_baseline=function(JSContext JS){return JS.Return(fixed2double(y_baseline))}
	JS_set_w=function(JSContext JS){w=double2fixed(JS.Param(0).as(double));return 0}
	JS_set_h=function(JSContext JS){h=double2fixed(JS.Param(0).as(double));return 0}
	JS_set_y_baseline=function(JSContext JS){y_baseline=double2fixed(JS.Param(0).as(double));return 0}
	__JS_prototype=function(JSObject proto){
		proto.ExportProperty(this,"obj")
		proto.ExportGetterSetter(this,"w",JS_get_w,JS_set_w)
		proto.ExportGetterSetter(this,"h",JS_get_h,JS_set_h)
		proto.ExportGetterSetter(this,"y_baseline",JS_get_y_baseline,JS_set_y_baseline)
	}
///////////////////////////////
//separate document and stylesheet?
class CLayouter_fancy
	MODE_BB=0
	MODE_SEEK=1
	MODE_RENDER=2
	/////////
	m_wrap_width_in_fp=800LL*64LL
	//m_h_blank_line_in_fp=0LL
	m_bgcolor=0xffffffff
	m_bgcolor_selection=0xff800000
	m_styles=new CStyle[]
	m_objects=new CEmbededObject[]
	CHyphenator m_hyphenator
	/////////////////
	name=function(){return "renderer"}
	stateSize=function(){return 3}
	isLineOnly=function(){return 1}
	/////////////////
	auto PremakeRenderingText(int style_id,string s)
		auto su32=Utf8ToUnicode32(s)
		for J=0:su32.n-1
			if isArabic(su32[J]):
				prev_arabic=(J>0&&isArabic(su32[J-1]))
				next_arabic=(J<su32.n-1&&isArabic(su32[J+1]))
				su32[J]=g_arabic_table[(su32[J]-0x600)*4+next_arabic*2+prev_arabic]
		return Unicode32ToUtf8(su32).Replace(m_styles[style_id].ligatures)
	auto PreprocessParagraph(i64[] result,int offset_base,string s,int has_tail_newline)
		//create the "words"
		style_id=0
		p_last_word=0L
		words=new int3[]
		hyp=m_hyphenator
		no_hyp_points=new int[]
		foreach ch,I,I_next in Utf8Chars(s)
			//use single char commands
			if !isWordChar(ch)||isCJK(ch):
				if p_last_word<I:
					if I-p_last_word<MAX_HYPHENATABLE_WORD:
						hyp_points=hyp.HyphenateWord(s[p_last_word:I-1])
					else
						hyp_points=no_hyp_points
					p_last_hyphen=0
					foreach p in hyp_points
						if p_last_hyphen<p:
							words.push(int3(FLAG_HYPHENATE_AFTER|style_id,int(p_last_word+p_last_hyphen),int(p_last_word+p)))
						p_last_hyphen=p
					if p_last_hyphen<I-p_last_word:
						words.push(int3(style_id,int(p_last_word+p_last_hyphen),int(I)))
				if ch>=COMMAND_INSERT_OBJECT&&ch<COMMAND_END:
					if ch==COMMAND_RUBBER_SPACE:
						words.push(int3(-2,0,I))
					else if ch<COMMAND_SET_STYLE:
						obj_id=ch-COMMAND_INSERT_OBJECT
						if u32(obj_id)<u32(m_objects.n):
							words.push(int3(-1,obj_id,I))
					else
						style_id_new=ch-COMMAND_SET_STYLE
						if u32(style_id_new)<u32(m_styles.n):
							style_id=style_id_new
				else
					words.push(int3(style_id,int(I),int(I_next)))
				p_last_word=I_next
		if p_last_word<s.n:
			words.push(int3(style_id,int(p_last_word),int(s.n)))
		tail_style_id=style_id
		////////////
		//hyphenate the words
		atoms=new TLayoutAtom[]
		foreach word_i in words
			if word_i.x==-1:
				//object
				obj_id=word_i.y
				pobj=m_objects[obj_id]
				atoms.push(TLayoutAtom(){flags:FLAG_CAN_PAD_AFTER_WEAK, style_id:word_i.x, w:pobj.w,h:pobj.h, y_baseline:pobj.y_baseline, pword0:obj_id, pword1:word_i.z})
				continue
			if word_i.x==-2:
				//rubber space
				atoms.push(TLayoutAtom(){flags:FLAG_RUBBER, style_id:word_i.x, pword1:word_i.z})
				continue
			ch_first=0
			foreach ch in Utf8Chars(s[word_i.y:word_i.z-1])
				ch_first=ch
				break
			flags=g_char_to_flags[ch_first]
			if !flags:
				//default handling
				if isCJK(ch_first):
					//pad after CJK chars as a last resort
					flags|=FLAG_CAN_PAD_AFTER_WEAK
				else if !isWordChar(ch_first):
					//non-words are bad BOL unless stated otherwise
					flags|=FLAG_BAD_BOL
			//////////
			flags|=(word_i.x&FLAG_HYPHENATE_AFTER)
			style_id=(word_i.x&~FLAG_HYPHENATE_AFTER)
			//pre-apply ligatures and pre-hack arabics, but do the real deed during rendering
			s_render=PremakeRenderingText(style_id,s[word_i.y:word_i.z-1])
			w_word=0LL
			current_style=m_styles[style_id]
			ch_prev=-1
			foreach ch in Utf8Chars(s_render)
				if ch_prev>=0:
					w_word+=float2fixed(g_renderer.GetKerning(current_style.font,ch_prev,ch))
				ch_prev=ch
				w_word+=charWidth(current_style,ch)
			hc=charHeight(current_style)
			y_baseline=float2fixed(g_renderer.GetFontBaseline(current_style.font))
			if word_i.z<s.n:
				ch_next=0
				foreach ch in Utf8Chars(s[word_i.z:])
					ch_next=ch
					break
				tail_kerning=float2fixed(g_renderer.GetKerning(current_style.font,ch_prev,ch_next))
			else
				tail_kerning=0LL
			atoms.push(TLayoutAtom(){flags:flags, style_id:style_id, w:w_word,h:hc, y_baseline:y_baseline, tail_kerning:tail_kerning, pword0:word_i.y,pword1:word_i.z})
		//////////////////////////////
		//the real DP
		//start from max-greedy, stop when the current line clearly makes it suboptimal
		w_line=m_wrap_width_in_fp
		inline spaceBadness(w){return ((w*w)>>12)*w}
		LEADING_SPACE_BADNESS=1LL<<60
		inline HYPHEN_BADNESS(style_id){return spaceBadness(charWidth(m_styles[style_id],'-')>>1)}
		inline BAD_BOLEOL_BADNESS(style_id){return spaceBadness(charWidth(m_styles[style_id],' ')*20)}
		////
		n=int(atoms.n)
		best=new i64[n+1]
		blast=new int[n+1]
		j_min_last=0
		wsum_last=0LL
		//need O(n) j_min
		for i=1:n
			w0=0LL
			base_badness=0LL
			if i<n:
				if atoms[i].flags&FLAG_BAD_BOL:
					base_badness=BAD_BOLEOL_BADNESS(atoms[i].style_id)
				if atoms[i].flags&FLAG_IS_SPACE:
					base_badness+=LEADING_SPACE_BADNESS
			if atoms[i-1].flags&FLAG_HYPHENATE_AFTER:
				w0=charWidth(m_styles[atoms[i-1].style_id],'-')
				base_badness+=HYPHEN_BADNESS(atoms[i-1].style_id)
			if atoms[i-1].flags&FLAG_BAD_EOL:
				base_badness+=BAD_BOLEOL_BADNESS(atoms[i-1].style_id)
			//greedy first, extend to i and advance j_min_last
			if atoms[i-1].flags&FLAG_IS_SPACE:
				//it's a trailing space, advance *after* taking the current values
				j_min=j_min_last
				w=wsum_last+w0
				/////////
				if i>=2:
					wsum_last+=atoms[i-2].tail_kerning
				wsum_last+=atoms[i-1].w
			else
				if i>=2:
					wsum_last+=atoms[i-2].tail_kerning
				wsum_last+=atoms[i-1].w
				while wsum_last>w_line:
					wsum_last-=atoms[j_min_last].w+atoms[j_min_last].tail_kerning
					j_min_last++
				/////////
				j_min=j_min_last
				w=wsum_last+w0
			w_tail=w_line-w
			best_i=1LL<<62
			blast_i=j_min
			for j=min(j_min,i-1):i-1
				if j==i-1&&(atoms[i-1].flags&FLAG_IS_SPACE):
					break
				if w_tail>=0LL:
					cost=best[j]
					if i!=n:
						cost_j=spaceBadness(w_tail)
						if cost_j>=best_i:
							break
						cost+=cost_j
					if best_i>cost:
						best_i=cost
						blast_i=j
				w_tail+=atoms[j].w+atoms[j].tail_kerning
			best[i]=best_i+base_badness
			blast[i]=blast_i
		lbreaks_backward=new int[]
		p=n
		for(;;)
			lbreaks_backward.push(p)
			if !p:break
			p=blast[p]
		if !lbreaks_backward.n:lbreaks_backward.push(0)
		/////
		line_breaks=new int[lbreaks_backward.n]
		for i=0:lbreaks_backward.n-1
			line_breaks[lbreaks_backward.n-1-i]=i64(lbreaks_backward[i])
		///////////////////////////////////
		//per-line merging and padding - and cache the result
		//each component is a styled text range / object / space, the rendering of which should be self-evident
		SkipInvisiblesLeft=function(iptr p0){
			auto ret=p0
			foreach ch32,I in CharToUtf8Backward(s[:p0-1].ReverseOrder(),iptr)
				if !IsCharInvisible(ch32):
					return ret
				ret=I
			return ret
		}
		for li=0:line_breaks.n-2
			//rubber, normal, weak
			w=0LL
			n_paddables=int3(0,0,0)
			n_trailing_paddables=int3(0,0,0)
			p_last=line_breaks[li+1]-1
			h_up=0LL
			h_down=0LL
			h_lspace=0LL
			//h_pspace=0LL
			w_trailing=0LL
			for i=line_breaks[li]:p_last
				w+=atoms[i].w
				if i<p_last:
					w+=atoms[i].tail_kerning
				flags=atoms[i].flags
				if flags&FLAG_RUBBER:
					//rubbers are padded even when they're trailing
					n_paddables.x++
					w_trailing=0LL
				else if flags&FLAG_CAN_PAD_AFTER:
					n_paddables.y++
					n_trailing_paddables.y++
					w_trailing+=atoms[i].w
				else 
					if flags&FLAG_CAN_PAD_AFTER_WEAK:
						n_paddables.z++
						//n_trailing_paddables.z++
					//weaks are not spaces, so the strongs are no longer trailing
					n_trailing_paddables.x=0
					n_trailing_paddables.y=0
					w_trailing=0LL
				h_up=max(h_up,atoms[i].y_baseline)
				h_down=max(h_down,atoms[i].h-atoms[i].y_baseline)
				if atoms[i].style_id>=0:
					pstyle=m_styles[atoms[i].style_id]
					h_lspace=max(h_lspace,pstyle.line_space)
					//h_pspace=max(h_pspace,pstyle.paragraph_space)
			w-=w_trailing
			if atoms[p_last].flags&FLAG_HYPHENATE_AFTER:
				w+=charWidth(m_styles[atoms[p_last].style_id],'-')
			n_paddables-=n_trailing_paddables
			w_tail=max(w_line-w,0LL)
			if li==line_breaks.n-2&&n_paddables.x==0:w_tail=0LL
			w_pad=0LL
			w_rem=0
			n_spaces=0
			padding_mode=-1
			if w_tail>0LL:
				//pad spaces
				if n_paddables.x>0:
					//rubber
					n_spaces=n_paddables.x
					padding_mode=0
				else
					if n_paddables.y>0:
						n_spaces=n_paddables.y
						padding_mode=1
					else if n_paddables.z>0:
						n_spaces=n_paddables.z
						padding_mode=2
			if n_spaces>0:
				w_pad=w_tail/i64(n_spaces)
				w_rem=int(w_tail-w_pad*i64(n_spaces))
			cur_word0=-1
			cur_word1=-1
			cur_style=-1
			inline FlushWord()
				if cur_style>=0:
					result.push((i64(cur_style)<<42)|(i64(offset_base+cur_word1)<<21)|i64(offset_base+cur_word0))
					assert((result.back()>>42)!=-1LL)
				cur_word0=-1
				cur_word1=-1
				cur_style=-1
			inline addSpace(i64 dw,int ccnt)
				FlushWord()
				assert(ccnt>=0)
				if dw:
					assert(i64(int(dw))==dw&&dw>0L)
					result.push(i64(dw)|(i64(offset_base+ccnt)<<21)|(-2LL<<42))
					assert((result.back()>>42)!=-1LL)
			//newline
			h_line=h_up+h_down+h_lspace
			if li==line_breaks.n-2&&line_breaks.n==2&&!p_last:
				//empty line - switch to paragraph space
				h_line=m_styles[tail_style_id].paragraph_space
			assert(i64(int(h_up))==h_up&&h_up>=0LL)
			assert(i64(int(h_line))==h_line&&h_line>=0LL)
			//////////////////
			aflag=ATOM_FLAG_LINE_BREAK
			if has_tail_newline||(li<line_breaks.n-2):
				aflag|=ATOM_FLAG_NEWLINE
			if atoms[p_last].flags&FLAG_HYPHENATE_AFTER:
				aflag|=ATOM_FLAG_HYPHEN
			aflag|=SkipInvisiblesLeft(atoms[line_breaks[li]].style_id<0?atoms[line_breaks[li]].pword1:atoms[line_breaks[li]].pword0)+offset_base
			result.push(h_line|(h_up<<21)|(i64(aflag)<<42))
			assert((result.back()>>42)!=-1LL)
			for i=line_breaks[li]:line_breaks[li+1]-1
				if atoms[i].style_id==-1:
					//object
					FlushWord()
					result.push(i64(atoms[i].pword0)|(i64(offset_base+atoms[i].pword1)<<21)|(-1LL<<42))
				else if atoms[i].style_id==-2:
					assert(padding_mode==0||padding_mode<0)
					if padding_mode==0:
						addSpace(w_pad+i64(w_rem>0),atoms[i].pword1)
						w_rem--
				else
					//word
					if cur_style!=atoms[i].style_id||cur_word1!=atoms[i].pword0:
						FlushWord()
						cur_word0=atoms[i].pword0
					//this is always needed
					cur_word1=atoms[i].pword1
					cur_style=atoms[i].style_id
					//padding mode 1 / 2
					if padding_mode==1||padding_mode==2:
						if atoms[i].flags&(padding_mode==1?FLAG_CAN_PAD_AFTER:FLAG_CAN_PAD_AFTER_WEAK):
							addSpace(w_pad+i64(w_rem>0),atoms[i].pword0)
							w_rem--
			FlushWord()
	/////////////////
	PreprocessBlock=function(CEditableText caller,i64[] a,string s){
		result=new i64[]
		foreach sline,I in s.TokenizeEx("\n",s.TOKENIZE_ALLOW_EMPTY|s.TOKENIZE_INCLUDE_SEPARATOR)
			n0=result.n
			//if m_h_blank_line_in_fp&&(sline=="\n"||sline=="\r\n"):
			//	result.push(m_h_blank_line_in_fp|(m_h_blank_line_in_fp<<21)|(i64(ATOM_FLAG_LINE_BREAK|ATOM_FLAG_NEWLINE|I)<<42))
			//	assert((result.back()>>42)!=-1LL)
			//	result.push(i64(I)|(i64(I+1)<<21)|(0LL<<42))
			//	assert((result.back()>>42)!=-1LL)
			//else
			PreprocessParagraph(result,I,sline,sline.EndsWith("\n"))
			if n0<result.n:
				//shove back real newlines to \n
				aflag=(result[n0]>>42)
				if aflag!=-1&&aflag!=-2&&(aflag&ATOM_FLAG_LINE_BREAK):
					ccnt=(aflag&ATOM_MASK_CCNT)
					if ccnt>0&&s[ccnt-1]=='\n':
						result[n0]-=1LL<<42
		return result
	}
	AddString=function(i64[] a,i64[] pp,string s_context,string s,iptr ofs){
		bb=_RenderText(MODE_BB,0LL,a,pp,s,ofs, 0LL,0LL,0.f,0.f,0.f)
		a[0]=bb.x
		a[1]=bb.y
		a[2]=bb.z
	}
	Add=function(i64[] a,i64[] b){
		bb=combineEditorOffset(long2(a[0],a[1]),long2(b[0],b[1]))
		a[0]=bb.x
		a[1]=bb.y
		a[2]=b[2]
	}
	/////////////////
	Compare=function(i64[] a,i64[] b){
		ret=__C_compare(a[1],b[1])
		if ret==0:ret=__C_compare(a[0],b[0])
		return ret
	}
	SeekInBlock=function(i64[] a,i64[] pp,string s,i64[] b){
		return iptr(_RenderText(MODE_SEEK,0LL,a,pp,s,s.n, b[0],b[1],0.f,0.f,0.f).w)
	}
	/////////////////
	m_caret_overlay=long3(-1LL,-1LL,-1LL)
	JSObject m_overlay_obj
	i64 m_caret_offset
	SetCaretOverlay=function(CEditableText caller,i64 x,i64 y,JSObject obj){
		if !obj:
			m_caret_overlay=long3(-1LL,-1LL,-1LL)
			m_caret_offset=0LL
			m_overlay_obj=obj
			return 0LL
		a=caller.GetStateAt(caller.m_handler_registration["renderer"].as(int),caller.m_caret_locator.ccnt)
		style_id=int(a[2])
		m_overlay_obj=obj
		w_overlayd=0.
		if obj:
			s=obj["text"].as(string)
			if s:
				w_overlayd=GetStringWidth(m_styles[style_id].font,s)
		w_overlay=double2fixed(w_overlayd)
		m_caret_overlay=long3(x,y,w_overlay)
		m_caret_offset=0LL
		return w_overlay
	}
	GetCaretOffset=function(){
		return m_caret_offset
	}
	IsAtLineWrap=function(i64[] a,i64[] pp,string s,iptr ofs){
		if pp.n>0:
			foreach atom_i,I in pp[1:]
				style_id=int(atom_i>>42)
				if style_id!=-1&&style_id!=-2&&(style_id&ATOM_FLAG_LINE_BREAK):
					ccnt=(style_id&ATOM_MASK_CCNT)
					if ccnt==ofs&&(ofs>=s.n||s[ofs]!='\n'):
						return 1
					if ccnt>ofs:break
		return 0
	}
	IsCharInvisible=function(int ch){
		return ch>=COMMAND_SET_STYLE&&ch<COMMAND_END
		//return ch>=COMMAND_RUBBER_SPACE&&ch<COMMAND_END
	}
	charWidth=inline(style,ch){
		return max(float2fixed(g_renderer.GetCharacterAdvance(style.font,int(ch))),1LL)
	}
	charHeight=inline(style){
		return float2fixed(g_renderer.GetCharacterHeight(style.font))
	}
	//////////////////////////////////////////////
	SetTextStyle=function(JSObject obj){
		m_bgcolor=int(obj["bgcolor"].or(u32(m_bgcolor)))
		m_bgcolor_selection=int(obj["bgcolor_selection"].or(u32(m_bgcolor_selection)))
		m_tab_width=obj["tab_width"].or(8)
		m_wrap_width_in_fp=float2fixed(obj["wrap_width"].or(800.f))
		//m_h_blank_line_in_fp=float2fixed(obj["h_blank_line"].or(0.f))
		m_hyphenator=obj["hyphenator"].or(g_null_hyphenator)
		/////////////////
		js_styles=obj["styles"].as(JSObject)
		assert(!!js_styles)
		assert(js_styles.length()>0)
		UpdateStyles(js_styles)
	}
	UpdateStyles=function(JSObject js_styles){
		m_styles=new CStyle[]
		for i=0:js_styles.length()-1
			style_i=js_styles[i].as(JSObject)
			assert(!!style_i)
			font=style_i["font"].as(TFont)
			color=style_i["color"].or(0xff000000)
			flags=style_i["flags"].or(0)
			line_space=double2fixed(style_i["line_space"].or(0.0))
			paragraph_space=double2fixed(style_i["paragraph_space"].or(0.0))
			assert(!!font.pfnt)
			nstyle_i=new CStyle(){font:font,color:color,flags:flags,line_space:line_space,paragraph_space:paragraph_space}
			nstyle_i.FindLigatures()
			m_styles.push(nstyle_i)
	}
	//////////////////////
	JSObject[] g_rendered_objects
	BeginRender=function(){
		g_rendered_objects=new JSObject[]
	}
	_RenderText=function(int mode,i64 ccnt_base,i64[] a,i64[] pp,string s,iptr ofs, i64 scroll_x,i64 scroll_y,float screen_x,float screen_y,float scaling){
		inline projectX(i64 x)
			return fixed2float(x-scroll_x)*scaling+screen_x
		inline projectY(i64 y)
			return fixed2float(y-scroll_y)*scaling+screen_y
		//re-create the atoms, convert string, then render
		x=a[0]
		y=a[1]
		if y==m_caret_overlay.y&&x>m_caret_overlay.x:
			x+=m_caret_overlay.z
		newline_flags=0
		y_baseline=float2fixed(g_renderer.GetFontBaseline(m_styles[0].font))
		h_line=charHeight(m_styles[0])
		current_style_id=0
		fnt_scaled=TFont()
		dy_baseline=0LL
		ch32_prev=int('\n')
		if mode==MODE_RENDER:
			fnt_scaled=m_styles[current_style_id].font
			fnt_scaled.h*=scaling
			//smart emboldening for SRGB - it has to be done *after* the scaling
			color=m_styles[current_style_id].color
			if g_renderer.m_srgb_supported:
				fnt_scaled.embolden+=int((1.f-float(19589*(color&0xff)+38470*((color>>8)&0xff)+7477*((color>>16)&0xff))/float(0xff0000))*3000.f/fnt_scaled.h)
			dy_baseline=y_baseline-float2fixed(g_renderer.GetFontBaseline(m_styles[current_style_id].font))
		OfsCheck=__inline_loop_body(ccnt){
			if mode==MODE_BB&&h_line:
				//never return before the first newline
				if ccnt>=ofs:return long4(x,y,i64(current_style_id),h_line)
		}
		SeekCheck=__inline_loop_body(ccnt){
			if mode==MODE_SEEK:
				if y>scroll_y||scroll_y>=y&&scroll_y<y+h_line&&x>scroll_x:
					return long4(x,y,i64(current_style_id),i64(ccnt))
		}
		x0_underline=0LL;underline_style_id=-1
		x0_strikeout=0LL;strikeout_style_id=-1
		FlushUnderline=function(){
			if underline_style_id>=0:
				auto y_underline=y_baseline+(y_baseline>>5)
				g_renderer.DrawBitmap(0, 
					projectX(x0_underline),projectY(y+y_underline),
					projectX(x)-projectX(x0_underline),max(fixed2float(y_baseline>>4),1.f), m_styles[underline_style_id].color)
			x0_underline=0LL;underline_style_id=-1
		}
		FlushStrikeout=function(){
			if strikeout_style_id>=0:
				auto y_strikeout=(y_baseline>>1)-(y_baseline>>5)
				g_renderer.DrawBitmap(0, 
					projectX(x0_strikeout),projectY(y+y_strikeout),
					projectX(x)-projectX(x0_strikeout),max(fixed2float(y_baseline>>4),1.f), m_styles[strikeout_style_id].color)
			x0_strikeout=0LL;strikeout_style_id=-1
		}
		myDrawChar=function(int ch32){
			if x==m_caret_overlay.x&&y==m_caret_overlay.y:
				if m_overlay_obj&&m_overlay_obj["type"].as(string)=="IME":
					s_overlay=m_overlay_obj["text"].as(string)
					yf=projectY(y+dy_baseline)
					hc=charHeight(m_styles[current_style_id])
					if s_overlay:
						cmap=new iptr[]
						foreach chj,J in Utf8Chars(s_overlay)
							cmap.push(J)
						cmap.push(s_overlay.n)
						overlay_sel0=m_overlay_obj["start"].as(iptr)
						overlay_sel1=overlay_sel0+m_overlay_obj["length"].as(iptr)
						overlay_sel0=min(overlay_sel0,cmap.n-1)
						overlay_sel1=min(overlay_sel1,cmap.n-1)
						if uptr(overlay_sel0)<uptr(cmap.n)&&uptr(overlay_sel1)<uptr(cmap.n):
							x_sel0=GetStringWidth(m_styles[current_style_id].font,s_overlay[:cmap[overlay_sel0]-1])
							x_sel1=GetStringWidth(m_styles[current_style_id].font,s_overlay[:cmap[overlay_sel1]-1])
							m_caret_offset=double2fixed(x_sel1)
							if x_sel0>x_sel1:
								(x_sel0,x_sel1)=(x_sel1,x_sel0)
							//selection - pre-draw the highlight
							if x_sel0<x_sel1:
								g_renderer.DrawBitmap(0, float((fixed2float(x-scroll_x)+x_sel0)*scaling+screen_x),yf,float((x_sel1-x_sel0)*scaling),fixed2float(hc), m_bgcolor_selection)
						else
							assert(0)
						xo=x
						foreach chj,J in Utf8Chars(s_overlay)
							dx_j=charWidth(m_styles[current_style_id],chj)
							g_renderer.DrawChar(fnt_scaled, projectX(xo),yf,m_styles[current_style_id].color, chj)
							xo+=dx_j
					else
						assert(0)
					//draw the underline
					auto y_underline=yf+fnt_scaled.h*(fnt_scaled.pfnt.y_baseline_per_height*(1.f+1.f/32.f))
					g_renderer.DrawBitmap(0, projectX(x),y_underline,fixed2float(m_caret_overlay.z)*scaling,max(fnt_scaled.h*0.05f,1.f), m_styles[current_style_id].color)
				else
					//Writeln(x,' ',m_caret_overlay.x,' ',y,' ',m_caret_overlay.y)
					assert(0)
				x+=m_caret_overlay.z
			if ch32!=int(' '):
				dy_flags=0LL
				pstyle=m_styles[current_style_id]
				if pstyle.flags&pstyle.SUPERSCRIPT:
					hc=charHeight(pstyle)
					dy_flags=hc*i64(SUPERSCRIPT_BASELINE)>>6
				else if pstyle.flags&pstyle.SUBSCRIPT:
					hc=charHeight(pstyle)
					dy_flags=hc*i64(SUBSCRIPT_BASELINE)>>6
				g_renderer.DrawChar(fnt_scaled, projectX(x),projectY(y+dy_baseline+dy_flags),m_styles[current_style_id].color, ch32)
				if pstyle.flags&pstyle.STRIKED_OUT:
					if strikeout_style_id!=current_style_id:
						FlushStrikeout()
						x0_strikeout=x;strikeout_style_id=current_style_id
				else
					FlushStrikeout()
				if pstyle.flags&pstyle.UNDERLINED:
					if underline_style_id!=current_style_id:
						FlushUnderline()
						x0_underline=x;underline_style_id=current_style_id
				else
					FlushUnderline()
		}
		NewlineCheck=inline(){
			FlushUnderline()
			FlushStrikeout()
			if mode==MODE_RENDER:myDrawChar(int(' '))
			if newline_flags:
				if mode==MODE_RENDER&&(newline_flags&ATOM_FLAG_HYPHEN):
					myDrawChar(int('-'))
				x=0LL
				y+=h_line
		}
		foreach atom_i in pp
			style_id=int(atom_i>>42)
			value1=int((atom_i>>21)&((1<<21)-1))
			value0=int(atom_i&((1<<21)-1))
			if style_id==-2:
				//space
				OfsCheck(value1)
				x+=i64(value0)
				SeekCheck(value1)
				ch32_prev=int(' ')
			else if style_id==-1:
				//object
				obj_id=value0
				js_obj=m_objects[obj_id].obj
				if mode==MODE_RENDER:
					rendered_x=projectX(x)
					rendered_y=projectY(y+y_baseline-m_objects[obj_id].y_baseline)
					rendered_w=fixed2float(m_objects[obj_id].w)*scaling
					rendered_h=fixed2float(m_objects[obj_id].h)*scaling
					js_obj.CallMethod(JSObject,"RenderAsObject",rendered_x,rendered_y,rendered_w,rendered_h)
					auto JS=js_obj.m_jsctx
					obj_rendered_pos=JS.New()
					obj_rendered_pos["numerical_id"]=obj_id
					obj_rendered_pos["x"]=rendered_x
					obj_rendered_pos["y"]=rendered_y
					obj_rendered_pos["w"]=rendered_w
					obj_rendered_pos["h"]=rendered_h
					obj_rendered_pos["ccnt"]=ccnt_base+i64(value1)
					g_rendered_objects.push(obj_rendered_pos)
				OfsCheck(value1)
				x+=m_objects[obj_id].w
				SeekCheck(value1) 
				ch32_prev=int('\n')
			else if style_id&ATOM_FLAG_LINE_BREAK:
				//line start
				OfsCheck(style_id&ATOM_MASK_CCNT)
				SeekCheck(style_id&ATOM_MASK_CCNT)
				NewlineCheck()
				newline_flags=(style_id&(ATOM_FLAG_NEWLINE|ATOM_FLAG_HYPHEN))
				y_baseline=i64(value1)
				h_line=i64(value0)
				ch32_prev=int('\n')
				current_style_id=0
			else
				assert(style_id>=0)
				current_style_id=style_id
				//ignore RTL reversal here - conceptually it goes LTR, and we just flip it "visually"
				//and precompute the ranges
				//arabic transformations - in the recursion
				if mode==MODE_RENDER:
					fnt_scaled=m_styles[current_style_id].font
					fnt_scaled.h*=scaling
					//smart emboldening for SRGB - it has to be done *after* the scaling
					color=m_styles[current_style_id].color
					if g_renderer.m_srgb_supported:
						fnt_scaled.embolden+=int((1.f-float(19589*(color&0xff)+38470*((color>>8)&0xff)+7477*((color>>16)&0xff))/float(0xff0000))*3000.f/fnt_scaled.h)
					dy_baseline=y_baseline-float2fixed(g_renderer.GetFontBaseline(m_styles[current_style_id].font))
				__inline_loop_body TranslateArabic(iptr ccnt0,string s_part)
					auto su32=[int2(ch,int(ccnt0+I)) foreach ch,I in Utf8Chars(s_part)]
					for J=0:su32.n-1
						ch32=su32[J].x
						if isArabic(ch32):
							prev_arabic=(J>0&&isArabic(su32[J-1].x))
							next_arabic=(J<su32.n-1&&isArabic(su32[J+1].x))
							ch32=g_arabic_table[(ch32-0x600)*4+next_arabic*2+prev_arabic]
						//ch32
						x+=float2fixed(g_renderer.GetKerning(m_styles[current_style_id].font,ch32_prev,ch32))
						OfsCheck(su32[J].y)
						if mode==MODE_RENDER:
							if ch32!=' '&&ch32!='\t'&&ch32!='\r'&&ch32!='\n':
								myDrawChar(ch32)
						x+=charWidth(m_styles[current_style_id],ch32)
						ch32_prev=ch32
						SeekCheck(su32[J].y)
				__inline_loop_body AddLigature(iptr ccnt0,iptr nc,string s_ligature)
					ch32=0
					foreach ch in Utf8Chars(s_ligature)
						ch32=ch
						break
					x0=x
					x+=float2fixed(g_renderer.GetKerning(m_styles[current_style_id].font,ch32_prev,ch32))
					auto dx=charWidth(m_styles[current_style_id],ch32)
					if mode==MODE_RENDER:
						myDrawChar(ch32)
					else if mode==MODE_SEEK:
						for j=0:nc-1
							xj=x+dx*i64(j+1)/i64(nc)
							if y>scroll_y||scroll_y>=y&&scroll_y<y+h_line&&xj>=scroll_x:
								return long4(xj,y,i64(current_style_id),i64(ccnt0+j))
					else if mode==MODE_BB:
						for j=0:nc-1
							if ccnt0+j>=ofs:return long4(x+dx*i64(j)/i64(nc),y,i64(current_style_id),h_line)
					x+=dx
					ch32_prev=ch32
				spart=s[value0:value1-1]
				ligatures=m_styles[current_style_id].ligatures
				ligature_poses=spart.FindAll(ligatures)
				p_last=0L
				for i=0:2:ligature_poses.n-2
					p=ligature_poses[i]
					id=ligature_poses[i+1]
					if p_last<p:
						TranslateArabic(value0+p_last,spart[p_last:p-1])
					p_last=p+ligatures[id*2+0].n
					AddLigature(value0+p,p_last-p,ligatures[id*2+1])
				if p_last<spart.n:
					TranslateArabic(value0+p_last,spart[p_last:])
		NewlineCheck()
		if mode==MODE_SEEK:
			return long4(x,y,i64(current_style_id),i64(s.n))
		else
			return long4(x,y,i64(current_style_id),h_line)
	}
	RenderText=function(i64 ccnt_base,i64[] a,i64[] pp,string s, u8[] color_ids, i64 scroll_x,i64 scroll_y,float screen_x,float screen_y,float scaling){
		_RenderText(MODE_RENDER,ccnt_base,a,pp,s,s.n,scroll_x,scroll_y,screen_x,screen_y,scaling)
	}
	GetCharacterHeightAt=function(i64[] a,i64[] pp,string s,iptr ofs){
		bb=_RenderText(MODE_BB,0LL,a,pp,s,ofs, 0LL,0LL,0.f,0.f,0.f)
		//return charHeight(m_styles[bb.z])
		return bb.w
	}
	GetDefaultFont=function(){
		return m_styles[0].font
	}
	//////////////////////////////
	//todo: somehow load the objects
	JS_UpdateStyles=function(JSContext JS){
		js_styles=JS.Param(0).as(JSObject)
		if !js_styles||js_styles.length()<=0:return 0
		UpdateStyles(js_styles)
		return 0
	}
	JS_InsertObject=function(JSContext JS){
		obj=JS.Param(0).as(JSObject)
		if !obj:return 0
		w=double2fixed(JS.Param(1).as(double))
		h=double2fixed(JS.Param(2).as(double))
		y_baseline=double2fixed(JS.Param(3).as(double))
		n0=m_objects.n
		m_objects.push(CEmbededObject(){obj:obj,w:w,h:h,y_baseline:y_baseline})
		return JS.Return(n0)
	}
	JS_GetObjectCount=function(JSContext JS){
		return JS.Return(m_objects.n)
	}
	JS_GetObject=function(JSContext JS){
		id=JS.Param(0).or(-1)
		if u32(id)<u32(m_objects.n):
			return JS.Return(m_objects[id])
		else
			return 0
	}
	JS_ConvertTextToPersistentForm=function(JSContext JS){
		stext=JS.Param(0).as(string)
		if !stext:return 0
		style0=JS.Param(1).or(0)
		obj_reach=new int[m_objects.n]
		style_reach=new int[m_styles.n]
		if u32(style0)<u32(style_reach.n):
			style_reach[style0]=1
		stext32=new int[]
		if u32(style0)<u32(style_reach.n):
			stext32.push(COMMAND_SET_STYLE+style0)
		foreach ch in Utf8Chars(stext)
			if ch>=COMMAND_INSERT_OBJECT&&ch<COMMAND_INSERT_OBJECT+obj_reach.n:
				obj_reach[ch-COMMAND_INSERT_OBJECT]=1
			if ch>=COMMAND_SET_STYLE&&ch<COMMAND_SET_STYLE+style_reach.n:
				style_reach[ch-COMMAND_SET_STYLE]=1
			stext32.push(ch)
		obj_subset=new int[]
		style_subset=new int[]
		//Writeln(obj_reach,' ',style_reach)
		foreach d,I in obj_reach
			d0=d
			obj_reach[I]=obj_subset.n
			if d0:obj_subset.push(I)
		foreach d,I in style_reach
			d0=d
			style_reach[I]=style_subset.n
			if d0:style_subset.push(I)
		//Writeln(obj_reach,' ',style_reach,' ',obj_subset,' ',style_subset)
		foreach ch,I in stext32
			if ch>=COMMAND_INSERT_OBJECT&&ch<COMMAND_INSERT_OBJECT+obj_reach.n:
				stext32[I]=obj_reach[ch-COMMAND_INSERT_OBJECT]+COMMAND_INSERT_OBJECT
			if ch>=COMMAND_SET_STYLE&&ch<COMMAND_SET_STYLE+style_reach.n:
				stext32[I]=style_reach[ch-COMMAND_SET_STYLE]+COMMAND_SET_STYLE
		ret=JS.New()
		ret["text"]=Unicode32ToUtf8(stext32)
		ret["objects"]=obj_subset
		ret["styles"]=style_subset
		return JS.Return(ret)
	}
	JS_TranslateStylesAndObjects=function(JSContext JS){
		stext=JS.Param(0).as(string)
		js_obj_subset=JS.Param(1).as(JSObject)
		js_style_subset=JS.Param(2).as(JSObject)
		if !stext||!js_obj_subset||!js_style_subset:return 0
		obj_subset=new int[]
		style_subset=new int[]
		for i=0:js_obj_subset.length()-1
			obj_id=js_obj_subset[i].or(-1)
			if u32(obj_id)<u32(m_objects.n):
				obj_subset.push(obj_id)
		for i=0:js_style_subset.length()-1
			style_id=js_style_subset[i].or(-1)
			if u32(style_id)<u32(m_styles.n):
				style_subset.push(style_id)
		stext32=new int[]
		foreach ch in Utf8Chars(stext)
			if ch>=COMMAND_INSERT_OBJECT&&ch<COMMAND_RUBBER_SPACE:
				if ch<COMMAND_INSERT_OBJECT+obj_subset.n:
					stext32.push(obj_subset[ch-COMMAND_INSERT_OBJECT]+COMMAND_INSERT_OBJECT)
					continue
			if ch>=COMMAND_SET_STYLE&&ch<COMMAND_END:
				if ch<COMMAND_SET_STYLE+style_subset.n:
					stext32.push(style_subset[ch-COMMAND_SET_STYLE]+COMMAND_SET_STYLE)
					continue
			stext32.push(ch)
		return JS.Return(Unicode32ToUtf8(stext32))
	}
	__JS_prototype=function(JSObject proto){
		proto.ExportProperty(this,"g_rendered_objects")
		proto.ExportMethod(this,"UpdateStyles",JS_UpdateStyles)
		proto.ExportMethod(this,"InsertObject",JS_InsertObject)
		proto.ExportMethod(this,"GetObject",JS_GetObject)
		proto.ExportMethod(this,"GetObjectCount",JS_GetObjectCount)
		proto.ExportMethod(this,"Internal_ConvertTextToPersistentForm",JS_ConvertTextToPersistentForm)
		proto.ExportMethod(this,"Internal_TranslateStylesAndObjects",JS_TranslateStylesAndObjects)
	}

registerStateHandler("renderer_fancy",CLayouter_fancy)

registerUIExtension(function(JSObject JS_UI,CUISandbox sbox,int is_real){
	JS_UI["ParseHyphenator"]=function(JSContext JS){
		sdata=JS.Param(0).or("")
		if sdata.StartsWith("{"):
			ret=parseCachedHyphenator(JS,sdata)
		else
			ret=parseTexHyphenFile(JS,sdata)
		return JS.Return(ret)
	}
	JS_UI["RemoveStylingCharacters"]=function(JSContext JS){
		s=JS.Param(0).as(string)
		if !s:return 0
		return JS.Return(Unicode32ToUtf8([ch foreach ch in Utf8ToUnicode32(s) if !(ch>=COMMAND_SET_STYLE&&ch<COMMAND_END)]))
	}
})
