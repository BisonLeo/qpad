import "text-box.jc"
import "bin-editor.jc"
import "code-editor.jc"
import "code-parser.jc"
import "encoding.jc"
import "g-l.jc"
//import "txtx-editor.jc"
//import "zip-doc.jc"
//import "ooc-mipmap.jc"
//import "uisandbox.jc"
import Gui2D.*
import Javascript.*
import System.Console.*
import System.Algorithm.*
import GL.*
//import Uisandbox.*

__generate_json("js_units","gui2d/ui.js")
__generate_json("js_units","gui2d/gl.js")
__generate_json("js_units","gui2d/widgets.js")
__generate_json("js_units","gui2d/dockbar.js")
if Platform.ARCH=="ios"||Platform.ARCH=="web":
	__generate_json("extra_resource_dirs","cjk_fonts")
if Platform.ARCH=="ios":
	__generate_json("icon_file","icon_ios.png")
else if Platform.ARCH=="mac":
	__generate_json("icon_file","icon1k.png")
else
	__generate_json("icon_file","icon256.png")
__generate_json("icon_win","iconwin.ico")
//__generate_json("include_js","build/make_new_docs.js")
//__generate_json("linux_cc","clang")
__generate_json("linux_cc","gcc-5")
if Platform.IS_LINUX:
	__generate_json("ssh_remote_target","~/qpad")
	__generate_json("ssh_server","houqiming@192.168.85.106")
//if Platform.IS_UNIX&&Platform.BUILD!="debug":
//	__generate_json("ldflags","-s")
if Platform.IS_WINDOWS:
	__generate_json("lib_files","shell32.lib")
	__generate_json("lib_files","kernel32.lib")
	__generate_json("lib_files","user32.lib")
	__generate_json("lib_files","gdi32.lib")
	//like Nuke, we could use a console
	//if Platform.BUILD!="debug":
	//	__generate_json("subsystem","windows")
	//	__generate_json("c_files","jc_winmain.c")
	__generate_json("vc_versions","11")
//if Platform.ARCH=="win32":
//	//use VC2008 for XP support
//	__generate_json("vc_versions","9")
if Platform.ARCH=="android":
	__generate_json("android_activity_manifest","android:windowSoftInputMode=stateAlwaysHidden|adjustResize")
if Platform.ARCH=="web":
	__generate_json("cflags","-s TOTAL_MEMORY=268435456")
	__generate_json("ldflags","-s TOTAL_MEMORY=268435456")

c_system=__c_function(int,"system","stdlib.h")

auto genString(string s0)
	s=new string
	hex="0123456789ABCDEF"
	foreach ch0 in s0
		ch=int(u8(ch0))
		if ch>=0:
			if ch=='"':
				s.push('\\')
				s.push('"')
			else if ch>=32&&ch<127:
				s.push(char(ch))
			else
				s.push('\\')
				s.push('x')
				s.push(hex[(ch>>4)&15])
				s.push(hex[ch&15])
	return s

if Platform.IS_WINDOWS:
	ExitProcess=__c_function(int,"ExitProcess","windows.h")
	registerUIExtension(function(JSObject JS_UI,CUISandbox sbox,int is_real){
		JS_UI["SDL_GLInitErrorCallback"]=function(JSContext JS){
			MessageBoxA=__c_function(int,"MessageBoxA","windows.h")
			MessageBoxA(NULL,"Your machine doesn't support OpenGL 2.0.\n\nPlease download and extract the LLVMPipe package","Error",0x10)
			ExitProcess(1)
			return 0;
		}
		JS_UI["ShowCompletionNotification"]=function(JSContext JS){
			GetCurrentProcessId=__c_function(int,"GetCurrentProcessId","windows.h")
			pid=GetCurrentProcessId()
			SetForegroundProcess=__c_function(int,"SetForegroundProcess","windows.h")
			return JS.Return(SetForegroundProcess(pid))
		}
		JS_UI["SetTaskbarProgress"]=function(JSContext JS){
			hwnd_sdl=JS.Param(0).as(__pointer)
			progress=JS.Param(1).or(0.f)
			SetTaskbarProgress=__c_function(int,"SetTaskbarProgress","taskbar_win.h","c_files","taskbar_win.cpp")
			SDL_GetHWND=__c_function(__pointer,"SDL_GetHWND","sdl_hwnd.h","c_files","sdl_hwnd.c")
			return JS.Return(SetTaskbarProgress(SDL_GetHWND(hwnd_sdl),progress))
		}
	})
if Platform.BUILD=="debug":
	registerUIExtension(function(JSObject JS_UI,CUISandbox sbox,int is_real){
		JS_UI["dumpMemoryUsage"]=function(JSContext JS){
			state_new=LeakDetection.CreateMemorySnapshot()
			Writeln('=== internal memory usage: ',LeakDetection.GetMemoryUsage(),' bytes, ',state_new.n,' allocs')
			state_new.discard()
			return 0
		}
		JS_UI["detectLeaks"]=function(JSContext JS){
			LeakDetection.DetectLeaks()
			return 0
		}
		JS_UI["debugDumpFragmentation"]=function(JSContext JS){
			LeakDetection.AnalyzeFragmentation()
			return 0
		}
		JS_UI["debugDumpHeap"]=function(JSContext JS){
			JS.debugDumpHeap()
			return 0
		}
		JS_UI["debugWipeStash"]=function(JSContext JS){
			JS.debugWipeStash()
			return 0
		}
	})

g_js_std_header="function(input,output)";
MODE_INPUT=1
MODE_OUTPUT=2
inline StripLeadingSpaces(string s)
	p=0L
	while p<s.n&&(s[p]==' '||s[p]=='\t'):
		p++
	return s[p:]

auto ParsePortDescs(JSObject ret,string scode)
	//just ignore all errors
	obj_ports=ret["m_ports"].as(JSObject)
	p=obj_ports["length"].as(iptr)
	prev_port=JSObject.NULL
	for sline in scode.Tokenize("\r\n")
		isin=1
		pport=sline.IndexOf('@in=')
		if pport>=0:
			pport+=4
		else
			pport=sline.IndexOf('@out=')
			if pport>=0:
				pport+=5
				isin=0
			else
				psticker=sline.IndexOf('@sticker=')
				if psticker>=0:
					psticker+=9
					ssticker=sline[psticker:]
					pspace=ssticker.IndexOf(' ')
					if pspace>=0:
						astickers=prev_port["stickers"].as(JSObject)
						if !astickers:
							astickers=JS.NewArray()
							prev_port["stickers"]=astickers
						n0=astickers["length"].as(iptr)
						astickers[n0]=ssticker[:pspace-1]
						astickers[n0+1]=ssticker[pspace+1:]
				continue
		words=[StripLeadingSpaces(s) for s in sline[pport:].Tokenize(",")]
		sname=words[0]
		//if obj_id2port:
		//	obj_port=obj_id2port[sname].as(JSObject)
		//	if Platform.BUILD=="debug":
		//		if !obj_port:
		//			Writeln('port not found: ',sname)
		//else
		obj_port=JSObject.NULL
		if !obj_port:
			obj_port=JS.New()
			obj_ports[p]=obj_port; p++
			obj_port["id"]=sname
			obj_port["dir"]=(isin?"input":"output")
		for i=1:words.n-1
			s_word=words[i]
			pcolon=s_word.IndexOf('=')
			if pcolon<0:continue
			s_key=s_word[:pcolon-1]
			s_value=s_word[pcolon+1:]
			if s_value.n&&s_value[0]>='0'&&s_value[0]<='9':
				if s_value.StartsWith('0x'):
					obj_port[s_key]=s_value[2:].asHex(int)
				else
					obj_port[s_key]=s_value.as(double)
			else
				obj_port[s_key]=s_value
		prev_port=obj_port

EnumWords=inline(scode){
	return {forEach:inline(fbody){
		plast=0L
		foreach ch,I in scode
			isalnum=(ch>='a'&&ch<='z'||ch>='A'&&ch<='Z'||ch>='0'&&ch<='9'||ch=='_'||ch>=128)
			word0=plast
			word1=-1L
			ch_delimiter=ch
			if !isalnum:
				word1=I
			else if isalnum&&I==scode.n-1:
				word1=scode.n
				ch_delimiter=char(0)
			if word0<word1:
				s_word=scode[word0:word1-1]
				fbody(s_word,ch_delimiter,word0,word1)
			if !isalnum:
				plast=word1+1
	}}
}

auto ParseJSNode(string scode)
	//pnewline=scode0.IndexOf('\n')
	//scode=scode0[pnewline+1:]
	if !scode.StartsWith(g_js_std_header):
		return JS.ReturnError('JS nodes must begin with "@1"'.Replace(["@1",g_js_std_header]))
	obj_func=JS["eval"].Call(JSObject,"(function(){return "+scode+"})()")
	///////////////
	ports=[new string[] for i=0:1]
	//got=new int[string]
	//word_mode=0
	//for s_word,ch in EnumWords(scode)
	//	if word_mode>0:
	//		if !(got[s_word]&(1<<(word_mode-1))):
	//			ports[word_mode-1].push(s_word)
	//			got[s_word]|=(1<<(word_mode-1))
	//		word_mode=0
	//	else
	//		word_mode=0
	//		if ch=='.':
	//			if s_word=='input':
	//				word_mode=MODE_INPUT
	//			else if s_word=='output':
	//				word_mode=MODE_OUTPUT
	//we still need @type for type labels
	ret=JS.New()
	ret["m_script"]=obj_func
	obj_ports=JS.NewArray()
	ret["m_ports"]=obj_ports
	//obj_id2port=JS.New()
	//p=0L
	//for i=0:1
	//	for s in ports[i]
	//		obj=JS.New()
	//		obj_ports[p]=obj;p++
	//		obj["id"]=s
	//		obj["dir"]=(i==0?"input":"output")
	//		obj_id2port[s]=obj
	//ParsePortDescs(ret,obj_id2port,scode)
	ParsePortDescs(ret,scode)
	return JS.Return(ret)

JS=new JSContext
auto ParseTextNode(string scode)
	//make @out lines hard separators
	obj_code_blocks=JS.NewArray()
	p=0L
	s_port_name=string.NULL
	sblock=new string
	for sline,I in scode.TokenizeEx("\r\n",scode.TOKENIZE_ALLOW_EMPTY|scode.TOKENIZE_INCLUDE_SEPARATOR)
		pport=sline.IndexOf('@out=')
		if pport<0:
			if sline.IndexOf('@in=')<0&&sline.IndexOf('@sticker=')<0:
				sblock.push(sline)
			continue
		else
			//found a separator
			if s_port_name&&sblock.n:
				obj_code_blocks[p+0]=s_port_name
				obj_code_blocks[p+1]=sblock
				p+=2
			sblock=new string
			pport+=5
			s_port_name=StripLeadingSpaces(sline[pport:])
			pcomma=s_port_name.IndexOf(',')
			if pcomma>=0:
				s_port_name.n=pcomma
	if s_port_name&&sblock.n:
		obj_code_blocks[p+0]=s_port_name
		obj_code_blocks[p+1]=sblock
		p+=2
	ret=JS.New()
	ret["m_blocks"]=obj_code_blocks
	obj_ports=JS.NewArray()
	ret["m_ports"]=obj_ports
	ParsePortDescs(ret,scode)
	is_in_port=new int[string]
	n_ports=obj_ports["length"].as(iptr)
	for i=0:n_ports-1
		s_id=obj_ports[i]["id"].as(string)
		if obj_ports[i]["dir"].as(string)=="input":
			is_in_port[s_id]=1
	for i=1:2:p-1
		sblock=obj_code_blocks[i].as(string)
		p_splits=new iptr[]
		p_splits.push(0L)
		for s_word,ch,p0,p1 in EnumWords(sblock)
			if is_in_port[s_word]:
				p_splits.push(p0)
				p_splits.push(p1)
		p_splits.push(sblock.n)
		obj_block=JS.NewArray()
		for i=0:p_splits.n-2
			obj_block[i]=sblock[p_splits[i]:p_splits[i+1]-1]
		obj_code_blocks[i]=obj_block
	return JS.Return(ret)

auto CountLeadingSpaces(string s)
	for i=0:s.n-1
		if s[i]!=' '&&s[i]!='\t':return i
	return s.n

registerUIExtension(function(JSObject JS_UI,CUISandbox sbox,int is_real){
	JS_UI["ParseJSNode"]=function(JSContext JS)
		scode=JS.Param(0).as(string)
		return ParseJSNode(scode)
	JS_UI["ParseTextNode"]=function(JSContext JS)
		scode=JS.Param(0).as(string)
		return ParseTextNode(scode)
	JS_UI["m_node_dir"]=System.Env.GetExecutablePath()+"../../nodes"
	///////////////////////////
	g_edge_vbo=new float[]
	g_vbo_tech=GLTechnique.NULL
	JS_UI["RenderEdge"]=function(JSContext JS){
		auto x0=JS.Param(0).as(float)*Gui2D.detail.g_renderer.m_pixels_per_unit
		auto y0=JS.Param(1).as(float)*Gui2D.detail.g_renderer.m_pixels_per_unit
		auto x1=JS.Param(2).as(float)*Gui2D.detail.g_renderer.m_pixels_per_unit
		auto y1=JS.Param(3).as(float)*Gui2D.detail.g_renderer.m_pixels_per_unit
		auto C0=JS.Param(4).as(int)
		auto C1=JS.Param(5).as(int)
		auto line_width=JS.Param(6).as(float)*Gui2D.detail.g_renderer.m_pixels_per_unit
		Nx=y1-y0
		Ny=x0-x1
		ilg=Nx*Nx+Ny*Ny
		if ilg>0.f:
			ilg=1.f/System.Math.sqrt(ilg)
		else
			ilg=0.f
		ilg*=0.5f*line_width+1.f
		Nx*=ilg;Ny*=ilg;
		g_edge_vbo.push(x0+Nx);g_edge_vbo.push(y0+Ny); g_edge_vbo.push((0.5f*line_width+1.f)); g_edge_vbo.push(__int_as_float(C0))
		g_edge_vbo.push(x1+Nx);g_edge_vbo.push(y1+Ny); g_edge_vbo.push((0.5f*line_width+1.f)); g_edge_vbo.push(__int_as_float(C1))
		g_edge_vbo.push(x1-Nx);g_edge_vbo.push(y1-Ny); g_edge_vbo.push(-(0.5f*line_width+1.f)); g_edge_vbo.push(__int_as_float(C1))
		g_edge_vbo.push(x0+Nx);g_edge_vbo.push(y0+Ny); g_edge_vbo.push((0.5f*line_width+1.f)); g_edge_vbo.push(__int_as_float(C0))
		g_edge_vbo.push(x1-Nx);g_edge_vbo.push(y1-Ny); g_edge_vbo.push(-(0.5f*line_width+1.f)); g_edge_vbo.push(__int_as_float(C1))
		g_edge_vbo.push(x0-Nx);g_edge_vbo.push(y0-Ny); g_edge_vbo.push(-(0.5f*line_width+1.f)); g_edge_vbo.push(__int_as_float(C0))
		return 0
	}
	JS_UI["GetEdgeVBO"]=function(JSContext JS){
		auto ret=g_edge_vbo
		g_edge_vbo=new float[]
		return JS.Return(ret)
	}
	JS_UI["FlushEdges"]=function(JSContext JS){
		//auto C=JS.Param(0).as(int)
		auto line_width=JS.Param(0).as(float)*Gui2D.detail.g_renderer.m_pixels_per_unit
		auto g_edge_vbo=JS.Param(1).as(float[])
		if !g_edge_vbo||!g_edge_vbo.n:
			return 0
		if !g_vbo_tech:
			g_vbo_tech=new GLTechnique
			g_vbo_tech.SetVarying("float dist;vec4 C")
			g_vbo_tech.SetVertexShader("
				void main(){
					vec2 P_scr=P.xy*scale;
					gl_Position=vec4(P_scr.x-1.0,1.0-P_scr.y,1.0,1.0);
					dist=P.z;
					C=vec4(pow(C0.xyz,vec3(gamma)),C0.w);
				}")
			g_vbo_tech.SetFragmentShader("
				void main(){
					float coverage=min(max(dist+0.5,-half_line_width),half_line_width)-min(max(dist-0.5,-half_line_width),half_line_width);
					gl_FragColor=vec4(C.xyz,C.w*coverage);
				}")
		prev_viewport=new int[4]
		glGetIntegerv(GL_VIEWPORT,__pointer(prev_viewport.d));
		BATCH=65536-(65536%(sizeof(float)*4 *6))
		for i=0:BATCH:g_edge_vbo.n-1
			real_batch=min(g_edge_vbo.n-i,BATCH)
			ref=g_edge_vbo[i:i+real_batch-1].ConvertToAsBinary(i32)
			vbo=Gui2D.detail.g_renderer.UploadMiniVBO(ref)
			ref.discard()
			if !vbo:break
			g_vbo_tech.SetUniform("scale",float2(2.f/f32(prev_viewport[2]),2.f/f32(prev_viewport[3])))
			g_vbo_tech.SetUniform("gamma",Gui2D.detail.g_renderer.m_gamma)
			g_vbo_tech.SetUniform("half_line_width",0.5f*line_width);
			//g_vbo_tech.SetUniformColor("C",C)
			g_vbo_tech.SetVertexPointer("P", 3,GL_FLOAT,0, 4*sizeof(float),0L)
			g_vbo_tech.SetVertexPointer("C0", 4,GL_UNSIGNED_BYTE,1, 4*sizeof(float),12L)
			g_vbo_tech.Draw(vbo,GL_TRIANGLES,real_batch/4)
		return 0
	}
	auto RecursiveCopy(string dir_src,string dir_tar)
		System.IO.CreateDirectory(dir_tar)
		if !System.IO.DirExists(dir_tar):return 0
		for fn,fi in System.IO.EnumFiles(dir_src+'/*',System.IO.ENUM_FILE|System.IO.ENUM_DIR)
			pslash=fn.LastIndexOf('/')
			fn_tar=dir_tar+"/"+fn[pslash+1:]
			if fi.is_dir():
				if !RecursiveCopy(fn,fn_tar):return 0
			else
				if !System.IO.CopyFile(fn,fn_tar):return 0
		return 1
	JS_UI["RecursiveCopy"]=function(JSContext JS){
		dir_src=JS.Param(0).as(string)
		dir_tar=JS.Param(1).as(string)
		return JS.Return(RecursiveCopy(dir_src,dir_tar))
	}
	JS_UI["ParseSyncTags"]=function(JSContext JS){
		auto fn=JS.Param(0).as(string)
		auto scode=System.IO.ReadAll(fn)
		if !scode:
			return JS.Return('cannot read the file')
		struct TSyncStackItem
			string id,port
			string buf
			int pindent,strip_next
		auto stk=new TSyncStackItem[]
		auto sync_jobs=new TSyncStackItem[]
		for sline in scode.TokenizeEx("\r\n",scode.TOKENIZE_ALLOW_EMPTY|scode.TOKENIZE_INCLUDE_SEPARATOR)
			psync=sline.IndexOf('@sync_')
			if psync>=0:
				sync_op=0
				if sline[psync+6:].StartsWith('in='):
					//input knob, insert as is, *WITHOUT THE NEWLINE*
					if stk.n:
						s_port=sline[psync+9:]
						if s_port.n&&s_port.back()=='\n':
							s_port.n--
						if s_port.n&&s_port.back()=='\r':
							s_port.n--
						pspace=s_port.IndexOf(' ')
						if pspace>=0:
							pt=psync-s_port[:pspace-1].as(int)
							if pt>=0&&pt<psync:
								//indent plus port name
								sindent=sline[:pt-1]
								stk[stk.n-1].buf.push(sindent[min(stk[stk.n-1].pindent,CountLeadingSpaces(sindent)):])
								stk[stk.n-1].buf.push(s_port[pspace+1:])
								stk[stk.n-1].strip_next=1
								continue
				else if sline[psync+6:].StartsWith('push='):
					sync_op=1
				else if sline[psync+6:].StartsWith('pop='):
					sync_op=-1
				if sync_op!=0:
					ssyncdata=sline[psync+(sync_op>0?11:10):]
					pportid=ssyncdata.IndexOf('?')
					if pportid>=0:
						s_node=ssyncdata[:pportid-1]
						s_port=ssyncdata[pportid+1:]
						if s_port.n&&s_port.back()=='\n':
							s_port.n--
						if s_port.n&&s_port.back()=='\r':
							s_port.n--
						if sync_op==1:
							stk.push(TSyncStackItem(){
								id:s_node,port:s_port,
								buf:new string,
								pindent:CountLeadingSpaces(sline)
							})
						else
							//in pop, s_port contains another = and we need to keep whatever coming after it, with the newline
							//pequ=s_port.IndexOf('=')
							//if pequ>=0:
							//	if stk.n:
							//		stk[stk.n-1].buf.push(ssyncdata[pportid+1+pequ+1:])
							//	s_port=s_port[:pequ-1]
							if !stk.n:return JS.Return(FormatAsText("'",sline[psync:],"' does't match any sync_push"))
							si=stk.pop()
							s_node0=si.id
							s_port0=si.port
							if s_node0!=s_node||s_port0!=s_port:
								return JS.Return(FormatAsText("'",sline[psync:],"' does't match '@sync_push="+s_node0+"="+s_port0+"'"))
							//create jobs on pop... no real difference though
							sync_jobs.push(si)
						continue
			if stk.n:
				//parse mid-line sync tags
				auto s=sline[min(stk[stk.n-1].strip_next?0x7fffffff:stk[stk.n-1].pindent,CountLeadingSpaces(sline)):]
				auto buf=stk[stk.n-1].buf
				stk[stk.n-1].strip_next=0
				for(;;){
					pmidline_tag=s.IndexOf("/*[")
					if pmidline_tag<0:
						buf.push(s)
						break
					//////
					buf.push(s[:pmidline_tag-1])
					s=s[pmidline_tag+3:]
					pmidline_tag=s.IndexOf("*/")
					if pmidline_tag<0:
						buf.push("/*[")
						continue
					//////
					buf.push(s[:pmidline_tag-1])
					s=s[pmidline_tag+2:]
					pmidline_tag=s.IndexOf('/*]*/')
					if pmidline_tag<0:
						buf.push("*/")
						continue
					s=s[pmidline_tag+5:]
				}
		if stk.n:
			si=stk.pop()
			s_node0=si.id
			s_port0=si.port
			return JS.Return(FormatAsText("'@sync_push="+s_node0+"="+s_port0+"' has no matching push"))
		sync_jobs.Sort(inline(a,b){return a.id<b.id||a.id==b.id&&a.port<b.port})
		//merge with existing in-file data, apply the changes to unsaved editor windows
		auto ret=JS.NewArray();
		auto lg_ret=0
		for id,grp in sync_jobs.Groupby(byMember("id"))
			ret_i=JS.New()
			ret_i["m_id"]=id
			obj_port_jobs=JS.NewArray()
			ret_i["m_port_jobs"]=obj_port_jobs
			nobj=0
			for si in grp
				obj_port_jobs[nobj++]=si.port
				obj_port_jobs[nobj++]=si.buf
			ret[lg_ret++]=ret_i
		return JS.Return(ret)
	}
	JS_UI["SyncOneFile"]=function(JSContext JS){
		ed=JS.Param(0).as(TextBox.detail.CEditableText)
		if !ed:return 0
		port2code=JS.Param(1).as(JSObject)
		if !port2code:return 0
		////////////////////////////
		//per-line port reconstruction
		scode=ed.GetText(0LL,ed.GetTextSize())
		scode_new=new string
		do_echo=0
		for sline,I in scode.TokenizeEx("\r\n",scode.TOKENIZE_ALLOW_EMPTY|scode.TOKENIZE_INCLUDE_SEPARATOR)
			//preserve the @in and @sticker stuff
			if sline.IndexOf('@in=')>=0||sline.IndexOf('@sticker=')>=0:
				scode_new.push(sline)
				continue
			else 
				pport=sline.IndexOf('@out=')
				if pport>=0:
					scode_new.push(sline)
					//reconstruct from the sync job... if we could find the port
					s_portname=sline[pport+5:]
					pcomma=s_portname.IndexOf(',')
					if pcomma>=0:
						s_portname.n=pcomma
					s_code=port2code[s_portname].as(string)
					if s_code:
						scode_new.push(s_code)
						if s_code.n&&s_code.back()!='\n':
							scode_new.push('\n')
						do_echo=0
					else
						do_echo=1
				else
					if do_echo:scode_new.push(sline)
		////////////////////////////
		dmp_diff_to_i64_list=__c_function(int,"dmp_diff_to_i64_list","dmp.h","c_files","dmp.c")
		dmp_diff_new=__c_function(int,"dmp_diff_new","dmp.h","c_files","dmp.c")
		dmp_diff_free=__c_function(int,"dmp_diff_free","dmp.h","c_files","dmp.c")
		diff=NULL
		dmp_diff_new(&diff,NULL, scode,scode.n, scode_new,scode_new.n);
		if !diff:return 0
		n=dmp_diff_to_i64_list(diff,NULL)
		rawdiff=new i64[n]
		n=dmp_diff_to_i64_list(diff,rawdiff)
		assert(n==rawdiff.n)
		dmp_diff_free(diff)
		diff=NULL
		////////////////////////////
		ops=new TextBox.detail.TEditop[]
		for i=0:3:rawdiff.n-3
			if rawdiff[i+2]:
				//insert
				ops.push(TextBox.detail.TEditop(){
					ccnt:rawdiff[i+0],
					sz:0LL,
					s:scode_new[iptr(rawdiff[i+2])-scode_new.d:iptr(rawdiff[i+2]+rawdiff[i+1])-scode_new.d-1]
				})
			else
				//delete
				ops.push(TextBox.detail.TEditop(){
					ccnt:rawdiff[i+0],
					sz:rawdiff[i+1],
				})
		if ops.n:
			ed.Edit(ops)
		//we need to keep scode_new until here - there are references inside it... well, it's represented as slices
		//scode_new.discard()
		scode.discard();
		return JS.Return(1)
	}
});

(function(){
	//Gui2D.ProvideGLFunctions()
	JS_script_sandbox=new JSContext
	sbox=setupModuleSystem(JS,1)
	if Platform.IS_MOBILE:
		sbox.UILoadZip(string.NULL)
	else
		sbox.UILoadStaticZip()
	/////////////
	jsio=JS.New()
	JS.GetGlobal()["IO"]=jsio
	jsio["ReadAll"]=function(JSContext JS){
		fn=JS.Param(0).or(new string)
		if !fn:return 0
		ret=System.IO.ReadAll(fn)
		if !ret:
			return 0
		else
			//return JS.Return(new(ret))
			return JS.Return(ret)
	}
	jsio["UIReadAll"]=function(JSContext JS){
		fn=JS.Param(0).or(new string)
		if !fn:return 0
		ret=sbox.UIReadAll(fn)
		if !ret:
			return 0
		else
			return JS.Return(ret)
	}
	jsio["ReadLimited"]=function(JSContext JS){
		fn=JS.Param(0).or(new string)
		sz=JS.Param(1).as(iptr)
		if !fn||!(sz>0):return 0
		auto f=System.IO.OpenFile(fn)
		if f:
			auto s=f.Read(sz)
			f.Close()
			return JS.Return(s)
		else
			return 0
	}
	jsio["CreateDirectory"]=function(JSContext JS){
		fn=JS.Param(0).as(string)
		if !fn:return 0
		return JS.Return(System.IO.CreateDirectory(fn))
	}
	jsio["CreateFile"]=function(JSContext JS){
		fn=JS.Param(0).or(new string)
		if !fn:return 0
		data_u8=JS.Param(1).as(u8[])
		if data_u8:
			data=data_u8.ConvertToAsBinary(i8)
		else
			data=JS.Param(1).or(new string)
		f=System.IO.CreateFile(fn)
		if f:
			lg=f.Write(data)
			f.Close()
			return JS.Return(lg)
		else
			return 0
	}
	jsio["DeleteFile"]=function(JSContext JS){
		fn=JS.Param(0).or(new string)
		if !fn:return 0
		return JS.Return(System.IO.DeleteFile(fn))
	}
	jsio["GetFileTimestamp"]=function(JSContext JS){
		fn=JS.Param(0).or(new string)
		foreach fn,fi in System.IO.EnumFiles(fn,System.IO.ENUM_FILE)
			return JS.Return(fi.latest_time())
		return 0
	}
	jsio["FileExists"]=function(JSContext JS){
		fn=JS.Param(0).or(new string)
		return JS.Return(System.IO.FileExists(fn))
	}
	jsio["DirExists"]=function(JSContext JS){
		fn=JS.Param(0).or(new string)
		return JS.Return(System.IO.DirExists(fn))
	}
	jsio["ProcessUnixFileName"]=function(JSContext JS){
		fn0=JS.Param(0).as(string)
		if !fn0:
			return 0
		else
			if Platform.IS_UNIX:
				if fn0.StartsWith("~"):
					fn0="${HOME}"+fn0[1:]
			else if Platform.IS_WINDOWS:
				if fn0.StartsWith("~"):
					fn0="%UserProfile%"+fn0[1:]
			return JS.Return(System.Env.ExpandEnvironmentStrings(fn0))
	}
	jsio["GetEnvironmentVariable"]=function(JSContext JS){
		s=JS.Param(0).as(string)
		if !s:
			return 0
		else
			return JS.Return(System.Env.GetEnvironmentVariable(s))
	}
	jsio["NormalizeFileName"]=function(JSContext JS){
		fn0=JS.Param(0).as(string)
		is_win_cased=JS.Param(1).or(0)
		if !fn0:return 0
		if Platform.IS_WINDOWS&&is_win_cased:
			foreach fn in System.IO.EnumFiles(fn0,System.IO.ENUM_FILE)
				return JS.Return(fn)
		return JS.Return(System.Env.NormalizeFileName(fn0))
	}
	jsio["CreateEnumFileContext"]=function(JSContext JS){
		fn0=JS.Param(0).as(string)
		flags=JS.Param(1).or(0)
		if !fn0:return 0
		fnextfile=System.IO.CreateEnumFileContext(fn0,flags)
		//we cannot create new functions willy-nilly!
		return JS.Return(function(JSContext JS){
			auto fn
			auto fi
			(fn,fi)=fnextfile()
			if !fn:return 0
			ret=JS.New()
			ret["name"]=fn
			ret["size"]=fi.size
			ret["attr"]=fi.attr
			ret["is_dir"]=fi.is_dir()
			ret["time"]=System.Time.ToLocalTime(i64(fi.latest_time()))
			return JS.Return(ret)
		})
	}
	jsio["WallClockTime"]=function(JSContext JS){
		return JS.Return(System.Time.ToLocalTime(System.Time.WallClockTime()))
	}
	/////////////
	dname_base=0
	jsio["GetNewDocumentName"]=function(JSContext JS){
		fn_base=JS.Param(0).as(string)
		s_ext=JS.Param(1).as(string)
		s_path_hint=JS.Param(2).or("document")
		if s_path_hint=="temp":
			return JS.Return(System.Env.GetTempFileName(s_ext))
		if Platform.IS_WINDOWS:
			s_userdir=System.Env.ExpandEnvironmentStrings(string("%USERPROFILE%"))
			if !s_userdir.n||s_userdir[0]=='%':
				s_userdir=System.Env.ExpandEnvironmentStrings(string("%SystemDrive%%HOMEPATH%"))
			if s_path_hint=="pictures":
				s_userdir.push("\\Pictures")
			else
				s_userdir.push("\\Documents")
			if !System.IO.DirExists(s_userdir):
				//no "My Pictures"
				s_userdir=new(".")
			else
				s_userdir=s_userdir.Replace(["\\","/"])
		else
			s_userdir=System.Env.ExpandEnvironmentStrings("${HOME}")
		if !fn_base||!s_ext:
			return JS.Return(s_userdir)
		if s_userdir.n&&s_userdir.back()=='/':
			fn_base=s_userdir+fn_base
		else
			fn_base=s_userdir+"/"+fn_base
		for(;;)
			fn=FormatAsText(fn_base,formatNumber(dname_base,{base:16,align:4}),".",s_ext)
			dname_base++
			if System.IO.FileExists(fn):continue
			return JS.Return(fn)
	}
	jsio["GetExecutablePath"]=function(JSContext JS){
		if Platform.IS_MOBILE:
			return 0
		else
			return JS.Return(System.Env.GetExecutablePath())
	}
	jsio["GetFileSize"]=function(JSContext JS){
		fn=JS.Param(0).as(string)
		return JS.Return(System.IO.GetFileSize(fn))
	}
	jsio["m_my_name"]=System.Env.GetExecutableName()
	jsio["m_argv"]=System.Console.GetCommandLine()
	jsio["GetStoragePath"]=function(JSContext JS){
		return JS.Return(System.Env.GetStoragePath())
	}
	/////////////
	if Platform.IS_WINDOWS:
		jsio["GetPID"]=function(JSContext JS){
			GetCurrentProcessId=__c_function(int,"GetCurrentProcessId","windows.h")
			return JS.Return(GetCurrentProcessId());
		}
	else
		jsio["GetPID"]=function(JSContext JS){
			getpid=__c_function(iptr,"getpid","unistd.h")
			return JS.Return(getpid());
		}
	if Platform.IS_WINDOWS:
		//osal_DoFileDialogWin=__c_function(int,"osal_DoFileDialogWin","filedlg.h","c_files","filedlg.c")
		//__generate_json("lib_files","comdlg32.lib")
		jsio["WIN_SHChangeNotify"]=function(JSContext JS){
			SHChangeNotify=__c_function(int,"SHChangeNotify","Shlobj.h")
			SHCNE_ASSOCCHANGED=0x8000000
			SHCNF_IDLIST=0
			SHChangeNotify(SHCNE_ASSOCCHANGED,SHCNF_IDLIST,NULL,NULL);
			return 0;
		}
		jsio["IsFirstInstance"]=function(JSContext JS){
			OpenMutex=__c_function(__pointer,"OpenMutexA","windows.h")
			CreateMutex=__c_function(__pointer,"CreateMutexA","windows.h")
			CloseHandle=__c_function(int,"CloseHandle","windows.h")
			s_mutex_name=JS.Param(0).asCString()
			MUTEX_ALL_ACCESS= 0x1f0001
			handle=OpenMutex(MUTEX_ALL_ACCESS,0,s_mutex_name);
			if !handle:
				CreateMutex(0,0,s_mutex_name)
				return JS.Return(1)
			else
				CloseHandle(handle)
				return 0
		}
		jsio["SetForegroundProcess"]=function(JSContext JS){
			__C(int,"@global:
			BOOL CALLBACK sfp_enumproc(HWND hw,LPARAM lp){
				if (IsWindowVisible(hw) && !GetParent(hw) && !GetWindow(hw,GW_OWNER)){
					int pid=0;
					GetWindowThreadProcessId(hw,&pid);
					if(pid==lp){
						SetForegroundWindow(hw);
						if(IsIconic(hw)){
							ShowWindow(hw,SW_SHOWNORMAL);
						}
						return 0;
					};
				}
				return 1;
			}
			int SetForegroundProcess(int pid){
				return !EnumWindows(sfp_enumproc,pid);
			}");
			pid=JS.Param(0).as(int)
			SetForegroundProcess=__c_function(int,"SetForegroundProcess","windows.h")
			return JS.Return(SetForegroundProcess(pid))
		}
		jsio["GetUserLanguage"]=function(JSContext JS){
			GetUserDefaultUILanguage=__c_function(int,"GetUserDefaultUILanguage","windows.h")
			sret="en_us"
			langid=GetUserDefaultUILanguage()
			if (langid&0x3ff)==4:
				//Chinese
				if langid!=2052&&langid!=4:
					sret="zh_tw"
				else
					sret="zh_cn"
			else if (langid&0x3ff)==0x11:
				sret="ja_jp"
			return JS.Return(sret)
		}
	else if Platform.ARCH=="mac":
		//osal_DoFileDialogMac=__c_function(int,"osal_DoFileDialogMac","filedlg.h","c_files","filedlg_mac.m")
		//__generate_json("mac_frameworks","System/Library/Frameworks/AppKit.framework")
	if Platform.IS_MOBILE||Platform.ARCH=="rasppi"||Platform.ARCH=="web":
		jsio["DoFileDialog"]=function(JSContext JS){
			return 0
		}
	else
		jsio["DoFileDialog"]=function(JSContext JS){
			is_save=JS.Param(0).or(0)
			sfilters=JS.Param(1).as(string)
			spath=JS.Param(2).as(string)
			return JS.Return(DoFileDialog(is_save,sfilters,spath))
		}
	/////////////
	auto shellcmd(JSObject shell_args,int do_system)
		if !shell_args:
			return JS.ReturnError("invalid shell arguments - it must be an object")
		//properly quote the args
		n=shell_args.length()
		if !(n>0):
			return JS.ReturnError("invalid shell arguments - it must be an array object of positive length")
		scmd=new string
		for i=0:n-1
			s_args_i=shell_args[i].as(string)
			if Platform.IS_WINDOWS:
				if !i:s_args_i=s_args_i.Replace(["/","\\"])
			if s_args_i.IndexOf(' ')>=0||s_args_i.IndexOf('&')>=0:
				s_args_i="\""+genString(s_args_i)+"\""
			if i:scmd.push(' ')
			scmd.push(s_args_i)
		if do_system:
			scmd.push(char(0))
			return JS.Return(c_system(scmd))
		else
			return JS.Return(scmd)
	jsio["Shell"]=function(JSContext JS){
		auto shell_args=JS.Param(0).as(JSObject)
		return shellcmd(shell_args,1)
	}
	jsio["ShellCmd"]=function(JSContext JS){
		auto shell_args=JS.Param(0).as(JSObject)
		return shellcmd(shell_args,0)
	}
	/////////////
	class CProcessWrapper
		System.Processes.CProcess proc
		JS_Read=function(JSContext JS){
			auto n=JS.Param(0).as(iptr)
			if proc.pipe.WouldBlock():return 0
			//line-based parsing? do it in JS
			s=proc.pipe.Read(n)
			if Platform.IS_WINDOWS:
				s=Encoding.OSConvertString(0,"",s)
			//System.Algorithm.NativeToUtf8()
			return JS.Return(s)
		}
		JS_IsRunning=function(JSContext JS){
			return JS.Return(proc.isRunning())
		}
		JS_ExitCode=function(JSContext JS){
			return JS.Return(proc.exit_code())
		}
		JS_Terminate=function(JSContext JS){
			proc.Terminate()
			return 0
		}
		JS_WaitForever=function(JSContext JS){
			proc.WaitForever()
			return 0
		}
		__JS_prototype=function(JSObject proto){
			proto.ExportMethod(this,"Read",JS_Read)
			proto.ExportMethod(this,"GetExitCode",JS_ExitCode)
			proto.ExportMethod(this,"IsRunning",JS_IsRunning)
			proto.ExportMethod(this,"Terminate",JS_Terminate)
			proto.ExportMethod(this,"WaitForever",JS_WaitForever)
		}
	jsio["RunProcess"]=function(JSContext JS){
		auto shell_args=JS.Param(0).as(JSObject)
		auto spath=JS.Param(1).or(".")
		auto show=JS.Param(2).or(1)
		n=shell_args["length"].as(iptr)
		args=[shell_args[i].as(string) for i=0:n-1]
		pproc=System.Processes.Run(args,spath,show&1,show&2?"new_job":"new_job,new_console")
		if !pproc:
			//job object creation may fail
			pproc=System.Processes.Run(args,spath,show&1,show&2?"":"new_console")
		if !pproc:
			return 0
		return JS.Return(new CProcessWrapper(){proc:pproc})
	}
	jsio["SetCurrentDirectory"]=function(JSContext JS){
		auto s=JS.Param(0).as(string)
		if !s:return 0;
		return JS.Return(System.IO.SetCurrentDirectory(s));
	}
	jsio["RunToolRedirected"]=function(JSContext JS){
		auto shell_args=JS.Param(0).as(JSObject)
		auto spath=JS.Param(1).or(".")
		auto show=JS.Param(2).or(1)
		auto n=shell_args.length()
		auto args=[shell_args[i].as(string) for i=0:n-1]
		foreach s,I in args
			if !s:
				return JS.ReturnError("bad args")
		pproc=System.Processes.RunPiped(args,spath,show,"new_job,output,error")
		if !pproc:
			//job object creation may fail
			pproc=System.Processes.RunPiped(args,spath,show,"output,error")
		if !pproc:
			return 0
		return JS.Return(new CProcessWrapper(){proc:pproc})
	}
	/////////////
	Duktape=JS.GetGlobal()["Duktape"].as(JSObject)
	Duktape["__utf8_fromCharCode"]=function(JSContext JS){
		ch=JS.Param(0).or(0)
		return JS.Return(System.Algorithm.Unicode32ToUtf8([ch]))
	}
	Duktape["__commonPrefixLength"]=function(JSContext JS){
		s0=JS.Param(0).or("")
		s1=JS.Param(1).or("")
		lg=0L
		for i=0:min(s0.n,s1.n)-1
			if s0[i]!=s1[i]:break
			lg=i+1
		return JS.Return(lg)
	}
	Duktape_sandbox=JS_script_sandbox.GetGlobal()["Duktape"].as(JSObject)
	JS_script_sandbox.evalVoid("Duktape.__eval_expr=function(){try{var ret=JSON.stringify(eval(Duktape.__code));Duktape.__error=undefined;return ret;}catch(e){Duktape.__error=e.message;return undefined;}}","<eval-sandbox>")
	Duktape["__eval_expr_sandbox"]=function(JSContext JS){
		s=JS.Param(0).as(string)
		Duktape_sandbox["__code"]=s;
		s_ret=JS_script_sandbox.eval(string,"Duktape.__eval_expr()")
		if s_ret:
			return JS.Return(s_ret)
		else
			s_error=Duktape_sandbox["__error"].as(string)
			if s_error:
				return JS.ReturnError(s_error)
		return 0
	}
	/////////////
	s_storage_path=System.Env.GetStoragePath()
	{
		if !System.IO.DirExists(s_storage_path+"/dict"):
			System.IO.CreateDirectory(s_storage_path+"/dict")
		if !System.IO.FileExists(s_storage_path+"/dict/en_us.aff")
			auto f=System.IO.CreateFile(s_storage_path+"/dict/en_us.aff")
			if f:
				auto s=sbox.UIReadAll("res/misc/dict/en_us.aff")
				f.Write(s)
				f.Close()
		if !System.IO.FileExists(s_storage_path+"/dict/en_us.dic")
			auto f=System.IO.CreateFile(s_storage_path+"/dict/en_us.dic")
			if f:
				auto s=sbox.UIReadAll("res/misc/dict/en_us.dic")
				f.Write(s)
				f.Close()
	}
	Gui2D.g_log_file=s_storage_path+"/log.txt"
	//for fn in sbox.m_ui_zip.AllFileNames()
	//	Writeln(fn)
	//Writeln('main: ',sbox.UIReadAll("res/main.js"))
	sbox.UIRunJS(JS,"res/main.js")
	//if Platform.IS_WINDOWS&&System.IO.FileExists(System.Env.GetExecutablePath()+"/opengl32.dll"):
	//	//LLVMPipe tends to crash
	//	ExitProcess(1)
})()
